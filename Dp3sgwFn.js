function __vite__mapDeps(indexes) {
    if (!__vite__mapDeps.viteFileDeps) {
        __vite__mapDeps.viteFileDeps = ["./DRSVZzvX.js", "./D_RATnym.js", "./DlAUqK2U.js", "./mfekxdxr.js", "./Icon.DBj6Hvvc.css", "./x_rD_Ya3.js", "./Cf4bMZVt.js", "./ProgressBar.BeqJrwiX.css", "./qmjGWB_1.js", "./Currency.CTPWYPAh.css", "./C8V467oI.js", "./Button.CJnUpIwh.css", "./Y6LB5-5f.js", "./CziIEY0o.js", "./Tooltip.DfVLoX8d.css", "./index.DcRVhpZm.css", "./BCulhAmO.js", "./u043iKQv.js", "./index.Bhv7IVG-.css", "./CDaE1xxE.js", "./ITVzfwOF.js", "./error.xPNhu7O0.css", "./DOffT44F.js", "./CPlt8Q36.js", "./boost.Dgo0MpQc.css", "./BtSe6vDq.js", "./x83sNqLH.js", "./qd3QrqfA.js", "./C-C86Gx0.js", "./q6Gp6DWr.js", "./BmsYybcI.js", "./PendingClaim.BHrXXo66.css", "./DkqXVyL4.js", "./POsysFzo.js", "./CBGuO4Uu.js", "./BqqdoD_D.js", "./Quest.Clb2cp9s.css", "./index.BsfnVORI.css", "./TaH7hA6k.js", "./BlR6WwWl.js", "./Widget.BQL6W8kR.css", "./BJC2-Jz8.js", "./index.DemT0ox7.css", "./overview.BOrtv34q.css", "./UslH2yVv.js", "./B85QUvmA.js", "./refer.CIBUbtWh.css", "./BMA4abMV.js", "./C8TEF1XU.js", "./index.C2DWaQzD.css", "./BvsFPunx.js", "./B350uSBM.js", "./Tabs.BKFRqxWD.css", "./Blwwd5cH.js", "./qV_gUD5v.js", "./C_0lvKsH.js", "./Avatar.HBxFa3OL.css", "./BxoDXYQU.js", "./B75z0i1w.js", "./IcnButton.uM2jPbDG.css", "./Pagination.CjqrFCRA.css", "./nLL-se3e.js", "./index.DKP5RkSz.css", "./DhJWq1T8.js", "./BIbnRTnL.js", "./CrsIpeO-.js", "./BrEG1xvv.js", "./BxLkGV0c.js", "./game-boost.B_kpBj18.css", "./BxxvWGPF.js", "./ClZpJimg.js", "./game.DNEwZn92.css", "./CZrXGl1Z.js", "./ihSNPY-u.js", "./Widget.BifSL7RF.css", "./BCJ15rM0.js", "./index.BZFGN6yo.css", "./B6WLvY07.js", "./index.DpZ-Qd2b.css", "./BHTI34Nq.js", "./lvl-info.CqM3WH1s.css", "./ew5ON6Jg.js", "./C4_OczyE.js", "./history.DmEDujMs.css", "./bRcxTqP0.js", "./index.CAZMZ_WT.css", "./xIlgjzeZ.js", "./tjR5YKRm.js", "./info.B4c1Jo_H.css", "./uWP3-j0i.js", "./B3S4fow_.js", "./lIMKAsBW.js", "./withdraw.CJMYxhPB.css", "./B6VUJOmQ.js", "./CO_HHqup.js", "./Cover.DBSvGDA8.css", "./Cbr12_Mb.js", "./SPPoints.DuWzvSIm.css", "./qW02vi4X.js", "./Ckp1gkBL.js", "./useGetQuest.CYjIn0-r.css", "./index.GLpB_q3T.css", "./CFXYgp9I.js", "./index.CM8PXiO1.css", "./-SXVdFqo.js", "./connect.BDZj4ukq.css", "./CanG2eKc.js", "./CnTddxGq.js", "./index.b0kzIEcx.css", "./BsLiiQf9.js", "./twitter-qr.C1bUCrdL.css", "./R7Bj7EkF.js", "./unfortunately.BwaCPHtC.css", "./ByzsbMhi.js", "./index.T8pg1vcS.css", "./CODubv1W.js", "./index.B2ZA5zzd.css", "./DnHc53EX.js", "./C1vQ2R6b.js", "./DzuNNOBc.js", "./CSq0OXW2.js", "./Bn75tDjZ.js", "./Line.bLsSCeNC.css", "./CSw4ceXU.js", "./TabEmptyContent.lcuLuP_B.css", "./index.Bt6IX86U.css", "./0rpJEqYI.js", "./index.KN2FKAck.css", "./bLKZshdW.js", "./BuM_0WuE.js", "./CF6fLyO5.js", "./Progress.Br2r9xqN.css", "./Info.aWlJUw0L.css", "./index.CEn6lkIA.css", "./CjGpVctZ.js", "./index.CXJrWlJ5.css", "./Boc6SjAf.js", "./D336uFEi.js", "./Toggle.C5W-SkYL.css", "./index.BHlfMbVV.css", "./DpgICpPI.js", "./index.B1KPnwQC.css", "./C_ei97nG.js", "./BzOeXX_R.js", "./index.B1LHOyeK.css", "./B8BQRA6-.js", "./CstqLvPg.js", "./DropDownList.CBfhaIse.css", "./index.Dmhpu5zP.css", "./4R4UHT6r.js", "./index.8IRh7774.css", "./n8ffhApi.js", "./index.CXjmQ0bH.css", "./Cviz7YWC.js", "./tPqNFg2l.js", "./MoreInfo.CPas3ZrI.css", "./index.BJvWKq9V.css", "./Cgxc4yiX.js", "./index.3rTaJwrP.css", "./DN83ABVv.js", "./Crj_7VuK.js", "./Profile.CkUFVQCi.css", "./index.BZbxkjas.css", "./BQyrV1Jw.js", "./qbVgkjYO.js", "./InputCustom.DtclBP49.css", "./ui.BvgDgrCz.css", "./iRb33dxa.js", "./history.C0k3ihxR.css", "./B7HM4yIT.js", "./index.DJl211HF.css", "./Dh1fxTJO.js", "./overview.B6Dp9f8h.css", "./Bi0AbUKn.js", "./XSVBfF8g.js", "./AllIcons.BA9jTKWm.css", "./BWazXSaF.js", "./default.Db-xMGpP.css", "./DRFzsTBt.js", "./error-404.JekaaCis.css", "./BR3gwn9N.js", "./error-500.CNP9nqm1.css"]
    }
    return indexes.map((i)=>__vite__mapDeps.viteFileDeps[i])
}
var Xo = (e,t,n)=>{
    if (!t.has(e))
        throw TypeError("Cannot " + n)
}
;
var Le = (e,t,n)=>(Xo(e, t, "read from private field"),
n ? n.call(e) : t.get(e))
  , je = (e,t,n)=>{
    if (t.has(e))
        throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
}
  , Rn = (e,t,n,r)=>(Xo(e, t, "write to private field"),
r ? r.call(e, n) : t.set(e, n),
n);
var on = (e,t,n)=>(Xo(e, t, "access private method"),
n);
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Xa(e, t) {
    const n = new Set(e.split(","));
    return t ? r=>n.has(r.toLowerCase()) : r=>n.has(r)
}
const pe = {}
  , sr = []
  , Ct = ()=>{}
  , gp = ()=>!1
  , as = e=>e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97)
  , Ya = e=>e.startsWith("onUpdate:")
  , we = Object.assign
  , Qa = (e,t)=>{
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
  , yp = Object.prototype.hasOwnProperty
  , oe = (e,t)=>yp.call(e, t)
  , K = Array.isArray
  , or = e=>Tr(e) === "[object Map]"
  , So = e=>Tr(e) === "[object Set]"
  , Qc = e=>Tr(e) === "[object Date]"
  , vp = e=>Tr(e) === "[object RegExp]"
  , Y = e=>typeof e == "function"
  , ye = e=>typeof e == "string"
  , _n = e=>typeof e == "symbol"
  , de = e=>e !== null && typeof e == "object"
  , Za = e=>(de(e) || Y(e)) && Y(e.then) && Y(e.catch)
  , uf = Object.prototype.toString
  , Tr = e=>uf.call(e)
  , bp = e=>Tr(e).slice(8, -1)
  , ff = e=>Tr(e) === "[object Object]"
  , ec = e=>ye(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e
  , ir = Xa(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , ko = e=>{
    const t = Object.create(null);
    return n=>t[n] || (t[n] = e(n))
}
  , wp = /-(\w)/g
  , Mt = ko(e=>e.replace(wp, (t,n)=>n ? n.toUpperCase() : ""))
  , Ep = /\B([A-Z])/g
  , Sn = ko(e=>e.replace(Ep, "-$1").toLowerCase())
  , Ro = ko(e=>e.charAt(0).toUpperCase() + e.slice(1))
  , Ws = ko(e=>e ? `on${Ro(e)}` : "")
  , Kt = (e,t)=>!Object.is(e, t)
  , ar = (e,t)=>{
    for (let n = 0; n < e.length; n++)
        e[n](t)
}
  , Zs = (e,t,n)=>{
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        value: n
    })
}
  , Yi = e=>{
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}
  , df = e=>{
    const t = ye(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
}
;
let Zc;
const hf = ()=>Zc || (Zc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function _r(e) {
    if (K(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n]
              , s = ye(r) ? Sp(r) : _r(r);
            if (s)
                for (const o in s)
                    t[o] = s[o]
        }
        return t
    } else if (ye(e) || de(e))
        return e
}
const Cp = /;(?![^(]*\))/g
  , Tp = /:([^]+)/
  , _p = /\/\*[^]*?\*\//g;
function Sp(e) {
    const t = {};
    return e.replace(_p, "").split(Cp).forEach(n=>{
        if (n) {
            const r = n.split(Tp);
            r.length > 1 && (t[r[0].trim()] = r[1].trim())
        }
    }
    ),
    t
}
function en(e) {
    let t = "";
    if (ye(e))
        t = e;
    else if (K(e))
        for (let n = 0; n < e.length; n++) {
            const r = en(e[n]);
            r && (t += r + " ")
        }
    else if (de(e))
        for (const n in e)
            e[n] && (t += n + " ");
    return t.trim()
}
function kp(e) {
    if (!e)
        return null;
    let {class: t, style: n} = e;
    return t && !ye(t) && (e.class = en(t)),
    n && (e.style = _r(n)),
    e
}
const Rp = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , Ap = Xa(Rp);
function pf(e) {
    return !!e || e === ""
}
function Pp(e, t) {
    if (e.length !== t.length)
        return !1;
    let n = !0;
    for (let r = 0; n && r < e.length; r++)
        n = Ao(e[r], t[r]);
    return n
}
function Ao(e, t) {
    if (e === t)
        return !0;
    let n = Qc(e)
      , r = Qc(t);
    if (n || r)
        return n && r ? e.getTime() === t.getTime() : !1;
    if (n = _n(e),
    r = _n(t),
    n || r)
        return e === t;
    if (n = K(e),
    r = K(t),
    n || r)
        return n && r ? Pp(e, t) : !1;
    if (n = de(e),
    r = de(t),
    n || r) {
        if (!n || !r)
            return !1;
        const s = Object.keys(e).length
          , o = Object.keys(t).length;
        if (s !== o)
            return !1;
        for (const i in e) {
            const a = e.hasOwnProperty(i)
              , l = t.hasOwnProperty(i);
            if (a && !l || !a && l || !Ao(e[i], t[i]))
                return !1
        }
    }
    return String(e) === String(t)
}
function mf(e, t) {
    return e.findIndex(n=>Ao(n, t))
}
const gf = e=>ye(e) ? e : e == null ? "" : K(e) || de(e) && (e.toString === uf || !Y(e.toString)) ? JSON.stringify(e, yf, 2) : String(e)
  , yf = (e,t)=>t && t.__v_isRef ? yf(e, t.value) : or(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce((n,[r,s],o)=>(n[Yo(r, o) + " =>"] = s,
    n), {})
} : So(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(n=>Yo(n))
} : _n(t) ? Yo(t) : de(t) && !K(t) && !ff(t) ? String(t) : t
  , Yo = (e,t="")=>{
    var n;
    return _n(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
}
;
/**
* @vue/reactivity v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let ut;
class vf {
    constructor(t=!1) {
        this.detached = t,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this.parent = ut,
        !t && ut && (this.index = (ut.scopes || (ut.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(t) {
        if (this._active) {
            const n = ut;
            try {
                return ut = this,
                t()
            } finally {
                ut = n
            }
        }
    }
    on() {
        ut = this
    }
    off() {
        ut = this.parent
    }
    stop(t) {
        if (this._active) {
            let n, r;
            for (n = 0,
            r = this.effects.length; n < r; n++)
                this.effects[n].stop();
            for (n = 0,
            r = this.cleanups.length; n < r; n++)
                this.cleanups[n]();
            if (this.scopes)
                for (n = 0,
                r = this.scopes.length; n < r; n++)
                    this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !t) {
                const s = this.parent.scopes.pop();
                s && s !== this && (this.parent.scopes[this.index] = s,
                s.index = this.index)
            }
            this.parent = void 0,
            this._active = !1
        }
    }
}
function tc(e) {
    return new vf(e)
}
function Op(e, t=ut) {
    t && t.active && t.effects.push(e)
}
function cs() {
    return ut
}
function Po(e) {
    ut && ut.cleanups.push(e)
}
let Fn;
class nc {
    constructor(t, n, r, s) {
        this.fn = t,
        this.trigger = n,
        this.scheduler = r,
        this.active = !0,
        this.deps = [],
        this._dirtyLevel = 4,
        this._trackId = 0,
        this._runnings = 0,
        this._shouldSchedule = !1,
        this._depsLength = 0,
        Op(this, s)
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1,
            qn();
            for (let t = 0; t < this._depsLength; t++) {
                const n = this.deps[t];
                if (n.computed && (Ip(n.computed),
                this._dirtyLevel >= 4))
                    break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0),
            Wn()
        }
        return this._dirtyLevel >= 4
    }
    set dirty(t) {
        this._dirtyLevel = t ? 4 : 0
    }
    run() {
        if (this._dirtyLevel = 0,
        !this.active)
            return this.fn();
        let t = En
          , n = Fn;
        try {
            return En = !0,
            Fn = this,
            this._runnings++,
            el(this),
            this.fn()
        } finally {
            tl(this),
            this._runnings--,
            Fn = n,
            En = t
        }
    }
    stop() {
        var t;
        this.active && (el(this),
        tl(this),
        (t = this.onStop) == null || t.call(this),
        this.active = !1)
    }
}
function Ip(e) {
    return e.value
}
function el(e) {
    e._trackId++,
    e._depsLength = 0
}
function tl(e) {
    if (e.deps.length > e._depsLength) {
        for (let t = e._depsLength; t < e.deps.length; t++)
            bf(e.deps[t], e);
        e.deps.length = e._depsLength
    }
}
function bf(e, t) {
    const n = e.get(t);
    n !== void 0 && t._trackId !== n && (e.delete(t),
    e.size === 0 && e.cleanup())
}
let En = !0
  , Qi = 0;
const wf = [];
function qn() {
    wf.push(En),
    En = !1
}
function Wn() {
    const e = wf.pop();
    En = e === void 0 ? !0 : e
}
function rc() {
    Qi++
}
function sc() {
    for (Qi--; !Qi && Zi.length; )
        Zi.shift()()
}
function Ef(e, t, n) {
    if (t.get(e) !== e._trackId) {
        t.set(e, e._trackId);
        const r = e.deps[e._depsLength];
        r !== t ? (r && bf(r, e),
        e.deps[e._depsLength++] = t) : e._depsLength++
    }
}
const Zi = [];
function Cf(e, t, n) {
    rc();
    for (const r of e.keys()) {
        let s;
        r._dirtyLevel < t && (s ?? (s = e.get(r) === r._trackId)) && (r._shouldSchedule || (r._shouldSchedule = r._dirtyLevel === 0),
        r._dirtyLevel = t),
        r._shouldSchedule && (s ?? (s = e.get(r) === r._trackId)) && (r.trigger(),
        (!r._runnings || r.allowRecurse) && r._dirtyLevel !== 2 && (r._shouldSchedule = !1,
        r.scheduler && Zi.push(r.scheduler)))
    }
    sc()
}
const Tf = (e,t)=>{
    const n = new Map;
    return n.cleanup = e,
    n.computed = t,
    n
}
  , eo = new WeakMap
  , Hn = Symbol("")
  , ea = Symbol("");
function He(e, t, n) {
    if (En && Fn) {
        let r = eo.get(e);
        r || eo.set(e, r = new Map);
        let s = r.get(n);
        s || r.set(n, s = Tf(()=>r.delete(n))),
        Ef(Fn, s)
    }
}
function Qt(e, t, n, r, s, o) {
    const i = eo.get(e);
    if (!i)
        return;
    let a = [];
    if (t === "clear")
        a = [...i.values()];
    else if (n === "length" && K(e)) {
        const l = Number(r);
        i.forEach((u,c)=>{
            (c === "length" || !_n(c) && c >= l) && a.push(u)
        }
        )
    } else
        switch (n !== void 0 && a.push(i.get(n)),
        t) {
        case "add":
            K(e) ? ec(n) && a.push(i.get("length")) : (a.push(i.get(Hn)),
            or(e) && a.push(i.get(ea)));
            break;
        case "delete":
            K(e) || (a.push(i.get(Hn)),
            or(e) && a.push(i.get(ea)));
            break;
        case "set":
            or(e) && a.push(i.get(Hn));
            break
        }
    rc();
    for (const l of a)
        l && Cf(l, 4);
    sc()
}
function Lp(e, t) {
    var n;
    return (n = eo.get(e)) == null ? void 0 : n.get(t)
}
const Np = Xa("__proto__,__v_isRef,__isVue")
  , _f = new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e !== "arguments" && e !== "caller").map(e=>Symbol[e]).filter(_n))
  , nl = Mp();
function Mp() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t=>{
        e[t] = function(...n) {
            const r = ne(this);
            for (let o = 0, i = this.length; o < i; o++)
                He(r, "get", o + "");
            const s = r[t](...n);
            return s === -1 || s === !1 ? r[t](...n.map(ne)) : s
        }
    }
    ),
    ["push", "pop", "shift", "unshift", "splice"].forEach(t=>{
        e[t] = function(...n) {
            qn(),
            rc();
            const r = ne(this)[t].apply(this, n);
            return sc(),
            Wn(),
            r
        }
    }
    ),
    e
}
function Bp(e) {
    const t = ne(this);
    return He(t, "has", e),
    t.hasOwnProperty(e)
}
class Sf {
    constructor(t=!1, n=!1) {
        this._isReadonly = t,
        this._isShallow = n
    }
    get(t, n, r) {
        const s = this._isReadonly
          , o = this._isShallow;
        if (n === "__v_isReactive")
            return !s;
        if (n === "__v_isReadonly")
            return s;
        if (n === "__v_isShallow")
            return o;
        if (n === "__v_raw")
            return r === (s ? o ? Gp : Pf : o ? Af : Rf).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(r) ? t : void 0;
        const i = K(t);
        if (!s) {
            if (i && oe(nl, n))
                return Reflect.get(nl, n, r);
            if (n === "hasOwnProperty")
                return Bp
        }
        const a = Reflect.get(t, n, r);
        return (_n(n) ? _f.has(n) : Np(n)) || (s || He(t, "get", n),
        o) ? a : ve(a) ? i && ec(n) ? a : a.value : de(a) ? s ? Of(a) : nn(a) : a
    }
}
class kf extends Sf {
    constructor(t=!1) {
        super(!1, t)
    }
    set(t, n, r, s) {
        let o = t[n];
        if (!this._isShallow) {
            const l = Vn(o);
            if (!to(r) && !Vn(r) && (o = ne(o),
            r = ne(r)),
            !K(t) && ve(o) && !ve(r))
                return l ? !1 : (o.value = r,
                !0)
        }
        const i = K(t) && ec(n) ? Number(n) < t.length : oe(t, n)
          , a = Reflect.set(t, n, r, s);
        return t === ne(s) && (i ? Kt(r, o) && Qt(t, "set", n, r) : Qt(t, "add", n, r)),
        a
    }
    deleteProperty(t, n) {
        const r = oe(t, n);
        t[n];
        const s = Reflect.deleteProperty(t, n);
        return s && r && Qt(t, "delete", n, void 0),
        s
    }
    has(t, n) {
        const r = Reflect.has(t, n);
        return (!_n(n) || !_f.has(n)) && He(t, "has", n),
        r
    }
    ownKeys(t) {
        return He(t, "iterate", K(t) ? "length" : Hn),
        Reflect.ownKeys(t)
    }
}
class Dp extends Sf {
    constructor(t=!1) {
        super(!0, t)
    }
    set(t, n) {
        return !0
    }
    deleteProperty(t, n) {
        return !0
    }
}
const xp = new kf
  , Fp = new Dp
  , Hp = new kf(!0)
  , oc = e=>e
  , Oo = e=>Reflect.getPrototypeOf(e);
function ks(e, t, n=!1, r=!1) {
    e = e.__v_raw;
    const s = ne(e)
      , o = ne(t);
    n || (Kt(t, o) && He(s, "get", t),
    He(s, "get", o));
    const {has: i} = Oo(s)
      , a = r ? oc : n ? cc : Wr;
    if (i.call(s, t))
        return a(e.get(t));
    if (i.call(s, o))
        return a(e.get(o));
    e !== s && e.get(t)
}
function Rs(e, t=!1) {
    const n = this.__v_raw
      , r = ne(n)
      , s = ne(e);
    return t || (Kt(e, s) && He(r, "has", e),
    He(r, "has", s)),
    e === s ? n.has(e) : n.has(e) || n.has(s)
}
function As(e, t=!1) {
    return e = e.__v_raw,
    !t && He(ne(e), "iterate", Hn),
    Reflect.get(e, "size", e)
}
function rl(e) {
    e = ne(e);
    const t = ne(this);
    return Oo(t).has.call(t, e) || (t.add(e),
    Qt(t, "add", e, e)),
    this
}
function sl(e, t) {
    t = ne(t);
    const n = ne(this)
      , {has: r, get: s} = Oo(n);
    let o = r.call(n, e);
    o || (e = ne(e),
    o = r.call(n, e));
    const i = s.call(n, e);
    return n.set(e, t),
    o ? Kt(t, i) && Qt(n, "set", e, t) : Qt(n, "add", e, t),
    this
}
function ol(e) {
    const t = ne(this)
      , {has: n, get: r} = Oo(t);
    let s = n.call(t, e);
    s || (e = ne(e),
    s = n.call(t, e)),
    r && r.call(t, e);
    const o = t.delete(e);
    return s && Qt(t, "delete", e, void 0),
    o
}
function il() {
    const e = ne(this)
      , t = e.size !== 0
      , n = e.clear();
    return t && Qt(e, "clear", void 0, void 0),
    n
}
function Ps(e, t) {
    return function(r, s) {
        const o = this
          , i = o.__v_raw
          , a = ne(i)
          , l = t ? oc : e ? cc : Wr;
        return !e && He(a, "iterate", Hn),
        i.forEach((u,c)=>r.call(s, l(u), l(c), o))
    }
}
function Os(e, t, n) {
    return function(...r) {
        const s = this.__v_raw
          , o = ne(s)
          , i = or(o)
          , a = e === "entries" || e === Symbol.iterator && i
          , l = e === "keys" && i
          , u = s[e](...r)
          , c = n ? oc : t ? cc : Wr;
        return !t && He(o, "iterate", l ? ea : Hn),
        {
            next() {
                const {value: f, done: d} = u.next();
                return d ? {
                    value: f,
                    done: d
                } : {
                    value: a ? [c(f[0]), c(f[1])] : c(f),
                    done: d
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function an(e) {
    return function(...t) {
        return e === "delete" ? !1 : e === "clear" ? void 0 : this
    }
}
function $p() {
    const e = {
        get(o) {
            return ks(this, o)
        },
        get size() {
            return As(this)
        },
        has: Rs,
        add: rl,
        set: sl,
        delete: ol,
        clear: il,
        forEach: Ps(!1, !1)
    }
      , t = {
        get(o) {
            return ks(this, o, !1, !0)
        },
        get size() {
            return As(this)
        },
        has: Rs,
        add: rl,
        set: sl,
        delete: ol,
        clear: il,
        forEach: Ps(!1, !0)
    }
      , n = {
        get(o) {
            return ks(this, o, !0)
        },
        get size() {
            return As(this, !0)
        },
        has(o) {
            return Rs.call(this, o, !0)
        },
        add: an("add"),
        set: an("set"),
        delete: an("delete"),
        clear: an("clear"),
        forEach: Ps(!0, !1)
    }
      , r = {
        get(o) {
            return ks(this, o, !0, !0)
        },
        get size() {
            return As(this, !0)
        },
        has(o) {
            return Rs.call(this, o, !0)
        },
        add: an("add"),
        set: an("set"),
        delete: an("delete"),
        clear: an("clear"),
        forEach: Ps(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(o=>{
        e[o] = Os(o, !1, !1),
        n[o] = Os(o, !0, !1),
        t[o] = Os(o, !1, !0),
        r[o] = Os(o, !0, !0)
    }
    ),
    [e, n, t, r]
}
const [jp,Vp,Up,qp] = $p();
function ic(e, t) {
    const n = t ? e ? qp : Up : e ? Vp : jp;
    return (r,s,o)=>s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? r : Reflect.get(oe(n, s) && s in r ? n : r, s, o)
}
const Wp = {
    get: ic(!1, !1)
}
  , Kp = {
    get: ic(!1, !0)
}
  , zp = {
    get: ic(!0, !1)
}
  , Rf = new WeakMap
  , Af = new WeakMap
  , Pf = new WeakMap
  , Gp = new WeakMap;
function Jp(e) {
    switch (e) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function Xp(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : Jp(bp(e))
}
function nn(e) {
    return Vn(e) ? e : ac(e, !1, xp, Wp, Rf)
}
function ls(e) {
    return ac(e, !1, Hp, Kp, Af)
}
function Of(e) {
    return ac(e, !0, Fp, zp, Pf)
}
function ac(e, t, n, r, s) {
    if (!de(e) || e.__v_raw && !(t && e.__v_isReactive))
        return e;
    const o = s.get(e);
    if (o)
        return o;
    const i = Xp(e);
    if (i === 0)
        return e;
    const a = new Proxy(e,i === 2 ? r : n);
    return s.set(e, a),
    a
}
function Cn(e) {
    return Vn(e) ? Cn(e.__v_raw) : !!(e && e.__v_isReactive)
}
function Vn(e) {
    return !!(e && e.__v_isReadonly)
}
function to(e) {
    return !!(e && e.__v_isShallow)
}
function If(e) {
    return Cn(e) || Vn(e)
}
function ne(e) {
    const t = e && e.__v_raw;
    return t ? ne(t) : e
}
function Io(e) {
    return Object.isExtensible(e) && Zs(e, "__v_skip", !0),
    e
}
const Wr = e=>de(e) ? nn(e) : e
  , cc = e=>de(e) ? Of(e) : e;
class Lf {
    constructor(t, n, r, s) {
        this.getter = t,
        this._setter = n,
        this.dep = void 0,
        this.__v_isRef = !0,
        this.__v_isReadonly = !1,
        this.effect = new nc(()=>t(this._value),()=>Br(this, this.effect._dirtyLevel === 2 ? 2 : 3)),
        this.effect.computed = this,
        this.effect.active = this._cacheable = !s,
        this.__v_isReadonly = r
    }
    get value() {
        const t = ne(this);
        return (!t._cacheable || t.effect.dirty) && Kt(t._value, t._value = t.effect.run()) && Br(t, 4),
        lc(t),
        t.effect._dirtyLevel >= 2 && Br(t, 2),
        t._value
    }
    set value(t) {
        this._setter(t)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(t) {
        this.effect.dirty = t
    }
}
function Yp(e, t, n=!1) {
    let r, s;
    const o = Y(e);
    return o ? (r = e,
    s = Ct) : (r = e.get,
    s = e.set),
    new Lf(r,s,o || !s,n)
}
function lc(e) {
    var t;
    En && Fn && (e = ne(e),
    Ef(Fn, (t = e.dep) != null ? t : e.dep = Tf(()=>e.dep = void 0, e instanceof Lf ? e : void 0)))
}
function Br(e, t=4, n) {
    e = ne(e);
    const r = e.dep;
    r && Cf(r, t)
}
function ve(e) {
    return !!(e && e.__v_isRef === !0)
}
function pt(e) {
    return Nf(e, !1)
}
function Kr(e) {
    return Nf(e, !0)
}
function Nf(e, t) {
    return ve(e) ? e : new Qp(e,t)
}
class Qp {
    constructor(t, n) {
        this.__v_isShallow = n,
        this.dep = void 0,
        this.__v_isRef = !0,
        this._rawValue = n ? t : ne(t),
        this._value = n ? t : Wr(t)
    }
    get value() {
        return lc(this),
        this._value
    }
    set value(t) {
        const n = this.__v_isShallow || to(t) || Vn(t);
        t = n ? t : ne(t),
        Kt(t, this._rawValue) && (this._rawValue = t,
        this._value = n ? t : Wr(t),
        Br(this, 4))
    }
}
function he(e) {
    return ve(e) ? e.value : e
}
const Zp = {
    get: (e,t,n)=>he(Reflect.get(e, t, n)),
    set: (e,t,n,r)=>{
        const s = e[t];
        return ve(s) && !ve(n) ? (s.value = n,
        !0) : Reflect.set(e, t, n, r)
    }
};
function Mf(e) {
    return Cn(e) ? e : new Proxy(e,Zp)
}
class em {
    constructor(t) {
        this.dep = void 0,
        this.__v_isRef = !0;
        const {get: n, set: r} = t(()=>lc(this), ()=>Br(this));
        this._get = n,
        this._set = r
    }
    get value() {
        return this._get()
    }
    set value(t) {
        this._set(t)
    }
}
function Bf(e) {
    return new em(e)
}
function tm(e) {
    const t = K(e) ? new Array(e.length) : {};
    for (const n in e)
        t[n] = xf(e, n);
    return t
}
class nm {
    constructor(t, n, r) {
        this._object = t,
        this._key = n,
        this._defaultValue = r,
        this.__v_isRef = !0
    }
    get value() {
        const t = this._object[this._key];
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return Lp(ne(this._object), this._key)
    }
}
class rm {
    constructor(t) {
        this._getter = t,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}
function Df(e, t, n) {
    return ve(e) ? e : Y(e) ? new rm(e) : de(e) && arguments.length > 1 ? xf(e, t, n) : pt(e)
}
function xf(e, t, n) {
    const r = e[t];
    return ve(r) ? r : new nm(e,t,n)
}
/**
* @vue/runtime-core v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Tn(e, t, n, r) {
    try {
        return r ? e(...r) : e()
    } catch (s) {
        Sr(s, t, n)
    }
}
function _t(e, t, n, r) {
    if (Y(e)) {
        const o = Tn(e, t, n, r);
        return o && Za(o) && o.catch(i=>{
            Sr(i, t, n)
        }
        ),
        o
    }
    const s = [];
    for (let o = 0; o < e.length; o++)
        s.push(_t(e[o], t, n, r));
    return s
}
function Sr(e, t, n, r=!0) {
    const s = t ? t.vnode : null;
    if (t) {
        let o = t.parent;
        const i = t.proxy
          , a = `https://vuejs.org/error-reference/#runtime-${n}`;
        for (; o; ) {
            const u = o.ec;
            if (u) {
                for (let c = 0; c < u.length; c++)
                    if (u[c](e, i, a) === !1)
                        return
            }
            o = o.parent
        }
        const l = t.appContext.config.errorHandler;
        if (l) {
            Tn(l, null, 10, [e, i, a]);
            return
        }
    }
    sm(e, n, s, r)
}
function sm(e, t, n, r=!0) {
    console.error(e)
}
let zr = !1
  , ta = !1;
const Ne = [];
let Ut = 0;
const cr = [];
let hn = null
  , Mn = 0;
const Ff = Promise.resolve();
let uc = null;
function Dt(e) {
    const t = uc || Ff;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function om(e) {
    let t = Ut + 1
      , n = Ne.length;
    for (; t < n; ) {
        const r = t + n >>> 1
          , s = Ne[r]
          , o = Gr(s);
        o < e || o === e && s.pre ? t = r + 1 : n = r
    }
    return t
}
function Lo(e) {
    (!Ne.length || !Ne.includes(e, zr && e.allowRecurse ? Ut + 1 : Ut)) && (e.id == null ? Ne.push(e) : Ne.splice(om(e.id), 0, e),
    Hf())
}
function Hf() {
    !zr && !ta && (ta = !0,
    uc = Ff.then($f))
}
function im(e) {
    const t = Ne.indexOf(e);
    t > Ut && Ne.splice(t, 1)
}
function na(e) {
    K(e) ? cr.push(...e) : (!hn || !hn.includes(e, e.allowRecurse ? Mn + 1 : Mn)) && cr.push(e),
    Hf()
}
function al(e, t, n=zr ? Ut + 1 : 0) {
    for (; n < Ne.length; n++) {
        const r = Ne[n];
        if (r && r.pre) {
            if (e && r.id !== e.uid)
                continue;
            Ne.splice(n, 1),
            n--,
            r()
        }
    }
}
function no(e) {
    if (cr.length) {
        const t = [...new Set(cr)].sort((n,r)=>Gr(n) - Gr(r));
        if (cr.length = 0,
        hn) {
            hn.push(...t);
            return
        }
        for (hn = t,
        Mn = 0; Mn < hn.length; Mn++)
            hn[Mn]();
        hn = null,
        Mn = 0
    }
}
const Gr = e=>e.id == null ? 1 / 0 : e.id
  , am = (e,t)=>{
    const n = Gr(e) - Gr(t);
    if (n === 0) {
        if (e.pre && !t.pre)
            return -1;
        if (t.pre && !e.pre)
            return 1
    }
    return n
}
;
function $f(e) {
    ta = !1,
    zr = !0,
    Ne.sort(am);
    try {
        for (Ut = 0; Ut < Ne.length; Ut++) {
            const t = Ne[Ut];
            t && t.active !== !1 && Tn(t, null, 14)
        }
    } finally {
        Ut = 0,
        Ne.length = 0,
        no(),
        zr = !1,
        uc = null,
        (Ne.length || cr.length) && $f()
    }
}
function cm(e, t, ...n) {
    if (e.isUnmounted)
        return;
    const r = e.vnode.props || pe;
    let s = n;
    const o = t.startsWith("update:")
      , i = o && t.slice(7);
    if (i && i in r) {
        const c = `${i === "modelValue" ? "model" : i}Modifiers`
          , {number: f, trim: d} = r[c] || pe;
        d && (s = n.map(h=>ye(h) ? h.trim() : h)),
        f && (s = n.map(Yi))
    }
    let a, l = r[a = Ws(t)] || r[a = Ws(Mt(t))];
    !l && o && (l = r[a = Ws(Sn(t))]),
    l && _t(l, e, 6, s);
    const u = r[a + "Once"];
    if (u) {
        if (!e.emitted)
            e.emitted = {};
        else if (e.emitted[a])
            return;
        e.emitted[a] = !0,
        _t(u, e, 6, s)
    }
}
function jf(e, t, n=!1) {
    const r = t.emitsCache
      , s = r.get(e);
    if (s !== void 0)
        return s;
    const o = e.emits;
    let i = {}
      , a = !1;
    if (!Y(e)) {
        const l = u=>{
            const c = jf(u, t, !0);
            c && (a = !0,
            we(i, c))
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(l),
        e.extends && l(e.extends),
        e.mixins && e.mixins.forEach(l)
    }
    return !o && !a ? (de(e) && r.set(e, null),
    null) : (K(o) ? o.forEach(l=>i[l] = null) : we(i, o),
    de(e) && r.set(e, i),
    i)
}
function No(e, t) {
    return !e || !as(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""),
    oe(e, t[0].toLowerCase() + t.slice(1)) || oe(e, Sn(t)) || oe(e, t))
}
let Ee = null
  , Mo = null;
function ro(e) {
    const t = Ee;
    return Ee = e,
    Mo = e && e.type.__scopeId || null,
    t
}
function UT(e) {
    Mo = e
}
function qT() {
    Mo = null
}
const WT = e=>kn;
function kn(e, t=Ee, n) {
    if (!t || e._n)
        return e;
    const r = (...s)=>{
        r._d && Tl(-1);
        const o = ro(t);
        let i;
        try {
            i = e(...s)
        } finally {
            ro(o),
            r._d && Tl(1)
        }
        return i
    }
    ;
    return r._n = !0,
    r._c = !0,
    r._d = !0,
    r
}
function Qo(e) {
    const {type: t, vnode: n, proxy: r, withProxy: s, props: o, propsOptions: [i], slots: a, attrs: l, emit: u, render: c, renderCache: f, data: d, setupState: h, ctx: m, inheritAttrs: v} = e;
    let T, k;
    const b = ro(e);
    try {
        if (n.shapeFlag & 4) {
            const w = s || r
              , E = w;
            T = Et(c.call(E, w, f, o, h, d, m)),
            k = l
        } else {
            const w = t;
            T = Et(w.length > 1 ? w(o, {
                attrs: l,
                slots: a,
                emit: u
            }) : w(o, null)),
            k = t.props ? l : um(l)
        }
    } catch (w) {
        Hr.length = 0,
        Sr(w, e, 1),
        T = ce(Be)
    }
    let y = T;
    if (k && v !== !1) {
        const w = Object.keys(k)
          , {shapeFlag: E} = y;
        w.length && E & 7 && (i && w.some(Ya) && (k = fm(k, i)),
        y = tn(y, k))
    }
    return n.dirs && (y = tn(y),
    y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs),
    n.transition && (y.transition = n.transition),
    T = y,
    ro(b),
    T
}
function lm(e, t=!0) {
    let n;
    for (let r = 0; r < e.length; r++) {
        const s = e[r];
        if (br(s)) {
            if (s.type !== Be || s.children === "v-if") {
                if (n)
                    return;
                n = s
            }
        } else
            return
    }
    return n
}
const um = e=>{
    let t;
    for (const n in e)
        (n === "class" || n === "style" || as(n)) && ((t || (t = {}))[n] = e[n]);
    return t
}
  , fm = (e,t)=>{
    const n = {};
    for (const r in e)
        (!Ya(r) || !(r.slice(9)in t)) && (n[r] = e[r]);
    return n
}
;
function dm(e, t, n) {
    const {props: r, children: s, component: o} = e
      , {props: i, children: a, patchFlag: l} = t
      , u = o.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (n && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return r ? cl(r, i, u) : !!i;
        if (l & 8) {
            const c = t.dynamicProps;
            for (let f = 0; f < c.length; f++) {
                const d = c[f];
                if (i[d] !== r[d] && !No(u, d))
                    return !0
            }
        }
    } else
        return (s || a) && (!a || !a.$stable) ? !0 : r === i ? !1 : r ? i ? cl(r, i, u) : !0 : !!i;
    return !1
}
function cl(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length)
        return !0;
    for (let s = 0; s < r.length; s++) {
        const o = r[s];
        if (t[o] !== e[o] && !No(n, o))
            return !0
    }
    return !1
}
function fc({vnode: e, parent: t}, n) {
    for (; t; ) {
        const r = t.subTree;
        if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el),
        r === e)
            (e = t.vnode).el = n,
            t = t.parent;
        else
            break
    }
}
const dc = "components"
  , hm = "directives";
function Dr(e, t) {
    return hc(dc, e, !0, t) || e
}
const Vf = Symbol.for("v-ndc");
function Bo(e) {
    return ye(e) ? hc(dc, e, !1) || e : e || Vf
}
function KT(e) {
    return hc(hm, e)
}
function hc(e, t, n=!0, r=!1) {
    const s = Ee || _e;
    if (s) {
        const o = s.type;
        if (e === dc) {
            const a = da(o, !1);
            if (a && (a === t || a === Mt(t) || a === Ro(Mt(t))))
                return o
        }
        const i = ll(s[e] || o[e], t) || ll(s.appContext[e], t);
        return !i && r ? o : i
    }
}
function ll(e, t) {
    return e && (e[t] || e[Mt(t)] || e[Ro(Mt(t))])
}
const Uf = e=>e.__isSuspense;
let ra = 0;
const pm = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, n, r, s, o, i, a, l, u) {
        if (e == null)
            mm(t, n, r, s, o, i, a, l, u);
        else {
            if (o && o.deps > 0 && !e.suspense.isInFallback) {
                t.suspense = e.suspense,
                t.suspense.vnode = t,
                t.el = e.el;
                return
            }
            gm(e, t, n, r, s, i, a, l, u)
        }
    },
    hydrate: ym,
    create: mc,
    normalize: vm
}
  , pc = pm;
function Jr(e, t) {
    const n = e.props && e.props[t];
    Y(n) && n()
}
function mm(e, t, n, r, s, o, i, a, l) {
    const {p: u, o: {createElement: c}} = l
      , f = c("div")
      , d = e.suspense = mc(e, s, r, t, f, n, o, i, a, l);
    u(null, d.pendingBranch = e.ssContent, f, null, r, d, o, i),
    d.deps > 0 ? (Jr(e, "onPending"),
    Jr(e, "onFallback"),
    u(null, e.ssFallback, t, n, r, null, o, i),
    lr(d, e.ssFallback)) : d.resolve(!1, !0)
}
function gm(e, t, n, r, s, o, i, a, {p: l, um: u, o: {createElement: c}}) {
    const f = t.suspense = e.suspense;
    f.vnode = t,
    t.el = e.el;
    const d = t.ssContent
      , h = t.ssFallback
      , {activeBranch: m, pendingBranch: v, isInFallback: T, isHydrating: k} = f;
    if (v)
        f.pendingBranch = d,
        Ot(d, v) ? (l(v, d, f.hiddenContainer, null, s, f, o, i, a),
        f.deps <= 0 ? f.resolve() : T && (k || (l(m, h, n, r, s, null, o, i, a),
        lr(f, h)))) : (f.pendingId = ra++,
        k ? (f.isHydrating = !1,
        f.activeBranch = v) : u(v, s, f),
        f.deps = 0,
        f.effects.length = 0,
        f.hiddenContainer = c("div"),
        T ? (l(null, d, f.hiddenContainer, null, s, f, o, i, a),
        f.deps <= 0 ? f.resolve() : (l(m, h, n, r, s, null, o, i, a),
        lr(f, h))) : m && Ot(d, m) ? (l(m, d, n, r, s, f, o, i, a),
        f.resolve(!0)) : (l(null, d, f.hiddenContainer, null, s, f, o, i, a),
        f.deps <= 0 && f.resolve()));
    else if (m && Ot(d, m))
        l(m, d, n, r, s, f, o, i, a),
        lr(f, d);
    else if (Jr(t, "onPending"),
    f.pendingBranch = d,
    d.shapeFlag & 512 ? f.pendingId = d.component.suspenseId : f.pendingId = ra++,
    l(null, d, f.hiddenContainer, null, s, f, o, i, a),
    f.deps <= 0)
        f.resolve();
    else {
        const {timeout: b, pendingId: y} = f;
        b > 0 ? setTimeout(()=>{
            f.pendingId === y && f.fallback(h)
        }
        , b) : b === 0 && f.fallback(h)
    }
}
function mc(e, t, n, r, s, o, i, a, l, u, c=!1) {
    const {p: f, m: d, um: h, n: m, o: {parentNode: v, remove: T}} = u;
    let k;
    const b = bm(e);
    b && t != null && t.pendingBranch && (k = t.pendingId,
    t.deps++);
    const y = e.props ? df(e.props.timeout) : void 0
      , w = o
      , E = {
        vnode: e,
        parent: t,
        parentComponent: n,
        namespace: i,
        container: r,
        hiddenContainer: s,
        deps: 0,
        pendingId: ra++,
        timeout: typeof y == "number" ? y : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !c,
        isHydrating: c,
        isUnmounted: !1,
        effects: [],
        resolve(_=!1, I=!1) {
            const {vnode: C, activeBranch: R, pendingBranch: L, pendingId: H, effects: N, parentComponent: z, container: se} = E;
            let re = !1;
            E.isHydrating ? E.isHydrating = !1 : _ || (re = R && L.transition && L.transition.mode === "out-in",
            re && (R.transition.afterLeave = ()=>{
                H === E.pendingId && (d(L, se, o === w ? m(R) : o, 0),
                na(N))
            }
            ),
            R && (v(R.el) !== E.hiddenContainer && (o = m(R)),
            h(R, z, E, !0)),
            re || d(L, se, o, 0)),
            lr(E, L),
            E.pendingBranch = null,
            E.isInFallback = !1;
            let x = E.parent
              , Z = !1;
            for (; x; ) {
                if (x.pendingBranch) {
                    x.effects.push(...N),
                    Z = !0;
                    break
                }
                x = x.parent
            }
            !Z && !re && na(N),
            E.effects = [],
            b && t && t.pendingBranch && k === t.pendingId && (t.deps--,
            t.deps === 0 && !I && t.resolve()),
            Jr(C, "onResolve")
        },
        fallback(_) {
            if (!E.pendingBranch)
                return;
            const {vnode: I, activeBranch: C, parentComponent: R, container: L, namespace: H} = E;
            Jr(I, "onFallback");
            const N = m(C)
              , z = ()=>{
                E.isInFallback && (f(null, _, L, N, R, null, H, a, l),
                lr(E, _))
            }
              , se = _.transition && _.transition.mode === "out-in";
            se && (C.transition.afterLeave = z),
            E.isInFallback = !0,
            h(C, R, null, !0),
            se || z()
        },
        move(_, I, C) {
            E.activeBranch && d(E.activeBranch, _, I, C),
            E.container = _
        },
        next() {
            return E.activeBranch && m(E.activeBranch)
        },
        registerDep(_, I) {
            const C = !!E.pendingBranch;
            C && E.deps++;
            const R = _.vnode.el;
            _.asyncDep.catch(L=>{
                Sr(L, _, 0)
            }
            ).then(L=>{
                if (_.isUnmounted || E.isUnmounted || E.pendingId !== _.suspenseId)
                    return;
                _.asyncResolved = !0;
                const {vnode: H} = _;
                fa(_, L, !1),
                R && (H.el = R);
                const N = !R && _.subTree.el;
                I(_, H, v(R || _.subTree.el), R ? null : m(_.subTree), E, i, l),
                N && T(N),
                fc(_, H.el),
                C && --E.deps === 0 && E.resolve()
            }
            )
        },
        unmount(_, I) {
            E.isUnmounted = !0,
            E.activeBranch && h(E.activeBranch, n, _, I),
            E.pendingBranch && h(E.pendingBranch, n, _, I)
        }
    };
    return E
}
function ym(e, t, n, r, s, o, i, a, l) {
    const u = t.suspense = mc(t, r, n, e.parentNode, document.createElement("div"), null, s, o, i, a, !0)
      , c = l(e, u.pendingBranch = t.ssContent, n, u, o, i);
    return u.deps === 0 && u.resolve(!1, !0),
    c
}
function vm(e) {
    const {shapeFlag: t, children: n} = e
      , r = t & 32;
    e.ssContent = ul(r ? n.default : n),
    e.ssFallback = r ? ul(n.fallback) : ce(Be)
}
function ul(e) {
    let t;
    if (Y(e)) {
        const n = vr && e._c;
        n && (e._d = !1,
        ue()),
        e = e(),
        n && (e._d = !0,
        t = Tt,
        ud())
    }
    return K(e) && (e = lm(e)),
    e = Et(e),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n=>n !== e)),
    e
}
function qf(e, t) {
    t && t.pendingBranch ? K(e) ? t.effects.push(...e) : t.effects.push(e) : na(e)
}
function lr(e, t) {
    e.activeBranch = t;
    const {vnode: n, parentComponent: r} = e;
    let s = t.el;
    for (; !s && t.component; )
        t = t.component.subTree,
        s = t.el;
    n.el = s,
    r && r.subTree === n && (r.vnode.el = s,
    fc(r, s))
}
function bm(e) {
    var t;
    return ((t = e.props) == null ? void 0 : t.suspensible) != null && e.props.suspensible !== !1
}
const wm = Symbol.for("v-scx")
  , Em = ()=>Oe(wm);
function zT(e, t) {
    return us(e, null, t)
}
function Cm(e, t) {
    return us(e, null, {
        flush: "post"
    })
}
function Tm(e, t) {
    return us(e, null, {
        flush: "sync"
    })
}
const Is = {};
function mt(e, t, n) {
    return us(e, t, n)
}
function us(e, t, {immediate: n, deep: r, flush: s, once: o, onTrack: i, onTrigger: a}=pe) {
    if (t && o) {
        const _ = t;
        t = (...I)=>{
            _(...I),
            E()
        }
    }
    const l = _e
      , u = _=>r === !0 ? _ : Dn(_, r === !1 ? 1 : void 0);
    let c, f = !1, d = !1;
    if (ve(e) ? (c = ()=>e.value,
    f = to(e)) : Cn(e) ? (c = ()=>u(e),
    f = !0) : K(e) ? (d = !0,
    f = e.some(_=>Cn(_) || to(_)),
    c = ()=>e.map(_=>{
        if (ve(_))
            return _.value;
        if (Cn(_))
            return u(_);
        if (Y(_))
            return Tn(_, l, 2)
    }
    )) : Y(e) ? t ? c = ()=>Tn(e, l, 2) : c = ()=>(h && h(),
    _t(e, l, 3, [m])) : c = Ct,
    t && r) {
        const _ = c;
        c = ()=>Dn(_())
    }
    let h, m = _=>{
        h = y.onStop = ()=>{
            Tn(_, l, 4),
            h = y.onStop = void 0
        }
    }
    , v;
    if (ms)
        if (m = Ct,
        t ? n && _t(t, l, 3, [c(), d ? [] : void 0, m]) : c(),
        s === "sync") {
            const _ = Em();
            v = _.__watcherHandles || (_.__watcherHandles = [])
        } else
            return Ct;
    let T = d ? new Array(e.length).fill(Is) : Is;
    const k = ()=>{
        if (!(!y.active || !y.dirty))
            if (t) {
                const _ = y.run();
                (r || f || (d ? _.some((I,C)=>Kt(I, T[C])) : Kt(_, T))) && (h && h(),
                _t(t, l, 3, [_, T === Is ? void 0 : d && T[0] === Is ? [] : T, m]),
                T = _)
            } else
                y.run()
    }
    ;
    k.allowRecurse = !!t;
    let b;
    s === "sync" ? b = k : s === "post" ? b = ()=>Ae(k, l && l.suspense) : (k.pre = !0,
    l && (k.id = l.uid),
    b = ()=>Lo(k));
    const y = new nc(c,Ct,b)
      , w = cs()
      , E = ()=>{
        y.stop(),
        w && Qa(w.effects, y)
    }
    ;
    return t ? n ? k() : T = y.run() : s === "post" ? Ae(y.run.bind(y), l && l.suspense) : y.run(),
    v && v.push(E),
    E
}
function _m(e, t, n) {
    const r = this.proxy
      , s = ye(e) ? e.includes(".") ? Wf(r, e) : ()=>r[e] : e.bind(r, r);
    let o;
    Y(t) ? o = t : (o = t.handler,
    n = t);
    const i = Un(this)
      , a = us(s, o.bind(r), n);
    return i(),
    a
}
function Wf(e, t) {
    const n = t.split(".");
    return ()=>{
        let r = e;
        for (let s = 0; s < n.length && r; s++)
            r = r[n[s]];
        return r
    }
}
function Dn(e, t, n=0, r) {
    if (!de(e) || e.__v_skip)
        return e;
    if (t && t > 0) {
        if (n >= t)
            return e;
        n++
    }
    if (r = r || new Set,
    r.has(e))
        return e;
    if (r.add(e),
    ve(e))
        Dn(e.value, t, n, r);
    else if (K(e))
        for (let s = 0; s < e.length; s++)
            Dn(e[s], t, n, r);
    else if (So(e) || or(e))
        e.forEach(s=>{
            Dn(s, t, n, r)
        }
        );
    else if (ff(e))
        for (const s in e)
            Dn(e[s], t, n, r);
    return e
}
function GT(e, t) {
    if (Ee === null)
        return e;
    const n = Fo(Ee) || Ee.proxy
      , r = e.dirs || (e.dirs = []);
    for (let s = 0; s < t.length; s++) {
        let[o,i,a,l=pe] = t[s];
        o && (Y(o) && (o = {
            mounted: o,
            updated: o
        }),
        o.deep && Dn(i),
        r.push({
            dir: o,
            instance: n,
            value: i,
            oldValue: void 0,
            arg: a,
            modifiers: l
        }))
    }
    return e
}
function Vt(e, t, n, r) {
    const s = e.dirs
      , o = t && t.dirs;
    for (let i = 0; i < s.length; i++) {
        const a = s[i];
        o && (a.oldValue = o[i].value);
        let l = a.dir[r];
        l && (qn(),
        _t(l, n, 8, [e.el, a, e, t]),
        Wn())
    }
}
const pn = Symbol("_leaveCb")
  , Ls = Symbol("_enterCb");
function Kf() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return ds(()=>{
        e.isMounted = !0
    }
    ),
    vc(()=>{
        e.isUnmounting = !0
    }
    ),
    e
}
const yt = [Function, Array]
  , zf = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: yt,
    onEnter: yt,
    onAfterEnter: yt,
    onEnterCancelled: yt,
    onBeforeLeave: yt,
    onLeave: yt,
    onAfterLeave: yt,
    onLeaveCancelled: yt,
    onBeforeAppear: yt,
    onAppear: yt,
    onAfterAppear: yt,
    onAppearCancelled: yt
}
  , Sm = {
    name: "BaseTransition",
    props: zf,
    setup(e, {slots: t}) {
        const n = Gt()
          , r = Kf();
        return ()=>{
            const s = t.default && gc(t.default(), !0);
            if (!s || !s.length)
                return;
            let o = s[0];
            if (s.length > 1) {
                for (const d of s)
                    if (d.type !== Be) {
                        o = d;
                        break
                    }
            }
            const i = ne(e)
              , {mode: a} = i;
            if (r.isLeaving)
                return Zo(o);
            const l = fl(o);
            if (!l)
                return Zo(o);
            const u = Xr(l, i, r, n);
            gr(l, u);
            const c = n.subTree
              , f = c && fl(c);
            if (f && f.type !== Be && !Ot(l, f)) {
                const d = Xr(f, i, r, n);
                if (gr(f, d),
                a === "out-in")
                    return r.isLeaving = !0,
                    d.afterLeave = ()=>{
                        r.isLeaving = !1,
                        n.update.active !== !1 && (n.effect.dirty = !0,
                        n.update())
                    }
                    ,
                    Zo(o);
                a === "in-out" && l.type !== Be && (d.delayLeave = (h,m,v)=>{
                    const T = Gf(r, f);
                    T[String(f.key)] = f,
                    h[pn] = ()=>{
                        m(),
                        h[pn] = void 0,
                        delete u.delayedLeave
                    }
                    ,
                    u.delayedLeave = v
                }
                )
            }
            return o
        }
    }
}
  , km = Sm;
function Gf(e, t) {
    const {leavingVNodes: n} = e;
    let r = n.get(t.type);
    return r || (r = Object.create(null),
    n.set(t.type, r)),
    r
}
function Xr(e, t, n, r) {
    const {appear: s, mode: o, persisted: i=!1, onBeforeEnter: a, onEnter: l, onAfterEnter: u, onEnterCancelled: c, onBeforeLeave: f, onLeave: d, onAfterLeave: h, onLeaveCancelled: m, onBeforeAppear: v, onAppear: T, onAfterAppear: k, onAppearCancelled: b} = t
      , y = String(e.key)
      , w = Gf(n, e)
      , E = (C,R)=>{
        C && _t(C, r, 9, R)
    }
      , _ = (C,R)=>{
        const L = R[1];
        E(C, R),
        K(C) ? C.every(H=>H.length <= 1) && L() : C.length <= 1 && L()
    }
      , I = {
        mode: o,
        persisted: i,
        beforeEnter(C) {
            let R = a;
            if (!n.isMounted)
                if (s)
                    R = v || a;
                else
                    return;
            C[pn] && C[pn](!0);
            const L = w[y];
            L && Ot(e, L) && L.el[pn] && L.el[pn](),
            E(R, [C])
        },
        enter(C) {
            let R = l
              , L = u
              , H = c;
            if (!n.isMounted)
                if (s)
                    R = T || l,
                    L = k || u,
                    H = b || c;
                else
                    return;
            let N = !1;
            const z = C[Ls] = se=>{
                N || (N = !0,
                se ? E(H, [C]) : E(L, [C]),
                I.delayedLeave && I.delayedLeave(),
                C[Ls] = void 0)
            }
            ;
            R ? _(R, [C, z]) : z()
        },
        leave(C, R) {
            const L = String(e.key);
            if (C[Ls] && C[Ls](!0),
            n.isUnmounting)
                return R();
            E(f, [C]);
            let H = !1;
            const N = C[pn] = z=>{
                H || (H = !0,
                R(),
                z ? E(m, [C]) : E(h, [C]),
                C[pn] = void 0,
                w[L] === e && delete w[L])
            }
            ;
            w[L] = e,
            d ? _(d, [C, N]) : N()
        },
        clone(C) {
            return Xr(C, t, n, r)
        }
    };
    return I
}
function Zo(e) {
    if (fs(e))
        return e = tn(e),
        e.children = null,
        e
}
function fl(e) {
    return fs(e) ? e.children ? e.children[0] : void 0 : e
}
function gr(e, t) {
    e.shapeFlag & 6 && e.component ? gr(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent),
    e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function gc(e, t=!1, n) {
    let r = []
      , s = 0;
    for (let o = 0; o < e.length; o++) {
        let i = e[o];
        const a = n == null ? i.key : String(n) + String(i.key != null ? i.key : o);
        i.type === Te ? (i.patchFlag & 128 && s++,
        r = r.concat(gc(i.children, t, a))) : (t || i.type !== Be) && r.push(a != null ? tn(i, {
            key: a
        }) : i)
    }
    if (s > 1)
        for (let o = 0; o < r.length; o++)
            r[o].patchFlag = -2;
    return r
}
/*! #__NO_SIDE_EFFECTS__ */
function De(e, t) {
    return Y(e) ? we({
        name: e.name
    }, t, {
        setup: e
    }) : e
}
const $n = e=>!!e.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
function dl(e) {
    Y(e) && (e = {
        loader: e
    });
    const {loader: t, loadingComponent: n, errorComponent: r, delay: s=200, timeout: o, suspensible: i=!0, onError: a} = e;
    let l = null, u, c = 0;
    const f = ()=>(c++,
    l = null,
    d())
      , d = ()=>{
        let h;
        return l || (h = l = t().catch(m=>{
            if (m = m instanceof Error ? m : new Error(String(m)),
            a)
                return new Promise((v,T)=>{
                    a(m, ()=>v(f()), ()=>T(m), c + 1)
                }
                );
            throw m
        }
        ).then(m=>h !== l && l ? l : (m && (m.__esModule || m[Symbol.toStringTag] === "Module") && (m = m.default),
        u = m,
        m)))
    }
    ;
    return De({
        name: "AsyncComponentWrapper",
        __asyncLoader: d,
        get __asyncResolved() {
            return u
        },
        setup() {
            const h = _e;
            if (u)
                return ()=>ei(u, h);
            const m = b=>{
                l = null,
                Sr(b, h, 13, !r)
            }
            ;
            if (i && h.suspense || ms)
                return d().then(b=>()=>ei(b, h)).catch(b=>(m(b),
                ()=>r ? ce(r, {
                    error: b
                }) : null));
            const v = pt(!1)
              , T = pt()
              , k = pt(!!s);
            return s && setTimeout(()=>{
                k.value = !1
            }
            , s),
            o != null && setTimeout(()=>{
                if (!v.value && !T.value) {
                    const b = new Error(`Async component timed out after ${o}ms.`);
                    m(b),
                    T.value = b
                }
            }
            , o),
            d().then(()=>{
                v.value = !0,
                h.parent && fs(h.parent.vnode) && (h.parent.effect.dirty = !0,
                Lo(h.parent.update))
            }
            ).catch(b=>{
                m(b),
                T.value = b
            }
            ),
            ()=>{
                if (v.value && u)
                    return ei(u, h);
                if (T.value && r)
                    return ce(r, {
                        error: T.value
                    });
                if (n && !k.value)
                    return ce(n)
            }
        }
    })
}
function ei(e, t) {
    const {ref: n, props: r, children: s, ce: o} = t.vnode
      , i = ce(e, r, s);
    return i.ref = n,
    i.ce = o,
    delete t.vnode.ce,
    i
}
const fs = e=>e.type.__isKeepAlive
  , Rm = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(e, {slots: t}) {
        const n = Gt()
          , r = n.ctx;
        if (!r.renderer)
            return ()=>{
                const b = t.default && t.default();
                return b && b.length === 1 ? b[0] : b
            }
            ;
        const s = new Map
          , o = new Set;
        let i = null;
        const a = n.suspense
          , {renderer: {p: l, m: u, um: c, o: {createElement: f}}} = r
          , d = f("div");
        r.activate = (b,y,w,E,_)=>{
            const I = b.component;
            u(b, y, w, 0, a),
            l(I.vnode, b, y, w, I, a, E, b.slotScopeIds, _),
            Ae(()=>{
                I.isDeactivated = !1,
                I.a && ar(I.a);
                const C = b.props && b.props.onVnodeMounted;
                C && Fe(C, I.parent, b)
            }
            , a)
        }
        ,
        r.deactivate = b=>{
            const y = b.component;
            u(b, d, null, 1, a),
            Ae(()=>{
                y.da && ar(y.da);
                const w = b.props && b.props.onVnodeUnmounted;
                w && Fe(w, y.parent, b),
                y.isDeactivated = !0
            }
            , a)
        }
        ;
        function h(b) {
            ti(b),
            c(b, n, a, !0)
        }
        function m(b) {
            s.forEach((y,w)=>{
                const E = da(y.type);
                E && (!b || !b(E)) && v(w)
            }
            )
        }
        function v(b) {
            const y = s.get(b);
            !i || !Ot(y, i) ? h(y) : i && ti(i),
            s.delete(b),
            o.delete(b)
        }
        mt(()=>[e.include, e.exclude], ([b,y])=>{
            b && m(w=>Nr(b, w)),
            y && m(w=>!Nr(y, w))
        }
        , {
            flush: "post",
            deep: !0
        });
        let T = null;
        const k = ()=>{
            T != null && s.set(T, ni(n.subTree))
        }
        ;
        return ds(k),
        yc(k),
        vc(()=>{
            s.forEach(b=>{
                const {subTree: y, suspense: w} = n
                  , E = ni(y);
                if (b.type === E.type && b.key === E.key) {
                    ti(E);
                    const _ = E.component.da;
                    _ && Ae(_, w);
                    return
                }
                h(b)
            }
            )
        }
        ),
        ()=>{
            if (T = null,
            !t.default)
                return null;
            const b = t.default()
              , y = b[0];
            if (b.length > 1)
                return i = null,
                b;
            if (!br(y) || !(y.shapeFlag & 4) && !(y.shapeFlag & 128))
                return i = null,
                y;
            let w = ni(y);
            const E = w.type
              , _ = da($n(w) ? w.type.__asyncResolved || {} : E)
              , {include: I, exclude: C, max: R} = e;
            if (I && (!_ || !Nr(I, _)) || C && _ && Nr(C, _))
                return i = w,
                y;
            const L = w.key == null ? E : w.key
              , H = s.get(L);
            return w.el && (w = tn(w),
            y.shapeFlag & 128 && (y.ssContent = w)),
            T = L,
            H ? (w.el = H.el,
            w.component = H.component,
            w.transition && gr(w, w.transition),
            w.shapeFlag |= 512,
            o.delete(L),
            o.add(L)) : (o.add(L),
            R && o.size > parseInt(R, 10) && v(o.values().next().value)),
            w.shapeFlag |= 256,
            i = w,
            Uf(y.type) ? y : w
        }
    }
}
  , Am = Rm;
function Nr(e, t) {
    return K(e) ? e.some(n=>Nr(n, t)) : ye(e) ? e.split(",").includes(t) : vp(e) ? e.test(t) : !1
}
function Pm(e, t) {
    Jf(e, "a", t)
}
function Om(e, t) {
    Jf(e, "da", t)
}
function Jf(e, t, n=_e) {
    const r = e.__wdc || (e.__wdc = ()=>{
        let s = n;
        for (; s; ) {
            if (s.isDeactivated)
                return;
            s = s.parent
        }
        return e()
    }
    );
    if (Do(t, r, n),
    n) {
        let s = n.parent;
        for (; s && s.parent; )
            fs(s.parent.vnode) && Im(r, t, n, s),
            s = s.parent
    }
}
function Im(e, t, n, r) {
    const s = Do(t, e, r, !0);
    bc(()=>{
        Qa(r[t], s)
    }
    , n)
}
function ti(e) {
    e.shapeFlag &= -257,
    e.shapeFlag &= -513
}
function ni(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}
function Do(e, t, n=_e, r=!1) {
    if (n) {
        const s = n[e] || (n[e] = [])
          , o = t.__weh || (t.__weh = (...i)=>{
            if (n.isUnmounted)
                return;
            qn();
            const a = Un(n)
              , l = _t(t, n, e, i);
            return a(),
            Wn(),
            l
        }
        );
        return r ? s.unshift(o) : s.push(o),
        o
    }
}
const rn = e=>(t,n=_e)=>(!ms || e === "sp") && Do(e, (...r)=>t(...r), n)
  , Lm = rn("bm")
  , ds = rn("m")
  , Nm = rn("bu")
  , yc = rn("u")
  , vc = rn("bum")
  , bc = rn("um")
  , Mm = rn("sp")
  , Bm = rn("rtg")
  , Dm = rn("rtc");
function Xf(e, t=_e) {
    Do("ec", e, t)
}
function hl(e, t, n, r) {
    let s;
    const o = n && n[r];
    if (K(e) || ye(e)) {
        s = new Array(e.length);
        for (let i = 0, a = e.length; i < a; i++)
            s[i] = t(e[i], i, void 0, o && o[i])
    } else if (typeof e == "number") {
        s = new Array(e);
        for (let i = 0; i < e; i++)
            s[i] = t(i + 1, i, void 0, o && o[i])
    } else if (de(e))
        if (e[Symbol.iterator])
            s = Array.from(e, (i,a)=>t(i, a, void 0, o && o[a]));
        else {
            const i = Object.keys(e);
            s = new Array(i.length);
            for (let a = 0, l = i.length; a < l; a++) {
                const u = i[a];
                s[a] = t(e[u], u, a, o && o[a])
            }
        }
    else
        s = [];
    return n && (n[r] = s),
    s
}
function xm(e, t, n={}, r, s) {
    if (Ee.isCE || Ee.parent && $n(Ee.parent) && Ee.parent.isCE)
        return t !== "default" && (n.name = t),
        ce("slot", n, r && r());
    let o = e[t];
    o && o._c && (o._d = !1),
    ue();
    const i = o && Yf(o(n))
      , a = Pe(Te, {
        key: n.key || i && i.key || `_${t}`
    }, i || (r ? r() : []), i && e._ === 1 ? 64 : -2);
    return !s && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]),
    o && o._c && (o._d = !0),
    a
}
function Yf(e) {
    return e.some(t=>br(t) ? !(t.type === Be || t.type === Te && !Yf(t.children)) : !0) ? e : null
}
function Fm(e, t) {
    const n = {};
    for (const r in e)
        n[t && /[A-Z]/.test(r) ? `on:${r}` : Ws(r)] = e[r];
    return n
}
const sa = e=>e ? pd(e) ? Fo(e) || e.proxy : sa(e.parent) : null
  , xr = we(Object.create(null), {
    $: e=>e,
    $el: e=>e.vnode.el,
    $data: e=>e.data,
    $props: e=>e.props,
    $attrs: e=>e.attrs,
    $slots: e=>e.slots,
    $refs: e=>e.refs,
    $parent: e=>sa(e.parent),
    $root: e=>sa(e.root),
    $emit: e=>e.emit,
    $options: e=>wc(e),
    $forceUpdate: e=>e.f || (e.f = ()=>{
        e.effect.dirty = !0,
        Lo(e.update)
    }
    ),
    $nextTick: e=>e.n || (e.n = Dt.bind(e.proxy)),
    $watch: e=>_m.bind(e)
})
  , ri = (e,t)=>e !== pe && !e.__isScriptSetup && oe(e, t)
  , Hm = {
    get({_: e}, t) {
        const {ctx: n, setupState: r, data: s, props: o, accessCache: i, type: a, appContext: l} = e;
        let u;
        if (t[0] !== "$") {
            const h = i[t];
            if (h !== void 0)
                switch (h) {
                case 1:
                    return r[t];
                case 2:
                    return s[t];
                case 4:
                    return n[t];
                case 3:
                    return o[t]
                }
            else {
                if (ri(r, t))
                    return i[t] = 1,
                    r[t];
                if (s !== pe && oe(s, t))
                    return i[t] = 2,
                    s[t];
                if ((u = e.propsOptions[0]) && oe(u, t))
                    return i[t] = 3,
                    o[t];
                if (n !== pe && oe(n, t))
                    return i[t] = 4,
                    n[t];
                oa && (i[t] = 0)
            }
        }
        const c = xr[t];
        let f, d;
        if (c)
            return t === "$attrs" && He(e, "get", t),
            c(e);
        if ((f = a.__cssModules) && (f = f[t]))
            return f;
        if (n !== pe && oe(n, t))
            return i[t] = 4,
            n[t];
        if (d = l.config.globalProperties,
        oe(d, t))
            return d[t]
    },
    set({_: e}, t, n) {
        const {data: r, setupState: s, ctx: o} = e;
        return ri(s, t) ? (s[t] = n,
        !0) : r !== pe && oe(r, t) ? (r[t] = n,
        !0) : oe(e.props, t) || t[0] === "$" && t.slice(1)in e ? !1 : (o[t] = n,
        !0)
    },
    has({_: {data: e, setupState: t, accessCache: n, ctx: r, appContext: s, propsOptions: o}}, i) {
        let a;
        return !!n[i] || e !== pe && oe(e, i) || ri(t, i) || (a = o[0]) && oe(a, i) || oe(r, i) || oe(xr, i) || oe(s.config.globalProperties, i)
    },
    defineProperty(e, t, n) {
        return n.get != null ? e._.accessCache[t] = 0 : oe(n, "value") && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
    }
};
function JT() {
    return Qf().slots
}
function XT() {
    return Qf().attrs
}
function Qf() {
    const e = Gt();
    return e.setupContext || (e.setupContext = gd(e))
}
function so(e) {
    return K(e) ? e.reduce((t,n)=>(t[n] = null,
    t), {}) : e
}
function YT(e, t) {
    return !e || !t ? e || t : K(e) && K(t) ? e.concat(t) : we({}, so(e), so(t))
}
function QT(e) {
    const t = Gt();
    let n = e();
    return ua(),
    Za(n) && (n = n.catch(r=>{
        throw Un(t),
        r
    }
    )),
    [n, ()=>Un(t)]
}
let oa = !0;
function $m(e) {
    const t = wc(e)
      , n = e.proxy
      , r = e.ctx;
    oa = !1,
    t.beforeCreate && pl(t.beforeCreate, e, "bc");
    const {data: s, computed: o, methods: i, watch: a, provide: l, inject: u, created: c, beforeMount: f, mounted: d, beforeUpdate: h, updated: m, activated: v, deactivated: T, beforeDestroy: k, beforeUnmount: b, destroyed: y, unmounted: w, render: E, renderTracked: _, renderTriggered: I, errorCaptured: C, serverPrefetch: R, expose: L, inheritAttrs: H, components: N, directives: z, filters: se} = t;
    if (u && jm(u, r, null),
    i)
        for (const Z in i) {
            const q = i[Z];
            Y(q) && (r[Z] = q.bind(n))
        }
    if (s) {
        const Z = s.call(n, n);
        de(Z) && (e.data = nn(Z))
    }
    if (oa = !0,
    o)
        for (const Z in o) {
            const q = o[Z]
              , St = Y(q) ? q.bind(n, n) : Y(q.get) ? q.get.bind(n, n) : Ct
              , sn = !Y(q) && Y(q.set) ? q.set.bind(n) : Ct
              , Ht = ft({
                get: St,
                set: sn
            });
            Object.defineProperty(r, Z, {
                enumerable: !0,
                configurable: !0,
                get: ()=>Ht.value,
                set: xe=>Ht.value = xe
            })
        }
    if (a)
        for (const Z in a)
            Zf(a[Z], r, n, Z);
    if (l) {
        const Z = Y(l) ? l.call(n) : l;
        Reflect.ownKeys(Z).forEach(q=>{
            jn(q, Z[q])
        }
        )
    }
    c && pl(c, e, "c");
    function x(Z, q) {
        K(q) ? q.forEach(St=>Z(St.bind(n))) : q && Z(q.bind(n))
    }
    if (x(Lm, f),
    x(ds, d),
    x(Nm, h),
    x(yc, m),
    x(Pm, v),
    x(Om, T),
    x(Xf, C),
    x(Dm, _),
    x(Bm, I),
    x(vc, b),
    x(bc, w),
    x(Mm, R),
    K(L))
        if (L.length) {
            const Z = e.exposed || (e.exposed = {});
            L.forEach(q=>{
                Object.defineProperty(Z, q, {
                    get: ()=>n[q],
                    set: St=>n[q] = St
                })
            }
            )
        } else
            e.exposed || (e.exposed = {});
    E && e.render === Ct && (e.render = E),
    H != null && (e.inheritAttrs = H),
    N && (e.components = N),
    z && (e.directives = z)
}
function jm(e, t, n=Ct) {
    K(e) && (e = ia(e));
    for (const r in e) {
        const s = e[r];
        let o;
        de(s) ? "default"in s ? o = Oe(s.from || r, s.default, !0) : o = Oe(s.from || r) : o = Oe(s),
        ve(o) ? Object.defineProperty(t, r, {
            enumerable: !0,
            configurable: !0,
            get: ()=>o.value,
            set: i=>o.value = i
        }) : t[r] = o
    }
}
function pl(e, t, n) {
    _t(K(e) ? e.map(r=>r.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function Zf(e, t, n, r) {
    const s = r.includes(".") ? Wf(n, r) : ()=>n[r];
    if (ye(e)) {
        const o = t[e];
        Y(o) && mt(s, o)
    } else if (Y(e))
        mt(s, e.bind(n));
    else if (de(e))
        if (K(e))
            e.forEach(o=>Zf(o, t, n, r));
        else {
            const o = Y(e.handler) ? e.handler.bind(n) : t[e.handler];
            Y(o) && mt(s, o, e)
        }
}
function wc(e) {
    const t = e.type
      , {mixins: n, extends: r} = t
      , {mixins: s, optionsCache: o, config: {optionMergeStrategies: i}} = e.appContext
      , a = o.get(t);
    let l;
    return a ? l = a : !s.length && !n && !r ? l = t : (l = {},
    s.length && s.forEach(u=>oo(l, u, i, !0)),
    oo(l, t, i)),
    de(t) && o.set(t, l),
    l
}
function oo(e, t, n, r=!1) {
    const {mixins: s, extends: o} = t;
    o && oo(e, o, n, !0),
    s && s.forEach(i=>oo(e, i, n, !0));
    for (const i in t)
        if (!(r && i === "expose")) {
            const a = Vm[i] || n && n[i];
            e[i] = a ? a(e[i], t[i]) : t[i]
        }
    return e
}
const Vm = {
    data: ml,
    props: gl,
    emits: gl,
    methods: Mr,
    computed: Mr,
    beforeCreate: Me,
    created: Me,
    beforeMount: Me,
    mounted: Me,
    beforeUpdate: Me,
    updated: Me,
    beforeDestroy: Me,
    beforeUnmount: Me,
    destroyed: Me,
    unmounted: Me,
    activated: Me,
    deactivated: Me,
    errorCaptured: Me,
    serverPrefetch: Me,
    components: Mr,
    directives: Mr,
    watch: qm,
    provide: ml,
    inject: Um
};
function ml(e, t) {
    return t ? e ? function() {
        return we(Y(e) ? e.call(this, this) : e, Y(t) ? t.call(this, this) : t)
    }
    : t : e
}
function Um(e, t) {
    return Mr(ia(e), ia(t))
}
function ia(e) {
    if (K(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = e[n];
        return t
    }
    return e
}
function Me(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function Mr(e, t) {
    return e ? we(Object.create(null), e, t) : t
}
function gl(e, t) {
    return e ? K(e) && K(t) ? [...new Set([...e, ...t])] : we(Object.create(null), so(e), so(t ?? {})) : t
}
function qm(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    const n = we(Object.create(null), e);
    for (const r in t)
        n[r] = Me(e[r], t[r]);
    return n
}
function ed() {
    return {
        app: null,
        config: {
            isNativeTag: gp,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let Wm = 0;
function Km(e, t) {
    return function(r, s=null) {
        Y(r) || (r = we({}, r)),
        s != null && !de(s) && (s = null);
        const o = ed()
          , i = new WeakSet;
        let a = !1;
        const l = o.app = {
            _uid: Wm++,
            _component: r,
            _props: s,
            _container: null,
            _context: o,
            _instance: null,
            version: yd,
            get config() {
                return o.config
            },
            set config(u) {},
            use(u, ...c) {
                return i.has(u) || (u && Y(u.install) ? (i.add(u),
                u.install(l, ...c)) : Y(u) && (i.add(u),
                u(l, ...c))),
                l
            },
            mixin(u) {
                return o.mixins.includes(u) || o.mixins.push(u),
                l
            },
            component(u, c) {
                return c ? (o.components[u] = c,
                l) : o.components[u]
            },
            directive(u, c) {
                return c ? (o.directives[u] = c,
                l) : o.directives[u]
            },
            mount(u, c, f) {
                if (!a) {
                    const d = ce(r, s);
                    return d.appContext = o,
                    f === !0 ? f = "svg" : f === !1 && (f = void 0),
                    c && t ? t(d, u) : e(d, u, f),
                    a = !0,
                    l._container = u,
                    u.__vue_app__ = l,
                    Fo(d.component) || d.component.proxy
                }
            },
            unmount() {
                a && (e(null, l._container),
                delete l._container.__vue_app__)
            },
            provide(u, c) {
                return o.provides[u] = c,
                l
            },
            runWithContext(u) {
                const c = ur;
                ur = l;
                try {
                    return u()
                } finally {
                    ur = c
                }
            }
        };
        return l
    }
}
let ur = null;
function jn(e, t) {
    if (_e) {
        let n = _e.provides;
        const r = _e.parent && _e.parent.provides;
        r === n && (n = _e.provides = Object.create(r)),
        n[e] = t
    }
}
function Oe(e, t, n=!1) {
    const r = _e || Ee;
    if (r || ur) {
        const s = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : ur._context.provides;
        if (s && e in s)
            return s[e];
        if (arguments.length > 1)
            return n && Y(t) ? t.call(r && r.proxy) : t
    }
}
function Ec() {
    return !!(_e || Ee || ur)
}
function zm(e, t, n, r=!1) {
    const s = {}
      , o = {};
    Zs(o, xo, 1),
    e.propsDefaults = Object.create(null),
    td(e, t, s, o);
    for (const i in e.propsOptions[0])
        i in s || (s[i] = void 0);
    n ? e.props = r ? s : ls(s) : e.type.props ? e.props = s : e.props = o,
    e.attrs = o
}
function Gm(e, t, n, r) {
    const {props: s, attrs: o, vnode: {patchFlag: i}} = e
      , a = ne(s)
      , [l] = e.propsOptions;
    let u = !1;
    if ((r || i > 0) && !(i & 16)) {
        if (i & 8) {
            const c = e.vnode.dynamicProps;
            for (let f = 0; f < c.length; f++) {
                let d = c[f];
                if (No(e.emitsOptions, d))
                    continue;
                const h = t[d];
                if (l)
                    if (oe(o, d))
                        h !== o[d] && (o[d] = h,
                        u = !0);
                    else {
                        const m = Mt(d);
                        s[m] = aa(l, a, m, h, e, !1)
                    }
                else
                    h !== o[d] && (o[d] = h,
                    u = !0)
            }
        }
    } else {
        td(e, t, s, o) && (u = !0);
        let c;
        for (const f in a)
            (!t || !oe(t, f) && ((c = Sn(f)) === f || !oe(t, c))) && (l ? n && (n[f] !== void 0 || n[c] !== void 0) && (s[f] = aa(l, a, f, void 0, e, !0)) : delete s[f]);
        if (o !== a)
            for (const f in o)
                (!t || !oe(t, f)) && (delete o[f],
                u = !0)
    }
    u && Qt(e, "set", "$attrs")
}
function td(e, t, n, r) {
    const [s,o] = e.propsOptions;
    let i = !1, a;
    if (t)
        for (let l in t) {
            if (ir(l))
                continue;
            const u = t[l];
            let c;
            s && oe(s, c = Mt(l)) ? !o || !o.includes(c) ? n[c] = u : (a || (a = {}))[c] = u : No(e.emitsOptions, l) || (!(l in r) || u !== r[l]) && (r[l] = u,
            i = !0)
        }
    if (o) {
        const l = ne(n)
          , u = a || pe;
        for (let c = 0; c < o.length; c++) {
            const f = o[c];
            n[f] = aa(s, l, f, u[f], e, !oe(u, f))
        }
    }
    return i
}
function aa(e, t, n, r, s, o) {
    const i = e[n];
    if (i != null) {
        const a = oe(i, "default");
        if (a && r === void 0) {
            const l = i.default;
            if (i.type !== Function && !i.skipFactory && Y(l)) {
                const {propsDefaults: u} = s;
                if (n in u)
                    r = u[n];
                else {
                    const c = Un(s);
                    r = u[n] = l.call(null, t),
                    c()
                }
            } else
                r = l
        }
        i[0] && (o && !a ? r = !1 : i[1] && (r === "" || r === Sn(n)) && (r = !0))
    }
    return r
}
function nd(e, t, n=!1) {
    const r = t.propsCache
      , s = r.get(e);
    if (s)
        return s;
    const o = e.props
      , i = {}
      , a = [];
    let l = !1;
    if (!Y(e)) {
        const c = f=>{
            l = !0;
            const [d,h] = nd(f, t, !0);
            we(i, d),
            h && a.push(...h)
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(c),
        e.extends && c(e.extends),
        e.mixins && e.mixins.forEach(c)
    }
    if (!o && !l)
        return de(e) && r.set(e, sr),
        sr;
    if (K(o))
        for (let c = 0; c < o.length; c++) {
            const f = Mt(o[c]);
            yl(f) && (i[f] = pe)
        }
    else if (o)
        for (const c in o) {
            const f = Mt(c);
            if (yl(f)) {
                const d = o[c]
                  , h = i[f] = K(d) || Y(d) ? {
                    type: d
                } : we({}, d);
                if (h) {
                    const m = wl(Boolean, h.type)
                      , v = wl(String, h.type);
                    h[0] = m > -1,
                    h[1] = v < 0 || m < v,
                    (m > -1 || oe(h, "default")) && a.push(f)
                }
            }
        }
    const u = [i, a];
    return de(e) && r.set(e, u),
    u
}
function yl(e) {
    return e[0] !== "$" && !ir(e)
}
function vl(e) {
    return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || ""
}
function bl(e, t) {
    return vl(e) === vl(t)
}
function wl(e, t) {
    return K(t) ? t.findIndex(n=>bl(n, e)) : Y(t) && bl(t, e) ? 0 : -1
}
const rd = e=>e[0] === "_" || e === "$stable"
  , Cc = e=>K(e) ? e.map(Et) : [Et(e)]
  , Jm = (e,t,n)=>{
    if (t._n)
        return t;
    const r = kn((...s)=>Cc(t(...s)), n);
    return r._c = !1,
    r
}
  , sd = (e,t,n)=>{
    const r = e._ctx;
    for (const s in e) {
        if (rd(s))
            continue;
        const o = e[s];
        if (Y(o))
            t[s] = Jm(s, o, r);
        else if (o != null) {
            const i = Cc(o);
            t[s] = ()=>i
        }
    }
}
  , od = (e,t)=>{
    const n = Cc(t);
    e.slots.default = ()=>n
}
  , Xm = (e,t)=>{
    if (e.vnode.shapeFlag & 32) {
        const n = t._;
        n ? (e.slots = ne(t),
        Zs(t, "_", n)) : sd(t, e.slots = {})
    } else
        e.slots = {},
        t && od(e, t);
    Zs(e.slots, xo, 1)
}
  , Ym = (e,t,n)=>{
    const {vnode: r, slots: s} = e;
    let o = !0
      , i = pe;
    if (r.shapeFlag & 32) {
        const a = t._;
        a ? n && a === 1 ? o = !1 : (we(s, t),
        !n && a === 1 && delete s._) : (o = !t.$stable,
        sd(t, s)),
        i = t
    } else
        t && (od(e, t),
        i = {
            default: 1
        });
    if (o)
        for (const a in s)
            !rd(a) && i[a] == null && delete s[a]
}
;
function io(e, t, n, r, s=!1) {
    if (K(e)) {
        e.forEach((d,h)=>io(d, t && (K(t) ? t[h] : t), n, r, s));
        return
    }
    if ($n(r) && !s)
        return;
    const o = r.shapeFlag & 4 ? Fo(r.component) || r.component.proxy : r.el
      , i = s ? null : o
      , {i: a, r: l} = e
      , u = t && t.r
      , c = a.refs === pe ? a.refs = {} : a.refs
      , f = a.setupState;
    if (u != null && u !== l && (ye(u) ? (c[u] = null,
    oe(f, u) && (f[u] = null)) : ve(u) && (u.value = null)),
    Y(l))
        Tn(l, a, 12, [i, c]);
    else {
        const d = ye(l)
          , h = ve(l);
        if (d || h) {
            const m = ()=>{
                if (e.f) {
                    const v = d ? oe(f, l) ? f[l] : c[l] : l.value;
                    s ? K(v) && Qa(v, o) : K(v) ? v.includes(o) || v.push(o) : d ? (c[l] = [o],
                    oe(f, l) && (f[l] = c[l])) : (l.value = [o],
                    e.k && (c[e.k] = l.value))
                } else
                    d ? (c[l] = i,
                    oe(f, l) && (f[l] = i)) : h && (l.value = i,
                    e.k && (c[e.k] = i))
            }
            ;
            i ? (m.id = -1,
            Ae(m, n)) : m()
        }
    }
}
let cn = !1;
const Qm = e=>e.namespaceURI.includes("svg") && e.tagName !== "foreignObject"
  , Zm = e=>e.namespaceURI.includes("MathML")
  , Ns = e=>{
    if (Qm(e))
        return "svg";
    if (Zm(e))
        return "mathml"
}
  , Ms = e=>e.nodeType === 8;
function eg(e) {
    const {mt: t, p: n, o: {patchProp: r, createText: s, nextSibling: o, parentNode: i, remove: a, insert: l, createComment: u}} = e
      , c = (y,w)=>{
        if (!w.hasChildNodes()) {
            n(null, y, w),
            no(),
            w._vnode = y;
            return
        }
        cn = !1,
        f(w.firstChild, y, null, null, null),
        no(),
        w._vnode = y,
        cn && console.error("Hydration completed but contains mismatches.")
    }
      , f = (y,w,E,_,I,C=!1)=>{
        const R = Ms(y) && y.data === "["
          , L = ()=>v(y, w, E, _, I, R)
          , {type: H, ref: N, shapeFlag: z, patchFlag: se} = w;
        let re = y.nodeType;
        w.el = y,
        se === -2 && (C = !1,
        w.dynamicChildren = null);
        let x = null;
        switch (H) {
        case yr:
            re !== 3 ? w.children === "" ? (l(w.el = s(""), i(y), y),
            x = y) : x = L() : (y.data !== w.children && (cn = !0,
            y.data = w.children),
            x = o(y));
            break;
        case Be:
            b(y) ? (x = o(y),
            k(w.el = y.content.firstChild, y, E)) : re !== 8 || R ? x = L() : x = o(y);
            break;
        case fr:
            if (R && (y = o(y),
            re = y.nodeType),
            re === 1 || re === 3) {
                x = y;
                const Z = !w.children.length;
                for (let q = 0; q < w.staticCount; q++)
                    Z && (w.children += x.nodeType === 1 ? x.outerHTML : x.data),
                    q === w.staticCount - 1 && (w.anchor = x),
                    x = o(x);
                return R ? o(x) : x
            } else
                L();
            break;
        case Te:
            R ? x = m(y, w, E, _, I, C) : x = L();
            break;
        default:
            if (z & 1)
                (re !== 1 || w.type.toLowerCase() !== y.tagName.toLowerCase()) && !b(y) ? x = L() : x = d(y, w, E, _, I, C);
            else if (z & 6) {
                w.slotScopeIds = I;
                const Z = i(y);
                if (R ? x = T(y) : Ms(y) && y.data === "teleport start" ? x = T(y, y.data, "teleport end") : x = o(y),
                t(w, Z, null, E, _, Ns(Z), C),
                $n(w)) {
                    let q;
                    R ? (q = ce(Te),
                    q.anchor = x ? x.previousSibling : Z.lastChild) : q = y.nodeType === 3 ? hs("") : ce("div"),
                    q.el = y,
                    w.component.subTree = q
                }
            } else
                z & 64 ? re !== 8 ? x = L() : x = w.type.hydrate(y, w, E, _, I, C, e, h) : z & 128 && (x = w.type.hydrate(y, w, E, _, Ns(i(y)), I, C, e, f))
        }
        return N != null && io(N, null, _, w),
        x
    }
      , d = (y,w,E,_,I,C)=>{
        C = C || !!w.dynamicChildren;
        const {type: R, props: L, patchFlag: H, shapeFlag: N, dirs: z, transition: se} = w
          , re = R === "input" || R === "option";
        if (re || H !== -1) {
            z && Vt(w, null, E, "created");
            let x = !1;
            if (b(y)) {
                x = ad(_, se) && E && E.vnode.props && E.vnode.props.appear;
                const q = y.content.firstChild;
                x && se.beforeEnter(q),
                k(q, y, E),
                w.el = y = q
            }
            if (N & 16 && !(L && (L.innerHTML || L.textContent))) {
                let q = h(y.firstChild, w, y, E, _, I, C);
                for (; q; ) {
                    cn = !0;
                    const St = q;
                    q = q.nextSibling,
                    a(St)
                }
            } else
                N & 8 && y.textContent !== w.children && (cn = !0,
                y.textContent = w.children);
            if (L)
                if (re || !C || H & 48)
                    for (const q in L)
                        (re && (q.endsWith("value") || q === "indeterminate") || as(q) && !ir(q) || q[0] === ".") && r(y, q, null, L[q], void 0, void 0, E);
                else
                    L.onClick && r(y, "onClick", null, L.onClick, void 0, void 0, E);
            let Z;
            (Z = L && L.onVnodeBeforeMount) && Fe(Z, E, w),
            z && Vt(w, null, E, "beforeMount"),
            ((Z = L && L.onVnodeMounted) || z || x) && qf(()=>{
                Z && Fe(Z, E, w),
                x && se.enter(y),
                z && Vt(w, null, E, "mounted")
            }
            , _)
        }
        return y.nextSibling
    }
      , h = (y,w,E,_,I,C,R)=>{
        R = R || !!w.dynamicChildren;
        const L = w.children
          , H = L.length;
        for (let N = 0; N < H; N++) {
            const z = R ? L[N] : L[N] = Et(L[N]);
            if (y)
                y = f(y, z, _, I, C, R);
            else {
                if (z.type === yr && !z.children)
                    continue;
                cn = !0,
                n(null, z, E, null, _, I, Ns(E), C)
            }
        }
        return y
    }
      , m = (y,w,E,_,I,C)=>{
        const {slotScopeIds: R} = w;
        R && (I = I ? I.concat(R) : R);
        const L = i(y)
          , H = h(o(y), w, L, E, _, I, C);
        return H && Ms(H) && H.data === "]" ? o(w.anchor = H) : (cn = !0,
        l(w.anchor = u("]"), L, H),
        H)
    }
      , v = (y,w,E,_,I,C)=>{
        if (cn = !0,
        w.el = null,
        C) {
            const H = T(y);
            for (; ; ) {
                const N = o(y);
                if (N && N !== H)
                    a(N);
                else
                    break
            }
        }
        const R = o(y)
          , L = i(y);
        return a(y),
        n(null, w, L, R, E, _, Ns(L), I),
        R
    }
      , T = (y,w="[",E="]")=>{
        let _ = 0;
        for (; y; )
            if (y = o(y),
            y && Ms(y) && (y.data === w && _++,
            y.data === E)) {
                if (_ === 0)
                    return o(y);
                _--
            }
        return y
    }
      , k = (y,w,E)=>{
        const _ = w.parentNode;
        _ && _.replaceChild(y, w);
        let I = E;
        for (; I; )
            I.vnode.el === w && (I.vnode.el = I.subTree.el = y),
            I = I.parent
    }
      , b = y=>y.nodeType === 1 && y.tagName.toLowerCase() === "template";
    return [c, f]
}
const Ae = qf;
function tg(e) {
    return id(e)
}
function ng(e) {
    return id(e, eg)
}
function id(e, t) {
    const n = hf();
    n.__VUE__ = !0;
    const {insert: r, remove: s, patchProp: o, createElement: i, createText: a, createComment: l, setText: u, setElementText: c, parentNode: f, nextSibling: d, setScopeId: h=Ct, insertStaticContent: m} = e
      , v = (p,g,S,O=null,A=null,D=null,j=void 0,B=null,F=!!g.dynamicChildren)=>{
        if (p === g)
            return;
        p && !Ot(p, g) && (O = P(p),
        xe(p, A, D, !0),
        p = null),
        g.patchFlag === -2 && (F = !1,
        g.dynamicChildren = null);
        const {type: M, ref: U, shapeFlag: X} = g;
        switch (M) {
        case yr:
            T(p, g, S, O);
            break;
        case Be:
            k(p, g, S, O);
            break;
        case fr:
            p == null && b(g, S, O, j);
            break;
        case Te:
            N(p, g, S, O, A, D, j, B, F);
            break;
        default:
            X & 1 ? E(p, g, S, O, A, D, j, B, F) : X & 6 ? z(p, g, S, O, A, D, j, B, F) : (X & 64 || X & 128) && M.process(p, g, S, O, A, D, j, B, F, W)
        }
        U != null && A && io(U, p && p.ref, D, g || p, !g)
    }
      , T = (p,g,S,O)=>{
        if (p == null)
            r(g.el = a(g.children), S, O);
        else {
            const A = g.el = p.el;
            g.children !== p.children && u(A, g.children)
        }
    }
      , k = (p,g,S,O)=>{
        p == null ? r(g.el = l(g.children || ""), S, O) : g.el = p.el
    }
      , b = (p,g,S,O)=>{
        [p.el,p.anchor] = m(p.children, g, S, O, p.el, p.anchor)
    }
      , y = ({el: p, anchor: g},S,O)=>{
        let A;
        for (; p && p !== g; )
            A = d(p),
            r(p, S, O),
            p = A;
        r(g, S, O)
    }
      , w = ({el: p, anchor: g})=>{
        let S;
        for (; p && p !== g; )
            S = d(p),
            s(p),
            p = S;
        s(g)
    }
      , E = (p,g,S,O,A,D,j,B,F)=>{
        g.type === "svg" ? j = "svg" : g.type === "math" && (j = "mathml"),
        p == null ? _(g, S, O, A, D, j, B, F) : R(p, g, A, D, j, B, F)
    }
      , _ = (p,g,S,O,A,D,j,B)=>{
        let F, M;
        const {props: U, shapeFlag: X, transition: G, dirs: ee} = p;
        if (F = p.el = i(p.type, D, U && U.is, U),
        X & 8 ? c(F, p.children) : X & 16 && C(p.children, F, null, O, A, si(p, D), j, B),
        ee && Vt(p, null, O, "created"),
        I(F, p, p.scopeId, j, O),
        U) {
            for (const fe in U)
                fe !== "value" && !ir(fe) && o(F, fe, null, U[fe], D, p.children, O, A, Ie);
            "value"in U && o(F, "value", null, U.value, D),
            (M = U.onVnodeBeforeMount) && Fe(M, O, p)
        }
        ee && Vt(p, null, O, "beforeMount");
        const te = ad(A, G);
        te && G.beforeEnter(F),
        r(F, g, S),
        ((M = U && U.onVnodeMounted) || te || ee) && Ae(()=>{
            M && Fe(M, O, p),
            te && G.enter(F),
            ee && Vt(p, null, O, "mounted")
        }
        , A)
    }
      , I = (p,g,S,O,A)=>{
        if (S && h(p, S),
        O)
            for (let D = 0; D < O.length; D++)
                h(p, O[D]);
        if (A) {
            let D = A.subTree;
            if (g === D) {
                const j = A.vnode;
                I(p, j, j.scopeId, j.slotScopeIds, A.parent)
            }
        }
    }
      , C = (p,g,S,O,A,D,j,B,F=0)=>{
        for (let M = F; M < p.length; M++) {
            const U = p[M] = B ? mn(p[M]) : Et(p[M]);
            v(null, U, g, S, O, A, D, j, B)
        }
    }
      , R = (p,g,S,O,A,D,j)=>{
        const B = g.el = p.el;
        let {patchFlag: F, dynamicChildren: M, dirs: U} = g;
        F |= p.patchFlag & 16;
        const X = p.props || pe
          , G = g.props || pe;
        let ee;
        if (S && An(S, !1),
        (ee = G.onVnodeBeforeUpdate) && Fe(ee, S, g, p),
        U && Vt(g, p, S, "beforeUpdate"),
        S && An(S, !0),
        M ? L(p.dynamicChildren, M, B, S, O, si(g, A), D) : j || q(p, g, B, null, S, O, si(g, A), D, !1),
        F > 0) {
            if (F & 16)
                H(B, g, X, G, S, O, A);
            else if (F & 2 && X.class !== G.class && o(B, "class", null, G.class, A),
            F & 4 && o(B, "style", X.style, G.style, A),
            F & 8) {
                const te = g.dynamicProps;
                for (let fe = 0; fe < te.length; fe++) {
                    const ge = te[fe]
                      , Se = X[ge]
                      , kt = G[ge];
                    (kt !== Se || ge === "value") && o(B, ge, Se, kt, A, p.children, S, O, Ie)
                }
            }
            F & 1 && p.children !== g.children && c(B, g.children)
        } else
            !j && M == null && H(B, g, X, G, S, O, A);
        ((ee = G.onVnodeUpdated) || U) && Ae(()=>{
            ee && Fe(ee, S, g, p),
            U && Vt(g, p, S, "updated")
        }
        , O)
    }
      , L = (p,g,S,O,A,D,j)=>{
        for (let B = 0; B < g.length; B++) {
            const F = p[B]
              , M = g[B]
              , U = F.el && (F.type === Te || !Ot(F, M) || F.shapeFlag & 70) ? f(F.el) : S;
            v(F, M, U, null, O, A, D, j, !0)
        }
    }
      , H = (p,g,S,O,A,D,j)=>{
        if (S !== O) {
            if (S !== pe)
                for (const B in S)
                    !ir(B) && !(B in O) && o(p, B, S[B], null, j, g.children, A, D, Ie);
            for (const B in O) {
                if (ir(B))
                    continue;
                const F = O[B]
                  , M = S[B];
                F !== M && B !== "value" && o(p, B, M, F, j, g.children, A, D, Ie)
            }
            "value"in O && o(p, "value", S.value, O.value, j)
        }
    }
      , N = (p,g,S,O,A,D,j,B,F)=>{
        const M = g.el = p ? p.el : a("")
          , U = g.anchor = p ? p.anchor : a("");
        let {patchFlag: X, dynamicChildren: G, slotScopeIds: ee} = g;
        ee && (B = B ? B.concat(ee) : ee),
        p == null ? (r(M, S, O),
        r(U, S, O),
        C(g.children || [], S, U, A, D, j, B, F)) : X > 0 && X & 64 && G && p.dynamicChildren ? (L(p.dynamicChildren, G, S, A, D, j, B),
        (g.key != null || A && g === A.subTree) && Tc(p, g, !0)) : q(p, g, S, U, A, D, j, B, F)
    }
      , z = (p,g,S,O,A,D,j,B,F)=>{
        g.slotScopeIds = B,
        p == null ? g.shapeFlag & 512 ? A.ctx.activate(g, S, O, j, F) : se(g, S, O, A, D, j, F) : re(p, g, F)
    }
      , se = (p,g,S,O,A,D,j)=>{
        const B = p.component = ug(p, O, A);
        if (fs(p) && (B.ctx.renderer = W),
        fg(B),
        B.asyncDep) {
            if (A && A.registerDep(B, x),
            !p.el) {
                const F = B.subTree = ce(Be);
                k(null, F, g, S)
            }
        } else
            x(B, p, g, S, A, D, j)
    }
      , re = (p,g,S)=>{
        const O = g.component = p.component;
        if (dm(p, g, S))
            if (O.asyncDep && !O.asyncResolved) {
                Z(O, g, S);
                return
            } else
                O.next = g,
                im(O.update),
                O.effect.dirty = !0,
                O.update();
        else
            g.el = p.el,
            O.vnode = g
    }
      , x = (p,g,S,O,A,D,j)=>{
        const B = ()=>{
            if (p.isMounted) {
                let {next: U, bu: X, u: G, parent: ee, vnode: te} = p;
                {
                    const Qn = cd(p);
                    if (Qn) {
                        U && (U.el = te.el,
                        Z(p, U, j)),
                        Qn.asyncDep.then(()=>{
                            p.isUnmounted || B()
                        }
                        );
                        return
                    }
                }
                let fe = U, ge;
                An(p, !1),
                U ? (U.el = te.el,
                Z(p, U, j)) : U = te,
                X && ar(X),
                (ge = U.props && U.props.onVnodeBeforeUpdate) && Fe(ge, ee, U, te),
                An(p, !0);
                const Se = Qo(p)
                  , kt = p.subTree;
                p.subTree = Se,
                v(kt, Se, f(kt.el), P(kt), p, A, D),
                U.el = Se.el,
                fe === null && fc(p, Se.el),
                G && Ae(G, A),
                (ge = U.props && U.props.onVnodeUpdated) && Ae(()=>Fe(ge, ee, U, te), A)
            } else {
                let U;
                const {el: X, props: G} = g
                  , {bm: ee, m: te, parent: fe} = p
                  , ge = $n(g);
                if (An(p, !1),
                ee && ar(ee),
                !ge && (U = G && G.onVnodeBeforeMount) && Fe(U, fe, g),
                An(p, !0),
                X && me) {
                    const Se = ()=>{
                        p.subTree = Qo(p),
                        me(X, p.subTree, p, A, null)
                    }
                    ;
                    ge ? g.type.__asyncLoader().then(()=>!p.isUnmounted && Se()) : Se()
                } else {
                    const Se = p.subTree = Qo(p);
                    v(null, Se, S, O, p, A, D),
                    g.el = Se.el
                }
                if (te && Ae(te, A),
                !ge && (U = G && G.onVnodeMounted)) {
                    const Se = g;
                    Ae(()=>Fe(U, fe, Se), A)
                }
                (g.shapeFlag & 256 || fe && $n(fe.vnode) && fe.vnode.shapeFlag & 256) && p.a && Ae(p.a, A),
                p.isMounted = !0,
                g = S = O = null
            }
        }
          , F = p.effect = new nc(B,Ct,()=>Lo(M),p.scope)
          , M = p.update = ()=>{
            F.dirty && F.run()
        }
        ;
        M.id = p.uid,
        An(p, !0),
        M()
    }
      , Z = (p,g,S)=>{
        g.component = p;
        const O = p.vnode.props;
        p.vnode = g,
        p.next = null,
        Gm(p, g.props, O, S),
        Ym(p, g.children, S),
        qn(),
        al(p),
        Wn()
    }
      , q = (p,g,S,O,A,D,j,B,F=!1)=>{
        const M = p && p.children
          , U = p ? p.shapeFlag : 0
          , X = g.children
          , {patchFlag: G, shapeFlag: ee} = g;
        if (G > 0) {
            if (G & 128) {
                sn(M, X, S, O, A, D, j, B, F);
                return
            } else if (G & 256) {
                St(M, X, S, O, A, D, j, B, F);
                return
            }
        }
        ee & 8 ? (U & 16 && Ie(M, A, D),
        X !== M && c(S, X)) : U & 16 ? ee & 16 ? sn(M, X, S, O, A, D, j, B, F) : Ie(M, A, D, !0) : (U & 8 && c(S, ""),
        ee & 16 && C(X, S, O, A, D, j, B, F))
    }
      , St = (p,g,S,O,A,D,j,B,F)=>{
        p = p || sr,
        g = g || sr;
        const M = p.length
          , U = g.length
          , X = Math.min(M, U);
        let G;
        for (G = 0; G < X; G++) {
            const ee = g[G] = F ? mn(g[G]) : Et(g[G]);
            v(p[G], ee, S, null, A, D, j, B, F)
        }
        M > U ? Ie(p, A, D, !0, !1, X) : C(g, S, O, A, D, j, B, F, X)
    }
      , sn = (p,g,S,O,A,D,j,B,F)=>{
        let M = 0;
        const U = g.length;
        let X = p.length - 1
          , G = U - 1;
        for (; M <= X && M <= G; ) {
            const ee = p[M]
              , te = g[M] = F ? mn(g[M]) : Et(g[M]);
            if (Ot(ee, te))
                v(ee, te, S, null, A, D, j, B, F);
            else
                break;
            M++
        }
        for (; M <= X && M <= G; ) {
            const ee = p[X]
              , te = g[G] = F ? mn(g[G]) : Et(g[G]);
            if (Ot(ee, te))
                v(ee, te, S, null, A, D, j, B, F);
            else
                break;
            X--,
            G--
        }
        if (M > X) {
            if (M <= G) {
                const ee = G + 1
                  , te = ee < U ? g[ee].el : O;
                for (; M <= G; )
                    v(null, g[M] = F ? mn(g[M]) : Et(g[M]), S, te, A, D, j, B, F),
                    M++
            }
        } else if (M > G)
            for (; M <= X; )
                xe(p[M], A, D, !0),
                M++;
        else {
            const ee = M
              , te = M
              , fe = new Map;
            for (M = te; M <= G; M++) {
                const $e = g[M] = F ? mn(g[M]) : Et(g[M]);
                $e.key != null && fe.set($e.key, M)
            }
            let ge, Se = 0;
            const kt = G - te + 1;
            let Qn = !1
              , Jc = 0;
            const Ar = new Array(kt);
            for (M = 0; M < kt; M++)
                Ar[M] = 0;
            for (M = ee; M <= X; M++) {
                const $e = p[M];
                if (Se >= kt) {
                    xe($e, A, D, !0);
                    continue
                }
                let $t;
                if ($e.key != null)
                    $t = fe.get($e.key);
                else
                    for (ge = te; ge <= G; ge++)
                        if (Ar[ge - te] === 0 && Ot($e, g[ge])) {
                            $t = ge;
                            break
                        }
                $t === void 0 ? xe($e, A, D, !0) : (Ar[$t - te] = M + 1,
                $t >= Jc ? Jc = $t : Qn = !0,
                v($e, g[$t], S, null, A, D, j, B, F),
                Se++)
            }
            const Xc = Qn ? rg(Ar) : sr;
            for (ge = Xc.length - 1,
            M = kt - 1; M >= 0; M--) {
                const $e = te + M
                  , $t = g[$e]
                  , Yc = $e + 1 < U ? g[$e + 1].el : O;
                Ar[M] === 0 ? v(null, $t, S, Yc, A, D, j, B, F) : Qn && (ge < 0 || M !== Xc[ge] ? Ht($t, S, Yc, 2) : ge--)
            }
        }
    }
      , Ht = (p,g,S,O,A=null)=>{
        const {el: D, type: j, transition: B, children: F, shapeFlag: M} = p;
        if (M & 6) {
            Ht(p.component.subTree, g, S, O);
            return
        }
        if (M & 128) {
            p.suspense.move(g, S, O);
            return
        }
        if (M & 64) {
            j.move(p, g, S, W);
            return
        }
        if (j === Te) {
            r(D, g, S);
            for (let X = 0; X < F.length; X++)
                Ht(F[X], g, S, O);
            r(p.anchor, g, S);
            return
        }
        if (j === fr) {
            y(p, g, S);
            return
        }
        if (O !== 2 && M & 1 && B)
            if (O === 0)
                B.beforeEnter(D),
                r(D, g, S),
                Ae(()=>B.enter(D), A);
            else {
                const {leave: X, delayLeave: G, afterLeave: ee} = B
                  , te = ()=>r(D, g, S)
                  , fe = ()=>{
                    X(D, ()=>{
                        te(),
                        ee && ee()
                    }
                    )
                }
                ;
                G ? G(D, te, fe) : fe()
            }
        else
            r(D, g, S)
    }
      , xe = (p,g,S,O=!1,A=!1)=>{
        const {type: D, props: j, ref: B, children: F, dynamicChildren: M, shapeFlag: U, patchFlag: X, dirs: G} = p;
        if (B != null && io(B, null, S, p, !0),
        U & 256) {
            g.ctx.deactivate(p);
            return
        }
        const ee = U & 1 && G
          , te = !$n(p);
        let fe;
        if (te && (fe = j && j.onVnodeBeforeUnmount) && Fe(fe, g, p),
        U & 6)
            Ss(p.component, S, O);
        else {
            if (U & 128) {
                p.suspense.unmount(S, O);
                return
            }
            ee && Vt(p, null, g, "beforeUnmount"),
            U & 64 ? p.type.remove(p, g, S, A, W, O) : M && (D !== Te || X > 0 && X & 64) ? Ie(M, g, S, !1, !0) : (D === Te && X & 384 || !A && U & 16) && Ie(F, g, S),
            O && Xn(p)
        }
        (te && (fe = j && j.onVnodeUnmounted) || ee) && Ae(()=>{
            fe && Fe(fe, g, p),
            ee && Vt(p, null, g, "unmounted")
        }
        , S)
    }
      , Xn = p=>{
        const {type: g, el: S, anchor: O, transition: A} = p;
        if (g === Te) {
            Yn(S, O);
            return
        }
        if (g === fr) {
            w(p);
            return
        }
        const D = ()=>{
            s(S),
            A && !A.persisted && A.afterLeave && A.afterLeave()
        }
        ;
        if (p.shapeFlag & 1 && A && !A.persisted) {
            const {leave: j, delayLeave: B} = A
              , F = ()=>j(S, D);
            B ? B(p.el, D, F) : F()
        } else
            D()
    }
      , Yn = (p,g)=>{
        let S;
        for (; p !== g; )
            S = d(p),
            s(p),
            p = S;
        s(g)
    }
      , Ss = (p,g,S)=>{
        const {bum: O, scope: A, update: D, subTree: j, um: B} = p;
        O && ar(O),
        A.stop(),
        D && (D.active = !1,
        xe(j, p, g, S)),
        B && Ae(B, g),
        Ae(()=>{
            p.isUnmounted = !0
        }
        , g),
        g && g.pendingBranch && !g.isUnmounted && p.asyncDep && !p.asyncResolved && p.suspenseId === g.pendingId && (g.deps--,
        g.deps === 0 && g.resolve())
    }
      , Ie = (p,g,S,O=!1,A=!1,D=0)=>{
        for (let j = D; j < p.length; j++)
            xe(p[j], g, S, O, A)
    }
      , P = p=>p.shapeFlag & 6 ? P(p.component.subTree) : p.shapeFlag & 128 ? p.suspense.next() : d(p.anchor || p.el);
    let V = !1;
    const $ = (p,g,S)=>{
        p == null ? g._vnode && xe(g._vnode, null, null, !0) : v(g._vnode || null, p, g, null, null, null, S),
        V || (V = !0,
        al(),
        no(),
        V = !1),
        g._vnode = p
    }
      , W = {
        p: v,
        um: xe,
        m: Ht,
        r: Xn,
        mt: se,
        mc: C,
        pc: q,
        pbc: L,
        n: P,
        o: e
    };
    let ae, me;
    return t && ([ae,me] = t(W)),
    {
        render: $,
        hydrate: ae,
        createApp: Km($, ae)
    }
}
function si({type: e, props: t}, n) {
    return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}
function An({effect: e, update: t}, n) {
    e.allowRecurse = t.allowRecurse = n
}
function ad(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}
function Tc(e, t, n=!1) {
    const r = e.children
      , s = t.children;
    if (K(r) && K(s))
        for (let o = 0; o < r.length; o++) {
            const i = r[o];
            let a = s[o];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = s[o] = mn(s[o]),
            a.el = i.el),
            n || Tc(i, a)),
            a.type === yr && (a.el = i.el)
        }
}
function rg(e) {
    const t = e.slice()
      , n = [0];
    let r, s, o, i, a;
    const l = e.length;
    for (r = 0; r < l; r++) {
        const u = e[r];
        if (u !== 0) {
            if (s = n[n.length - 1],
            e[s] < u) {
                t[r] = s,
                n.push(r);
                continue
            }
            for (o = 0,
            i = n.length - 1; o < i; )
                a = o + i >> 1,
                e[n[a]] < u ? o = a + 1 : i = a;
            u < e[n[o]] && (o > 0 && (t[r] = n[o - 1]),
            n[o] = r)
        }
    }
    for (o = n.length,
    i = n[o - 1]; o-- > 0; )
        n[o] = i,
        i = t[i];
    return n
}
function cd(e) {
    const t = e.subTree.component;
    if (t)
        return t.asyncDep && !t.asyncResolved ? t : cd(t)
}
const sg = e=>e.__isTeleport
  , Fr = e=>e && (e.disabled || e.disabled === "")
  , El = e=>typeof SVGElement < "u" && e instanceof SVGElement
  , Cl = e=>typeof MathMLElement == "function" && e instanceof MathMLElement
  , ca = (e,t)=>{
    const n = e && e.to;
    return ye(n) ? t ? t(n) : null : n
}
  , og = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, n, r, s, o, i, a, l, u) {
        const {mc: c, pc: f, pbc: d, o: {insert: h, querySelector: m, createText: v, createComment: T}} = u
          , k = Fr(t.props);
        let {shapeFlag: b, children: y, dynamicChildren: w} = t;
        if (e == null) {
            const E = t.el = v("")
              , _ = t.anchor = v("");
            h(E, n, r),
            h(_, n, r);
            const I = t.target = ca(t.props, m)
              , C = t.targetAnchor = v("");
            I && (h(C, I),
            i === "svg" || El(I) ? i = "svg" : (i === "mathml" || Cl(I)) && (i = "mathml"));
            const R = (L,H)=>{
                b & 16 && c(y, L, H, s, o, i, a, l)
            }
            ;
            k ? R(n, _) : I && R(I, C)
        } else {
            t.el = e.el;
            const E = t.anchor = e.anchor
              , _ = t.target = e.target
              , I = t.targetAnchor = e.targetAnchor
              , C = Fr(e.props)
              , R = C ? n : _
              , L = C ? E : I;
            if (i === "svg" || El(_) ? i = "svg" : (i === "mathml" || Cl(_)) && (i = "mathml"),
            w ? (d(e.dynamicChildren, w, R, s, o, i, a),
            Tc(e, t, !0)) : l || f(e, t, R, L, s, o, i, a, !1),
            k)
                C ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Bs(t, n, E, u, 1);
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                const H = t.target = ca(t.props, m);
                H && Bs(t, H, null, u, 0)
            } else
                C && Bs(t, _, I, u, 1)
        }
        ld(t)
    },
    remove(e, t, n, r, {um: s, o: {remove: o}}, i) {
        const {shapeFlag: a, children: l, anchor: u, targetAnchor: c, target: f, props: d} = e;
        if (f && o(c),
        i && o(u),
        a & 16) {
            const h = i || !Fr(d);
            for (let m = 0; m < l.length; m++) {
                const v = l[m];
                s(v, t, n, h, !!v.dynamicChildren)
            }
        }
    },
    move: Bs,
    hydrate: ig
};
function Bs(e, t, n, {o: {insert: r}, m: s}, o=2) {
    o === 0 && r(e.targetAnchor, t, n);
    const {el: i, anchor: a, shapeFlag: l, children: u, props: c} = e
      , f = o === 2;
    if (f && r(i, t, n),
    (!f || Fr(c)) && l & 16)
        for (let d = 0; d < u.length; d++)
            s(u[d], t, n, 2);
    f && r(a, t, n)
}
function ig(e, t, n, r, s, o, {o: {nextSibling: i, parentNode: a, querySelector: l}}, u) {
    const c = t.target = ca(t.props, l);
    if (c) {
        const f = c._lpa || c.firstChild;
        if (t.shapeFlag & 16)
            if (Fr(t.props))
                t.anchor = u(i(e), t, a(e), n, r, s, o),
                t.targetAnchor = f;
            else {
                t.anchor = i(e);
                let d = f;
                for (; d; )
                    if (d = i(d),
                    d && d.nodeType === 8 && d.data === "teleport anchor") {
                        t.targetAnchor = d,
                        c._lpa = t.targetAnchor && i(t.targetAnchor);
                        break
                    }
                u(f, t, c, n, r, s, o)
            }
        ld(t)
    }
    return t.anchor && i(t.anchor)
}
const ZT = og;
function ld(e) {
    const t = e.ctx;
    if (t && t.ut) {
        let n = e.children[0].el;
        for (; n && n !== e.targetAnchor; )
            n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid),
            n = n.nextSibling;
        t.ut()
    }
}
const Te = Symbol.for("v-fgt")
  , yr = Symbol.for("v-txt")
  , Be = Symbol.for("v-cmt")
  , fr = Symbol.for("v-stc")
  , Hr = [];
let Tt = null;
function ue(e=!1) {
    Hr.push(Tt = e ? null : [])
}
function ud() {
    Hr.pop(),
    Tt = Hr[Hr.length - 1] || null
}
let vr = 1;
function Tl(e) {
    vr += e
}
function fd(e) {
    return e.dynamicChildren = vr > 0 ? Tt || sr : null,
    ud(),
    vr > 0 && Tt && Tt.push(e),
    e
}
function It(e, t, n, r, s, o) {
    return fd(Kn(e, t, n, r, s, o, !0))
}
function Pe(e, t, n, r, s) {
    return fd(ce(e, t, n, r, s, !0))
}
function br(e) {
    return e ? e.__v_isVNode === !0 : !1
}
function Ot(e, t) {
    return e.type === t.type && e.key === t.key
}
const xo = "__vInternal"
  , dd = ({key: e})=>e ?? null
  , Ks = ({ref: e, ref_key: t, ref_for: n})=>(typeof e == "number" && (e = "" + e),
e != null ? ye(e) || ve(e) || Y(e) ? {
    i: Ee,
    r: e,
    k: t,
    f: !!n
} : e : null);
function Kn(e, t=null, n=null, r=0, s=null, o=e === Te ? 0 : 1, i=!1, a=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && dd(t),
        ref: t && Ks(t),
        scopeId: Mo,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: o,
        patchFlag: r,
        dynamicProps: s,
        dynamicChildren: null,
        appContext: null,
        ctx: Ee
    };
    return a ? (_c(l, n),
    o & 128 && e.normalize(l)) : n && (l.shapeFlag |= ye(n) ? 8 : 16),
    vr > 0 && !i && Tt && (l.patchFlag > 0 || o & 6) && l.patchFlag !== 32 && Tt.push(l),
    l
}
const ce = ag;
function ag(e, t=null, n=null, r=0, s=null, o=!1) {
    if ((!e || e === Vf) && (e = Be),
    br(e)) {
        const a = tn(e, t, !0);
        return n && _c(a, n),
        vr > 0 && !o && Tt && (a.shapeFlag & 6 ? Tt[Tt.indexOf(e)] = a : Tt.push(a)),
        a.patchFlag |= -2,
        a
    }
    if (pg(e) && (e = e.__vccOpts),
    t) {
        t = hd(t);
        let {class: a, style: l} = t;
        a && !ye(a) && (t.class = en(a)),
        de(l) && (If(l) && !K(l) && (l = we({}, l)),
        t.style = _r(l))
    }
    const i = ye(e) ? 1 : Uf(e) ? 128 : sg(e) ? 64 : de(e) ? 4 : Y(e) ? 2 : 0;
    return Kn(e, t, n, r, s, i, o, !0)
}
function hd(e) {
    return e ? If(e) || xo in e ? we({}, e) : e : null
}
function tn(e, t, n=!1) {
    const {props: r, ref: s, patchFlag: o, children: i} = e
      , a = t ? ps(r || {}, t) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: a,
        key: a && dd(a),
        ref: t && t.ref ? n && s ? K(s) ? s.concat(Ks(t)) : [s, Ks(t)] : Ks(t) : s,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: i,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Te ? o === -1 ? 16 : o | 16 : o,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && tn(e.ssContent),
        ssFallback: e.ssFallback && tn(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    }
}
function hs(e=" ", t=0) {
    return ce(yr, null, e, t)
}
function e_(e, t) {
    const n = ce(fr, null, e);
    return n.staticCount = t,
    n
}
function oi(e="", t=!1) {
    return t ? (ue(),
    Pe(Be, null, e)) : ce(Be, null, e)
}
function Et(e) {
    return e == null || typeof e == "boolean" ? ce(Be) : K(e) ? ce(Te, null, e.slice()) : typeof e == "object" ? mn(e) : ce(yr, null, String(e))
}
function mn(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : tn(e)
}
function _c(e, t) {
    let n = 0;
    const {shapeFlag: r} = e;
    if (t == null)
        t = null;
    else if (K(t))
        n = 16;
    else if (typeof t == "object")
        if (r & 65) {
            const s = t.default;
            s && (s._c && (s._d = !1),
            _c(e, s()),
            s._c && (s._d = !0));
            return
        } else {
            n = 32;
            const s = t._;
            !s && !(xo in t) ? t._ctx = Ee : s === 3 && Ee && (Ee.slots._ === 1 ? t._ = 1 : (t._ = 2,
            e.patchFlag |= 1024))
        }
    else
        Y(t) ? (t = {
            default: t,
            _ctx: Ee
        },
        n = 32) : (t = String(t),
        r & 64 ? (n = 16,
        t = [hs(t)]) : n = 8);
    e.children = t,
    e.shapeFlag |= n
}
function ps(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const s in r)
            if (s === "class")
                t.class !== r.class && (t.class = en([t.class, r.class]));
            else if (s === "style")
                t.style = _r([t.style, r.style]);
            else if (as(s)) {
                const o = t[s]
                  , i = r[s];
                i && o !== i && !(K(o) && o.includes(i)) && (t[s] = o ? [].concat(o, i) : i)
            } else
                s !== "" && (t[s] = r[s])
    }
    return t
}
function Fe(e, t, n, r=null) {
    _t(e, t, 7, [n, r])
}
const cg = ed();
let lg = 0;
function ug(e, t, n) {
    const r = e.type
      , s = (t ? t.appContext : e.appContext) || cg
      , o = {
        uid: lg++,
        vnode: e,
        type: r,
        parent: t,
        appContext: s,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new vf(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(s.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: nd(r, s),
        emitsOptions: jf(r, s),
        emit: null,
        emitted: null,
        propsDefaults: pe,
        inheritAttrs: r.inheritAttrs,
        ctx: pe,
        data: pe,
        props: pe,
        attrs: pe,
        slots: pe,
        refs: pe,
        setupState: pe,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return o.ctx = {
        _: o
    },
    o.root = t ? t.root : o,
    o.emit = cm.bind(null, o),
    e.ce && e.ce(o),
    o
}
let _e = null;
const Gt = ()=>_e || Ee;
let ao, la;
{
    const e = hf()
      , t = (n,r)=>{
        let s;
        return (s = e[n]) || (s = e[n] = []),
        s.push(r),
        o=>{
            s.length > 1 ? s.forEach(i=>i(o)) : s[0](o)
        }
    }
    ;
    ao = t("__VUE_INSTANCE_SETTERS__", n=>_e = n),
    la = t("__VUE_SSR_SETTERS__", n=>ms = n)
}
const Un = e=>{
    const t = _e;
    return ao(e),
    e.scope.on(),
    ()=>{
        e.scope.off(),
        ao(t)
    }
}
  , ua = ()=>{
    _e && _e.scope.off(),
    ao(null)
}
;
function pd(e) {
    return e.vnode.shapeFlag & 4
}
let ms = !1;
function fg(e, t=!1) {
    t && la(t);
    const {props: n, children: r} = e.vnode
      , s = pd(e);
    zm(e, n, s, t),
    Xm(e, r);
    const o = s ? dg(e, t) : void 0;
    return t && la(!1),
    o
}
function dg(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null),
    e.proxy = Io(new Proxy(e.ctx,Hm));
    const {setup: r} = n;
    if (r) {
        const s = e.setupContext = r.length > 1 ? gd(e) : null
          , o = Un(e);
        qn();
        const i = Tn(r, e, 0, [e.props, s]);
        if (Wn(),
        o(),
        Za(i)) {
            if (i.then(ua, ua),
            t)
                return i.then(a=>{
                    fa(e, a, t)
                }
                ).catch(a=>{
                    Sr(a, e, 0)
                }
                );
            e.asyncDep = i
        } else
            fa(e, i, t)
    } else
        md(e, t)
}
function fa(e, t, n) {
    Y(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : de(t) && (e.setupState = Mf(t)),
    md(e, n)
}
let _l;
function md(e, t, n) {
    const r = e.type;
    if (!e.render) {
        if (!t && _l && !r.render) {
            const s = r.template || wc(e).template;
            if (s) {
                const {isCustomElement: o, compilerOptions: i} = e.appContext.config
                  , {delimiters: a, compilerOptions: l} = r
                  , u = we(we({
                    isCustomElement: o,
                    delimiters: a
                }, i), l);
                r.render = _l(s, u)
            }
        }
        e.render = r.render || Ct
    }
    {
        const s = Un(e);
        qn();
        try {
            $m(e)
        } finally {
            Wn(),
            s()
        }
    }
}
function hg(e) {
    return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs,{
        get(t, n) {
            return He(e, "get", "$attrs"),
            t[n]
        }
    }))
}
function gd(e) {
    const t = n=>{
        e.exposed = n || {}
    }
    ;
    return {
        get attrs() {
            return hg(e)
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function Fo(e) {
    if (e.exposed)
        return e.exposeProxy || (e.exposeProxy = new Proxy(Mf(Io(e.exposed)),{
            get(t, n) {
                if (n in t)
                    return t[n];
                if (n in xr)
                    return xr[n](e)
            },
            has(t, n) {
                return n in t || n in xr
            }
        }))
}
function da(e, t=!0) {
    return Y(e) ? e.displayName || e.name : e.name || t && e.__name
}
function pg(e) {
    return Y(e) && "__vccOpts"in e
}
const ft = (e,t)=>Yp(e, t, ms);
function t_(e, t, n=pe) {
    const r = Gt()
      , s = Mt(t)
      , o = Sn(t)
      , i = Bf((l,u)=>{
        let c;
        return Tm(()=>{
            const f = e[t];
            Kt(c, f) && (c = f,
            u())
        }
        ),
        {
            get() {
                return l(),
                n.get ? n.get(c) : c
            },
            set(f) {
                const d = r.vnode.props;
                !(d && (t in d || s in d || o in d) && (`onUpdate:${t}`in d || `onUpdate:${s}`in d || `onUpdate:${o}`in d)) && Kt(f, c) && (c = f,
                u()),
                r.emit(`update:${t}`, n.set ? n.set(f) : f)
            }
        }
    }
    )
      , a = t === "modelValue" ? "modelModifiers" : `${t}Modifiers`;
    return i[Symbol.iterator] = ()=>{
        let l = 0;
        return {
            next() {
                return l < 2 ? {
                    value: l++ ? e[a] || {} : i,
                    done: !1
                } : {
                    done: !0
                }
            }
        }
    }
    ,
    i
}
function gt(e, t, n) {
    const r = arguments.length;
    return r === 2 ? de(t) && !K(t) ? br(t) ? ce(e, null, [t]) : ce(e, t) : ce(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && br(n) && (n = [n]),
    ce(e, t, n))
}
const yd = "3.4.21";
/**
* @vue/runtime-dom v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const mg = "http://www.w3.org/2000/svg"
  , gg = "http://www.w3.org/1998/Math/MathML"
  , gn = typeof document < "u" ? document : null
  , Sl = gn && gn.createElement("template")
  , yg = {
    insert: (e,t,n)=>{
        t.insertBefore(e, n || null)
    }
    ,
    remove: e=>{
        const t = e.parentNode;
        t && t.removeChild(e)
    }
    ,
    createElement: (e,t,n,r)=>{
        const s = t === "svg" ? gn.createElementNS(mg, e) : t === "mathml" ? gn.createElementNS(gg, e) : gn.createElement(e, n ? {
            is: n
        } : void 0);
        return e === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple),
        s
    }
    ,
    createText: e=>gn.createTextNode(e),
    createComment: e=>gn.createComment(e),
    setText: (e,t)=>{
        e.nodeValue = t
    }
    ,
    setElementText: (e,t)=>{
        e.textContent = t
    }
    ,
    parentNode: e=>e.parentNode,
    nextSibling: e=>e.nextSibling,
    querySelector: e=>gn.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, r, s, o) {
        const i = n ? n.previousSibling : t.lastChild;
        if (s && (s === o || s.nextSibling))
            for (; t.insertBefore(s.cloneNode(!0), n),
            !(s === o || !(s = s.nextSibling)); )
                ;
        else {
            Sl.innerHTML = r === "svg" ? `<svg>${e}</svg>` : r === "mathml" ? `<math>${e}</math>` : e;
            const a = Sl.content;
            if (r === "svg" || r === "mathml") {
                const l = a.firstChild;
                for (; l.firstChild; )
                    a.appendChild(l.firstChild);
                a.removeChild(l)
            }
            t.insertBefore(a, n)
        }
        return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
}
  , ln = "transition"
  , Pr = "animation"
  , wr = Symbol("_vtc")
  , Ho = (e,{slots: t})=>gt(km, bd(e), t);
Ho.displayName = "Transition";
const vd = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , vg = Ho.props = we({}, zf, vd)
  , Pn = (e,t=[])=>{
    K(e) ? e.forEach(n=>n(...t)) : e && e(...t)
}
  , kl = e=>e ? K(e) ? e.some(t=>t.length > 1) : e.length > 1 : !1;
function bd(e) {
    const t = {};
    for (const N in e)
        N in vd || (t[N] = e[N]);
    if (e.css === !1)
        return t;
    const {name: n="v", type: r, duration: s, enterFromClass: o=`${n}-enter-from`, enterActiveClass: i=`${n}-enter-active`, enterToClass: a=`${n}-enter-to`, appearFromClass: l=o, appearActiveClass: u=i, appearToClass: c=a, leaveFromClass: f=`${n}-leave-from`, leaveActiveClass: d=`${n}-leave-active`, leaveToClass: h=`${n}-leave-to`} = e
      , m = bg(s)
      , v = m && m[0]
      , T = m && m[1]
      , {onBeforeEnter: k, onEnter: b, onEnterCancelled: y, onLeave: w, onLeaveCancelled: E, onBeforeAppear: _=k, onAppear: I=b, onAppearCancelled: C=y} = t
      , R = (N,z,se)=>{
        fn(N, z ? c : a),
        fn(N, z ? u : i),
        se && se()
    }
      , L = (N,z)=>{
        N._isLeaving = !1,
        fn(N, f),
        fn(N, h),
        fn(N, d),
        z && z()
    }
      , H = N=>(z,se)=>{
        const re = N ? I : b
          , x = ()=>R(z, N, se);
        Pn(re, [z, x]),
        Rl(()=>{
            fn(z, N ? l : o),
            Xt(z, N ? c : a),
            kl(re) || Al(z, r, v, x)
        }
        )
    }
    ;
    return we(t, {
        onBeforeEnter(N) {
            Pn(k, [N]),
            Xt(N, o),
            Xt(N, i)
        },
        onBeforeAppear(N) {
            Pn(_, [N]),
            Xt(N, l),
            Xt(N, u)
        },
        onEnter: H(!1),
        onAppear: H(!0),
        onLeave(N, z) {
            N._isLeaving = !0;
            const se = ()=>L(N, z);
            Xt(N, f),
            Ed(),
            Xt(N, d),
            Rl(()=>{
                N._isLeaving && (fn(N, f),
                Xt(N, h),
                kl(w) || Al(N, r, T, se))
            }
            ),
            Pn(w, [N, se])
        },
        onEnterCancelled(N) {
            R(N, !1),
            Pn(y, [N])
        },
        onAppearCancelled(N) {
            R(N, !0),
            Pn(C, [N])
        },
        onLeaveCancelled(N) {
            L(N),
            Pn(E, [N])
        }
    })
}
function bg(e) {
    if (e == null)
        return null;
    if (de(e))
        return [ii(e.enter), ii(e.leave)];
    {
        const t = ii(e);
        return [t, t]
    }
}
function ii(e) {
    return df(e)
}
function Xt(e, t) {
    t.split(/\s+/).forEach(n=>n && e.classList.add(n)),
    (e[wr] || (e[wr] = new Set)).add(t)
}
function fn(e, t) {
    t.split(/\s+/).forEach(r=>r && e.classList.remove(r));
    const n = e[wr];
    n && (n.delete(t),
    n.size || (e[wr] = void 0))
}
function Rl(e) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(e)
    }
    )
}
let wg = 0;
function Al(e, t, n, r) {
    const s = e._endId = ++wg
      , o = ()=>{
        s === e._endId && r()
    }
    ;
    if (n)
        return setTimeout(o, n);
    const {type: i, timeout: a, propCount: l} = wd(e, t);
    if (!i)
        return r();
    const u = i + "end";
    let c = 0;
    const f = ()=>{
        e.removeEventListener(u, d),
        o()
    }
      , d = h=>{
        h.target === e && ++c >= l && f()
    }
    ;
    setTimeout(()=>{
        c < l && f()
    }
    , a + 1),
    e.addEventListener(u, d)
}
function wd(e, t) {
    const n = window.getComputedStyle(e)
      , r = m=>(n[m] || "").split(", ")
      , s = r(`${ln}Delay`)
      , o = r(`${ln}Duration`)
      , i = Pl(s, o)
      , a = r(`${Pr}Delay`)
      , l = r(`${Pr}Duration`)
      , u = Pl(a, l);
    let c = null
      , f = 0
      , d = 0;
    t === ln ? i > 0 && (c = ln,
    f = i,
    d = o.length) : t === Pr ? u > 0 && (c = Pr,
    f = u,
    d = l.length) : (f = Math.max(i, u),
    c = f > 0 ? i > u ? ln : Pr : null,
    d = c ? c === ln ? o.length : l.length : 0);
    const h = c === ln && /\b(transform|all)(,|$)/.test(r(`${ln}Property`).toString());
    return {
        type: c,
        timeout: f,
        propCount: d,
        hasTransform: h
    }
}
function Pl(e, t) {
    for (; e.length < t.length; )
        e = e.concat(e);
    return Math.max(...t.map((n,r)=>Ol(n) + Ol(e[r])))
}
function Ol(e) {
    return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}
function Ed() {
    return document.body.offsetHeight
}
function Eg(e, t, n) {
    const r = e[wr];
    r && (t = (t ? [t, ...r] : [...r]).join(" ")),
    t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
const co = Symbol("_vod")
  , Cd = Symbol("_vsh")
  , n_ = {
    beforeMount(e, {value: t}, {transition: n}) {
        e[co] = e.style.display === "none" ? "" : e.style.display,
        n && t ? n.beforeEnter(e) : Or(e, t)
    },
    mounted(e, {value: t}, {transition: n}) {
        n && t && n.enter(e)
    },
    updated(e, {value: t, oldValue: n}, {transition: r}) {
        !t != !n && (r ? t ? (r.beforeEnter(e),
        Or(e, !0),
        r.enter(e)) : r.leave(e, ()=>{
            Or(e, !1)
        }
        ) : Or(e, t))
    },
    beforeUnmount(e, {value: t}) {
        Or(e, t)
    }
};
function Or(e, t) {
    e.style.display = t ? e[co] : "none",
    e[Cd] = !t
}
const Td = Symbol("");
function r_(e) {
    const t = Gt();
    if (!t)
        return;
    const n = t.ut = (s=e(t.proxy))=>{
        Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(o=>pa(o, s))
    }
      , r = ()=>{
        const s = e(t.proxy);
        ha(t.subTree, s),
        n(s)
    }
    ;
    Cm(r),
    ds(()=>{
        const s = new MutationObserver(r);
        s.observe(t.subTree.el.parentNode, {
            childList: !0
        }),
        bc(()=>s.disconnect())
    }
    )
}
function ha(e, t) {
    if (e.shapeFlag & 128) {
        const n = e.suspense;
        e = n.activeBranch,
        n.pendingBranch && !n.isHydrating && n.effects.push(()=>{
            ha(n.activeBranch, t)
        }
        )
    }
    for (; e.component; )
        e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el)
        pa(e.el, t);
    else if (e.type === Te)
        e.children.forEach(n=>ha(n, t));
    else if (e.type === fr) {
        let {el: n, anchor: r} = e;
        for (; n && (pa(n, t),
        n !== r); )
            n = n.nextSibling
    }
}
function pa(e, t) {
    if (e.nodeType === 1) {
        const n = e.style;
        let r = "";
        for (const s in t)
            n.setProperty(`--${s}`, t[s]),
            r += `--${s}: ${t[s]};`;
        n[Td] = r
    }
}
const Cg = /(^|;)\s*display\s*:/;
function Tg(e, t, n) {
    const r = e.style
      , s = ye(n);
    let o = !1;
    if (n && !s) {
        if (t)
            if (ye(t))
                for (const i of t.split(";")) {
                    const a = i.slice(0, i.indexOf(":")).trim();
                    n[a] == null && zs(r, a, "")
                }
            else
                for (const i in t)
                    n[i] == null && zs(r, i, "");
        for (const i in n)
            i === "display" && (o = !0),
            zs(r, i, n[i])
    } else if (s) {
        if (t !== n) {
            const i = r[Td];
            i && (n += ";" + i),
            r.cssText = n,
            o = Cg.test(n)
        }
    } else
        t && e.removeAttribute("style");
    co in e && (e[co] = o ? r.display : "",
    e[Cd] && (r.display = "none"))
}
const Il = /\s*!important$/;
function zs(e, t, n) {
    if (K(n))
        n.forEach(r=>zs(e, t, r));
    else if (n == null && (n = ""),
    t.startsWith("--"))
        e.setProperty(t, n);
    else {
        const r = _g(e, t);
        Il.test(n) ? e.setProperty(Sn(r), n.replace(Il, ""), "important") : e[r] = n
    }
}
const Ll = ["Webkit", "Moz", "ms"]
  , ai = {};
function _g(e, t) {
    const n = ai[t];
    if (n)
        return n;
    let r = Mt(t);
    if (r !== "filter" && r in e)
        return ai[t] = r;
    r = Ro(r);
    for (let s = 0; s < Ll.length; s++) {
        const o = Ll[s] + r;
        if (o in e)
            return ai[t] = o
    }
    return t
}
const Nl = "http://www.w3.org/1999/xlink";
function Sg(e, t, n, r, s) {
    if (r && t.startsWith("xlink:"))
        n == null ? e.removeAttributeNS(Nl, t.slice(6, t.length)) : e.setAttributeNS(Nl, t, n);
    else {
        const o = Ap(t);
        n == null || o && !pf(n) ? e.removeAttribute(t) : e.setAttribute(t, o ? "" : n)
    }
}
function kg(e, t, n, r, s, o, i) {
    if (t === "innerHTML" || t === "textContent") {
        r && i(r, s, o),
        e[t] = n ?? "";
        return
    }
    const a = e.tagName;
    if (t === "value" && a !== "PROGRESS" && !a.includes("-")) {
        const u = a === "OPTION" ? e.getAttribute("value") || "" : e.value
          , c = n ?? "";
        (u !== c || !("_value"in e)) && (e.value = c),
        n == null && e.removeAttribute(t),
        e._value = n;
        return
    }
    let l = !1;
    if (n === "" || n == null) {
        const u = typeof e[t];
        u === "boolean" ? n = pf(n) : n == null && u === "string" ? (n = "",
        l = !0) : u === "number" && (n = 0,
        l = !0)
    }
    try {
        e[t] = n
    } catch {}
    l && e.removeAttribute(t)
}
function Bn(e, t, n, r) {
    e.addEventListener(t, n, r)
}
function Rg(e, t, n, r) {
    e.removeEventListener(t, n, r)
}
const Ml = Symbol("_vei");
function Ag(e, t, n, r, s=null) {
    const o = e[Ml] || (e[Ml] = {})
      , i = o[t];
    if (r && i)
        i.value = r;
    else {
        const [a,l] = Pg(t);
        if (r) {
            const u = o[t] = Lg(r, s);
            Bn(e, a, u, l)
        } else
            i && (Rg(e, a, i, l),
            o[t] = void 0)
    }
}
const Bl = /(?:Once|Passive|Capture)$/;
function Pg(e) {
    let t;
    if (Bl.test(e)) {
        t = {};
        let r;
        for (; r = e.match(Bl); )
            e = e.slice(0, e.length - r[0].length),
            t[r[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : Sn(e.slice(2)), t]
}
let ci = 0;
const Og = Promise.resolve()
  , Ig = ()=>ci || (Og.then(()=>ci = 0),
ci = Date.now());
function Lg(e, t) {
    const n = r=>{
        if (!r._vts)
            r._vts = Date.now();
        else if (r._vts <= n.attached)
            return;
        _t(Ng(r, n.value), t, 5, [r])
    }
    ;
    return n.value = e,
    n.attached = Ig(),
    n
}
function Ng(e, t) {
    if (K(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = ()=>{
            n.call(e),
            e._stopped = !0
        }
        ,
        t.map(r=>s=>!s._stopped && r && r(s))
    } else
        return t
}
const Dl = e=>e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123
  , Mg = (e,t,n,r,s,o,i,a,l)=>{
    const u = s === "svg";
    t === "class" ? Eg(e, r, u) : t === "style" ? Tg(e, n, r) : as(t) ? Ya(t) || Ag(e, t, n, r, i) : (t[0] === "." ? (t = t.slice(1),
    !0) : t[0] === "^" ? (t = t.slice(1),
    !1) : Bg(e, t, r, u)) ? kg(e, t, r, o, i, a, l) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r),
    Sg(e, t, r, u))
}
;
function Bg(e, t, n, r) {
    if (r)
        return !!(t === "innerHTML" || t === "textContent" || t in e && Dl(t) && Y(n));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
        return !1;
    if (t === "width" || t === "height") {
        const s = e.tagName;
        if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
            return !1
    }
    return Dl(t) && ye(n) ? !1 : t in e
}
const _d = new WeakMap
  , Sd = new WeakMap
  , lo = Symbol("_moveCb")
  , xl = Symbol("_enterCb")
  , kd = {
    name: "TransitionGroup",
    props: we({}, vg, {
        tag: String,
        moveClass: String
    }),
    setup(e, {slots: t}) {
        const n = Gt()
          , r = Kf();
        let s, o;
        return yc(()=>{
            if (!s.length)
                return;
            const i = e.moveClass || `${e.name || "v"}-move`;
            if (!jg(s[0].el, n.vnode.el, i))
                return;
            s.forEach(Fg),
            s.forEach(Hg);
            const a = s.filter($g);
            Ed(),
            a.forEach(l=>{
                const u = l.el
                  , c = u.style;
                Xt(u, i),
                c.transform = c.webkitTransform = c.transitionDuration = "";
                const f = u[lo] = d=>{
                    d && d.target !== u || (!d || /transform$/.test(d.propertyName)) && (u.removeEventListener("transitionend", f),
                    u[lo] = null,
                    fn(u, i))
                }
                ;
                u.addEventListener("transitionend", f)
            }
            )
        }
        ),
        ()=>{
            const i = ne(e)
              , a = bd(i);
            let l = i.tag || Te;
            s = o,
            o = t.default ? gc(t.default()) : [];
            for (let u = 0; u < o.length; u++) {
                const c = o[u];
                c.key != null && gr(c, Xr(c, a, r, n))
            }
            if (s)
                for (let u = 0; u < s.length; u++) {
                    const c = s[u];
                    gr(c, Xr(c, a, r, n)),
                    _d.set(c, c.el.getBoundingClientRect())
                }
            return ce(l, null, o)
        }
    }
}
  , Dg = e=>delete e.mode;
kd.props;
const xg = kd;
function Fg(e) {
    const t = e.el;
    t[lo] && t[lo](),
    t[xl] && t[xl]()
}
function Hg(e) {
    Sd.set(e, e.el.getBoundingClientRect())
}
function $g(e) {
    const t = _d.get(e)
      , n = Sd.get(e)
      , r = t.left - n.left
      , s = t.top - n.top;
    if (r || s) {
        const o = e.el.style;
        return o.transform = o.webkitTransform = `translate(${r}px,${s}px)`,
        o.transitionDuration = "0s",
        e
    }
}
function jg(e, t, n) {
    const r = e.cloneNode()
      , s = e[wr];
    s && s.forEach(a=>{
        a.split(/\s+/).forEach(l=>l && r.classList.remove(l))
    }
    ),
    n.split(/\s+/).forEach(a=>a && r.classList.add(a)),
    r.style.display = "none";
    const o = t.nodeType === 1 ? t : t.parentNode;
    o.appendChild(r);
    const {hasTransform: i} = wd(r);
    return o.removeChild(r),
    i
}
const uo = e=>{
    const t = e.props["onUpdate:modelValue"] || !1;
    return K(t) ? n=>ar(t, n) : t
}
;
function Vg(e) {
    e.target.composing = !0
}
function Fl(e) {
    const t = e.target;
    t.composing && (t.composing = !1,
    t.dispatchEvent(new Event("input")))
}
const dr = Symbol("_assign")
  , s_ = {
    created(e, {modifiers: {lazy: t, trim: n, number: r}}, s) {
        e[dr] = uo(s);
        const o = r || s.props && s.props.type === "number";
        Bn(e, t ? "change" : "input", i=>{
            if (i.target.composing)
                return;
            let a = e.value;
            n && (a = a.trim()),
            o && (a = Yi(a)),
            e[dr](a)
        }
        ),
        n && Bn(e, "change", ()=>{
            e.value = e.value.trim()
        }
        ),
        t || (Bn(e, "compositionstart", Vg),
        Bn(e, "compositionend", Fl),
        Bn(e, "change", Fl))
    },
    mounted(e, {value: t}) {
        e.value = t ?? ""
    },
    beforeUpdate(e, {value: t, modifiers: {lazy: n, trim: r, number: s}}, o) {
        if (e[dr] = uo(o),
        e.composing)
            return;
        const i = s || e.type === "number" ? Yi(e.value) : e.value
          , a = t ?? "";
        i !== a && (document.activeElement === e && e.type !== "range" && (n || r && e.value.trim() === a) || (e.value = a))
    }
}
  , o_ = {
    deep: !0,
    created(e, t, n) {
        e[dr] = uo(n),
        Bn(e, "change", ()=>{
            const r = e._modelValue
              , s = Ug(e)
              , o = e.checked
              , i = e[dr];
            if (K(r)) {
                const a = mf(r, s)
                  , l = a !== -1;
                if (o && !l)
                    i(r.concat(s));
                else if (!o && l) {
                    const u = [...r];
                    u.splice(a, 1),
                    i(u)
                }
            } else if (So(r)) {
                const a = new Set(r);
                o ? a.add(s) : a.delete(s),
                i(a)
            } else
                i(Rd(e, o))
        }
        )
    },
    mounted: Hl,
    beforeUpdate(e, t, n) {
        e[dr] = uo(n),
        Hl(e, t, n)
    }
};
function Hl(e, {value: t, oldValue: n}, r) {
    e._modelValue = t,
    K(t) ? e.checked = mf(t, r.props.value) > -1 : So(t) ? e.checked = t.has(r.props.value) : t !== n && (e.checked = Ao(t, Rd(e, !0)))
}
function Ug(e) {
    return "_value"in e ? e._value : e.value
}
function Rd(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const qg = ["ctrl", "shift", "alt", "meta"]
  , Wg = {
    stop: e=>e.stopPropagation(),
    prevent: e=>e.preventDefault(),
    self: e=>e.target !== e.currentTarget,
    ctrl: e=>!e.ctrlKey,
    shift: e=>!e.shiftKey,
    alt: e=>!e.altKey,
    meta: e=>!e.metaKey,
    left: e=>"button"in e && e.button !== 0,
    middle: e=>"button"in e && e.button !== 1,
    right: e=>"button"in e && e.button !== 2,
    exact: (e,t)=>qg.some(n=>e[`${n}Key`] && !t.includes(n))
}
  , Kg = (e,t)=>{
    const n = e._withMods || (e._withMods = {})
      , r = t.join(".");
    return n[r] || (n[r] = (s,...o)=>{
        for (let i = 0; i < t.length; i++) {
            const a = Wg[t[i]];
            if (a && a(s, t))
                return
        }
        return e(s, ...o)
    }
    )
}
  , zg = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , i_ = (e,t)=>{
    const n = e._withKeys || (e._withKeys = {})
      , r = t.join(".");
    return n[r] || (n[r] = s=>{
        if (!("key"in s))
            return;
        const o = Sn(s.key);
        if (t.some(i=>i === o || zg[i] === o))
            return e(s)
    }
    )
}
  , Ad = we({
    patchProp: Mg
}, yg);
let $r, $l = !1;
function Gg() {
    return $r || ($r = tg(Ad))
}
function Jg() {
    return $r = $l ? $r : ng(Ad),
    $l = !0,
    $r
}
const Pd = (...e)=>{
    const t = Gg().createApp(...e)
      , {mount: n} = t;
    return t.mount = r=>{
        const s = Id(r);
        if (!s)
            return;
        const o = t._component;
        !Y(o) && !o.render && !o.template && (o.template = s.innerHTML),
        s.innerHTML = "";
        const i = n(s, !1, Od(s));
        return s instanceof Element && (s.removeAttribute("v-cloak"),
        s.setAttribute("data-v-app", "")),
        i
    }
    ,
    t
}
  , Xg = (...e)=>{
    const t = Jg().createApp(...e)
      , {mount: n} = t;
    return t.mount = r=>{
        const s = Id(r);
        if (s)
            return n(s, !0, Od(s))
    }
    ,
    t
}
;
function Od(e) {
    if (e instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement)
        return "mathml"
}
function Id(e) {
    return ye(e) ? document.querySelector(e) : e
}
const Yg = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
  , Qg = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
  , Zg = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function ey(e, t) {
    if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype"in t) {
        ty(e);
        return
    }
    return t
}
function ty(e) {
    console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}
function Yr(e, t={}) {
    if (typeof e != "string")
        return e;
    const n = e.trim();
    if (e[0] === '"' && e.endsWith('"') && !e.includes("\\"))
        return n.slice(1, -1);
    if (n.length <= 9) {
        const r = n.toLowerCase();
        if (r === "true")
            return !0;
        if (r === "false")
            return !1;
        if (r === "undefined")
            return;
        if (r === "null")
            return null;
        if (r === "nan")
            return Number.NaN;
        if (r === "infinity")
            return Number.POSITIVE_INFINITY;
        if (r === "-infinity")
            return Number.NEGATIVE_INFINITY
    }
    if (!Zg.test(e)) {
        if (t.strict)
            throw new SyntaxError("[destr] Invalid JSON");
        return e
    }
    try {
        if (Yg.test(e) || Qg.test(e)) {
            if (t.strict)
                throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(e, ey)
        }
        return JSON.parse(e)
    } catch (r) {
        if (t.strict)
            throw r;
        return e
    }
}
const ny = /#/g
  , ry = /&/g
  , sy = /\//g
  , oy = /=/g
  , Sc = /\+/g
  , iy = /%5e/gi
  , ay = /%60/gi
  , cy = /%7c/gi
  , ly = /%20/gi;
function uy(e) {
    return encodeURI("" + e).replace(cy, "|")
}
function ma(e) {
    return uy(typeof e == "string" ? e : JSON.stringify(e)).replace(Sc, "%2B").replace(ly, "+").replace(ny, "%23").replace(ry, "%26").replace(ay, "`").replace(iy, "^").replace(sy, "%2F")
}
function li(e) {
    return ma(e).replace(oy, "%3D")
}
function fo(e="") {
    try {
        return decodeURIComponent("" + e)
    } catch {
        return "" + e
    }
}
function fy(e) {
    return fo(e.replace(Sc, " "))
}
function dy(e) {
    return fo(e.replace(Sc, " "))
}
function hy(e="") {
    const t = {};
    e[0] === "?" && (e = e.slice(1));
    for (const n of e.split("&")) {
        const r = n.match(/([^=]+)=?(.*)/) || [];
        if (r.length < 2)
            continue;
        const s = fy(r[1]);
        if (s === "__proto__" || s === "constructor")
            continue;
        const o = dy(r[2] || "");
        t[s] === void 0 ? t[s] = o : Array.isArray(t[s]) ? t[s].push(o) : t[s] = [t[s], o]
    }
    return t
}
function py(e, t) {
    return (typeof t == "number" || typeof t == "boolean") && (t = String(t)),
    t ? Array.isArray(t) ? t.map(n=>`${li(e)}=${ma(n)}`).join("&") : `${li(e)}=${ma(t)}` : li(e)
}
function my(e) {
    return Object.keys(e).filter(t=>e[t] !== void 0).map(t=>py(t, e[t])).filter(Boolean).join("&")
}
const gy = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/
  , yy = /^[\s\w\0+.-]{2,}:([/\\]{2})?/
  , vy = /^([/\\]\s*){2,}[^/\\]/
  , by = /^[\s\0]*(blob|data|javascript|vbscript):$/i
  , wy = /\/$|\/\?|\/#/
  , Ey = /^\.?\//;
function zn(e, t={}) {
    return typeof t == "boolean" && (t = {
        acceptRelative: t
    }),
    t.strict ? gy.test(e) : yy.test(e) || (t.acceptRelative ? vy.test(e) : !1)
}
function Cy(e) {
    return !!e && by.test(e)
}
function ga(e="", t) {
    return t ? wy.test(e) : e.endsWith("/")
}
function kc(e="", t) {
    if (!t)
        return (ga(e) ? e.slice(0, -1) : e) || "/";
    if (!ga(e, !0))
        return e || "/";
    let n = e
      , r = "";
    const s = e.indexOf("#");
    s >= 0 && (n = e.slice(0, s),
    r = e.slice(s));
    const [o,...i] = n.split("?");
    return ((o.endsWith("/") ? o.slice(0, -1) : o) || "/") + (i.length > 0 ? `?${i.join("?")}` : "") + r
}
function ya(e="", t) {
    if (!t)
        return e.endsWith("/") ? e : e + "/";
    if (ga(e, !0))
        return e || "/";
    let n = e
      , r = "";
    const s = e.indexOf("#");
    if (s >= 0 && (n = e.slice(0, s),
    r = e.slice(s),
    !n))
        return r;
    const [o,...i] = n.split("?");
    return o + "/" + (i.length > 0 ? `?${i.join("?")}` : "") + r
}
function Ty(e="") {
    return e.startsWith("/")
}
function jl(e="") {
    return Ty(e) ? e : "/" + e
}
function _y(e, t) {
    if (Nd(t) || zn(e))
        return e;
    const n = kc(t);
    return e.startsWith(n) ? e : Rc(n, e)
}
function Vl(e, t) {
    if (Nd(t))
        return e;
    const n = kc(t);
    if (!e.startsWith(n))
        return e;
    const r = e.slice(n.length);
    return r[0] === "/" ? r : "/" + r
}
function Ld(e, t) {
    const n = $o(e)
      , r = {
        ...hy(n.search),
        ...t
    };
    return n.search = my(r),
    Ry(n)
}
function Nd(e) {
    return !e || e === "/"
}
function Sy(e) {
    return e && e !== "/"
}
function Rc(e, ...t) {
    let n = e || "";
    for (const r of t.filter(s=>Sy(s)))
        if (n) {
            const s = r.replace(Ey, "");
            n = ya(n) + s
        } else
            n = r;
    return n
}
function Md(...e) {
    var i, a, l, u;
    const t = /\/(?!\/)/
      , n = e.filter(Boolean)
      , r = [];
    let s = 0;
    for (const c of n)
        if (!(!c || c === "/")) {
            for (const [f,d] of c.split(t).entries())
                if (!(!d || d === ".")) {
                    if (d === "..") {
                        if (r.length === 1 && zn(r[0]))
                            continue;
                        r.pop(),
                        s--;
                        continue
                    }
                    if (f === 1 && ((i = r[r.length - 1]) != null && i.endsWith(":/"))) {
                        r[r.length - 1] += "/" + d;
                        continue
                    }
                    r.push(d),
                    s++
                }
        }
    let o = r.join("/");
    return s >= 0 ? (a = n[0]) != null && a.startsWith("/") && !o.startsWith("/") ? o = "/" + o : (l = n[0]) != null && l.startsWith("./") && !o.startsWith("./") && (o = "./" + o) : o = "../".repeat(-1 * s) + o,
    (u = n[n.length - 1]) != null && u.endsWith("/") && !o.endsWith("/") && (o += "/"),
    o
}
function ky(e, t, n={}) {
    return n.trailingSlash || (e = ya(e),
    t = ya(t)),
    n.leadingSlash || (e = jl(e),
    t = jl(t)),
    n.encoding || (e = fo(e),
    t = fo(t)),
    e === t
}
const Bd = Symbol.for("ufo:protocolRelative");
function $o(e="", t) {
    const n = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
    if (n) {
        const [,f,d=""] = n;
        return {
            protocol: f.toLowerCase(),
            pathname: d,
            href: f + d,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!zn(e, {
        acceptRelative: !0
    }))
        return t ? $o(t + e) : Ul(e);
    const [,r="",s,o=""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []
      , [,i="",a=""] = o.match(/([^#/?]*)(.*)?/) || []
      , {pathname: l, search: u, hash: c} = Ul(a.replace(/\/(?=[A-Za-z]:)/, ""));
    return {
        protocol: r.toLowerCase(),
        auth: s ? s.slice(0, Math.max(0, s.length - 1)) : "",
        host: i,
        pathname: l,
        search: u,
        hash: c,
        [Bd]: !r
    }
}
function Ul(e="") {
    const [t="",n="",r=""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: t,
        search: n,
        hash: r
    }
}
function Ry(e) {
    const t = e.pathname || ""
      , n = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : ""
      , r = e.hash || ""
      , s = e.auth ? e.auth + "@" : ""
      , o = e.host || "";
    return (e.protocol || e[Bd] ? (e.protocol || "") + "//" : "") + s + o + t + n + r
}
class Ay extends Error {
    constructor(t, n) {
        super(t, n),
        this.name = "FetchError",
        n != null && n.cause && !this.cause && (this.cause = n.cause)
    }
}
function Py(e) {
    var l, u, c, f, d;
    const t = ((l = e.error) == null ? void 0 : l.message) || ((u = e.error) == null ? void 0 : u.toString()) || ""
      , n = ((c = e.request) == null ? void 0 : c.method) || ((f = e.options) == null ? void 0 : f.method) || "GET"
      , r = ((d = e.request) == null ? void 0 : d.url) || String(e.request) || "/"
      , s = `[${n}] ${JSON.stringify(r)}`
      , o = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>"
      , i = `${s}: ${o}${t ? ` ${t}` : ""}`
      , a = new Ay(i,e.error ? {
        cause: e.error
    } : void 0);
    for (const h of ["request", "options", "response"])
        Object.defineProperty(a, h, {
            get() {
                return e[h]
            }
        });
    for (const [h,m] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]])
        Object.defineProperty(a, h, {
            get() {
                return e.response && e.response[m]
            }
        });
    return a
}
const Oy = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function ql(e="GET") {
    return Oy.has(e.toUpperCase())
}
function Iy(e) {
    if (e === void 0)
        return !1;
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function"
}
const Ly = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"])
  , Ny = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function My(e="") {
    if (!e)
        return "json";
    const t = e.split(";").shift() || "";
    return Ny.test(t) ? "json" : Ly.has(t) || t.startsWith("text/") ? "text" : "blob"
}
function By(e, t, n=globalThis.Headers) {
    const r = {
        ...t,
        ...e
    };
    if (t != null && t.params && (e != null && e.params) && (r.params = {
        ...t == null ? void 0 : t.params,
        ...e == null ? void 0 : e.params
    }),
    t != null && t.query && (e != null && e.query) && (r.query = {
        ...t == null ? void 0 : t.query,
        ...e == null ? void 0 : e.query
    }),
    t != null && t.headers && (e != null && e.headers)) {
        r.headers = new n((t == null ? void 0 : t.headers) || {});
        for (const [s,o] of new n((e == null ? void 0 : e.headers) || {}))
            r.headers.set(s, o)
    }
    return r
}
const Dy = new Set([408, 409, 425, 429, 500, 502, 503, 504])
  , xy = new Set([101, 204, 205, 304]);
function Dd(e={}) {
    const {fetch: t=globalThis.fetch, Headers: n=globalThis.Headers, AbortController: r=globalThis.AbortController} = e;
    async function s(a) {
        const l = a.error && a.error.name === "AbortError" && !a.options.timeout || !1;
        if (a.options.retry !== !1 && !l) {
            let c;
            typeof a.options.retry == "number" ? c = a.options.retry : c = ql(a.options.method) ? 0 : 1;
            const f = a.response && a.response.status || 500;
            if (c > 0 && (Array.isArray(a.options.retryStatusCodes) ? a.options.retryStatusCodes.includes(f) : Dy.has(f))) {
                const d = a.options.retryDelay || 0;
                return d > 0 && await new Promise(h=>setTimeout(h, d)),
                o(a.request, {
                    ...a.options,
                    retry: c - 1
                })
            }
        }
        const u = Py(a);
        throw Error.captureStackTrace && Error.captureStackTrace(u, o),
        u
    }
    const o = async function(l, u={}) {
        var h;
        const c = {
            request: l,
            options: By(u, e.defaults, n),
            response: void 0,
            error: void 0
        };
        c.options.method = (h = c.options.method) == null ? void 0 : h.toUpperCase(),
        c.options.onRequest && await c.options.onRequest(c),
        typeof c.request == "string" && (c.options.baseURL && (c.request = _y(c.request, c.options.baseURL)),
        (c.options.query || c.options.params) && (c.request = Ld(c.request, {
            ...c.options.params,
            ...c.options.query
        }))),
        c.options.body && ql(c.options.method) && (Iy(c.options.body) ? (c.options.body = typeof c.options.body == "string" ? c.options.body : JSON.stringify(c.options.body),
        c.options.headers = new n(c.options.headers || {}),
        c.options.headers.has("content-type") || c.options.headers.set("content-type", "application/json"),
        c.options.headers.has("accept") || c.options.headers.set("accept", "application/json")) : ("pipeTo"in c.options.body && typeof c.options.body.pipeTo == "function" || typeof c.options.body.pipe == "function") && ("duplex"in c.options || (c.options.duplex = "half")));
        let f;
        if (!c.options.signal && c.options.timeout) {
            const m = new r;
            f = setTimeout(()=>m.abort(), c.options.timeout),
            c.options.signal = m.signal
        }
        try {
            c.response = await t(c.request, c.options)
        } catch (m) {
            return c.error = m,
            c.options.onRequestError && await c.options.onRequestError(c),
            await s(c)
        } finally {
            f && clearTimeout(f)
        }
        if (c.response.body && !xy.has(c.response.status) && c.options.method !== "HEAD") {
            const m = (c.options.parseResponse ? "json" : c.options.responseType) || My(c.response.headers.get("content-type") || "");
            switch (m) {
            case "json":
                {
                    const v = await c.response.text()
                      , T = c.options.parseResponse || Yr;
                    c.response._data = T(v);
                    break
                }
            case "stream":
                {
                    c.response._data = c.response.body;
                    break
                }
            default:
                c.response._data = await c.response[m]()
            }
        }
        return c.options.onResponse && await c.options.onResponse(c),
        !c.options.ignoreResponseError && c.response.status >= 400 && c.response.status < 600 ? (c.options.onResponseError && await c.options.onResponseError(c),
        await s(c)) : c.response
    }
      , i = async function(l, u) {
        return (await o(l, u))._data
    };
    return i.raw = o,
    i.native = (...a)=>t(...a),
    i.create = (a={})=>Dd({
        ...e,
        defaults: {
            ...e.defaults,
            ...a
        }
    }),
    i
}
const Ac = function() {
    if (typeof globalThis < "u")
        return globalThis;
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("unable to locate global object")
}()
  , Fy = Ac.fetch || (()=>Promise.reject(new Error("[ofetch] global.fetch is not supported!")))
  , Hy = Ac.Headers
  , $y = Ac.AbortController
  , jy = Dd({
    fetch: Fy,
    Headers: Hy,
    AbortController: $y
})
  , Vy = jy
  , Uy = ()=>{
    var e;
    return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {}
}
  , ho = Uy().app
  , qy = ()=>ho.baseURL
  , Wy = ()=>ho.buildAssetsDir
  , Pc = (...e)=>Md(xd(), Wy(), ...e)
  , xd = (...e)=>{
    const t = ho.cdnURL || ho.baseURL;
    return e.length ? Md(t, ...e) : t
}
;
globalThis.__buildAssetsURL = Pc,
globalThis.__publicAssetsURL = xd;
globalThis.$fetch || (globalThis.$fetch = Vy.create({
    baseURL: qy()
}));
function va(e, t={}, n) {
    for (const r in e) {
        const s = e[r]
          , o = n ? `${n}:${r}` : r;
        typeof s == "object" && s !== null ? va(s, t, o) : typeof s == "function" && (t[o] = s)
    }
    return t
}
const Ky = {
    run: e=>e()
}
  , zy = ()=>Ky
  , Fd = typeof console.createTask < "u" ? console.createTask : zy;
function Gy(e, t) {
    const n = t.shift()
      , r = Fd(n);
    return e.reduce((s,o)=>s.then(()=>r.run(()=>o(...t))), Promise.resolve())
}
function Jy(e, t) {
    const n = t.shift()
      , r = Fd(n);
    return Promise.all(e.map(s=>r.run(()=>s(...t))))
}
function ui(e, t) {
    for (const n of [...e])
        n(t)
}
class Xy {
    constructor() {
        this._hooks = {},
        this._before = void 0,
        this._after = void 0,
        this._deprecatedMessages = void 0,
        this._deprecatedHooks = {},
        this.hook = this.hook.bind(this),
        this.callHook = this.callHook.bind(this),
        this.callHookWith = this.callHookWith.bind(this)
    }
    hook(t, n, r={}) {
        if (!t || typeof n != "function")
            return ()=>{}
            ;
        const s = t;
        let o;
        for (; this._deprecatedHooks[t]; )
            o = this._deprecatedHooks[t],
            t = o.to;
        if (o && !r.allowDeprecated) {
            let i = o.message;
            i || (i = `${s} hook has been deprecated` + (o.to ? `, please use ${o.to}` : "")),
            this._deprecatedMessages || (this._deprecatedMessages = new Set),
            this._deprecatedMessages.has(i) || (console.warn(i),
            this._deprecatedMessages.add(i))
        }
        if (!n.name)
            try {
                Object.defineProperty(n, "name", {
                    get: ()=>"_" + t.replace(/\W+/g, "_") + "_hook_cb",
                    configurable: !0
                })
            } catch {}
        return this._hooks[t] = this._hooks[t] || [],
        this._hooks[t].push(n),
        ()=>{
            n && (this.removeHook(t, n),
            n = void 0)
        }
    }
    hookOnce(t, n) {
        let r, s = (...o)=>(typeof r == "function" && r(),
        r = void 0,
        s = void 0,
        n(...o));
        return r = this.hook(t, s),
        r
    }
    removeHook(t, n) {
        if (this._hooks[t]) {
            const r = this._hooks[t].indexOf(n);
            r !== -1 && this._hooks[t].splice(r, 1),
            this._hooks[t].length === 0 && delete this._hooks[t]
        }
    }
    deprecateHook(t, n) {
        this._deprecatedHooks[t] = typeof n == "string" ? {
            to: n
        } : n;
        const r = this._hooks[t] || [];
        delete this._hooks[t];
        for (const s of r)
            this.hook(t, s)
    }
    deprecateHooks(t) {
        Object.assign(this._deprecatedHooks, t);
        for (const n in t)
            this.deprecateHook(n, t[n])
    }
    addHooks(t) {
        const n = va(t)
          , r = Object.keys(n).map(s=>this.hook(s, n[s]));
        return ()=>{
            for (const s of r.splice(0, r.length))
                s()
        }
    }
    removeHooks(t) {
        const n = va(t);
        for (const r in n)
            this.removeHook(r, n[r])
    }
    removeAllHooks() {
        for (const t in this._hooks)
            delete this._hooks[t]
    }
    callHook(t, ...n) {
        return n.unshift(t),
        this.callHookWith(Gy, t, ...n)
    }
    callHookParallel(t, ...n) {
        return n.unshift(t),
        this.callHookWith(Jy, t, ...n)
    }
    callHookWith(t, n, ...r) {
        const s = this._before || this._after ? {
            name: n,
            args: r,
            context: {}
        } : void 0;
        this._before && ui(this._before, s);
        const o = t(n in this._hooks ? [...this._hooks[n]] : [], r);
        return o instanceof Promise ? o.finally(()=>{
            this._after && s && ui(this._after, s)
        }
        ) : (this._after && s && ui(this._after, s),
        o)
    }
    beforeEach(t) {
        return this._before = this._before || [],
        this._before.push(t),
        ()=>{
            if (this._before !== void 0) {
                const n = this._before.indexOf(t);
                n !== -1 && this._before.splice(n, 1)
            }
        }
    }
    afterEach(t) {
        return this._after = this._after || [],
        this._after.push(t),
        ()=>{
            if (this._after !== void 0) {
                const n = this._after.indexOf(t);
                n !== -1 && this._after.splice(n, 1)
            }
        }
    }
}
function Hd() {
    return new Xy
}
function Yy(e={}) {
    let t, n = !1;
    const r = i=>{
        if (t && t !== i)
            throw new Error("Context conflict")
    }
    ;
    let s;
    if (e.asyncContext) {
        const i = e.AsyncLocalStorage || globalThis.AsyncLocalStorage;
        i ? s = new i : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
    }
    const o = ()=>{
        if (s && t === void 0) {
            const i = s.getStore();
            if (i !== void 0)
                return i
        }
        return t
    }
    ;
    return {
        use: ()=>{
            const i = o();
            if (i === void 0)
                throw new Error("Context is not available");
            return i
        }
        ,
        tryUse: ()=>o(),
        set: (i,a)=>{
            a || r(i),
            t = i,
            n = !0
        }
        ,
        unset: ()=>{
            t = void 0,
            n = !1
        }
        ,
        call: (i,a)=>{
            r(i),
            t = i;
            try {
                return s ? s.run(i, a) : a()
            } finally {
                n || (t = void 0)
            }
        }
        ,
        async callAsync(i, a) {
            t = i;
            const l = ()=>{
                t = i
            }
              , u = ()=>t === i ? l : void 0;
            ba.add(u);
            try {
                const c = s ? s.run(i, a) : a();
                return n || (t = void 0),
                await c
            } finally {
                ba.delete(u)
            }
        }
    }
}
function Qy(e={}) {
    const t = {};
    return {
        get(n, r={}) {
            return t[n] || (t[n] = Yy({
                ...e,
                ...r
            })),
            t[n],
            t[n]
        }
    }
}
const po = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}
  , Wl = "__unctx__"
  , Zy = po[Wl] || (po[Wl] = Qy())
  , ev = (e,t={})=>Zy.get(e, t)
  , Kl = "__unctx_async_handlers__"
  , ba = po[Kl] || (po[Kl] = new Set);
function Qr(e) {
    const t = [];
    for (const s of ba) {
        const o = s();
        o && t.push(o)
    }
    const n = ()=>{
        for (const s of t)
            s()
    }
    ;
    let r = e();
    return r && typeof r == "object" && "catch"in r && (r = r.catch(s=>{
        throw n(),
        s
    }
    )),
    [r, n]
}
const $d = ev("nuxt-app", {
    asyncContext: !1
})
  , tv = "__nuxt_plugin";
function nv(e) {
    let t = 0;
    const n = {
        _scope: tc(),
        provide: void 0,
        globalName: "nuxt",
        versions: {
            get nuxt() {
                return "3.11.2"
            },
            get vue() {
                return n.vueApp.version
            }
        },
        payload: nn({
            data: {},
            state: {},
            once: new Set,
            _errors: {},
            ...window.__NUXT__ ?? {}
        }),
        static: {
            data: {}
        },
        runWithContext: s=>n._scope.run(()=>ov(n, s)),
        isHydrating: !0,
        deferHydration() {
            if (!n.isHydrating)
                return ()=>{}
                ;
            t++;
            let s = !1;
            return ()=>{
                if (!s && (s = !0,
                t--,
                t === 0))
                    return n.isHydrating = !1,
                    n.callHook("app:suspense:resolve")
            }
        },
        _asyncDataPromises: {},
        _asyncData: {},
        _payloadRevivers: {},
        ...e
    };
    n.hooks = Hd(),
    n.hook = n.hooks.hook,
    n.callHook = n.hooks.callHook,
    n.provide = (s,o)=>{
        const i = "$" + s;
        Ds(n, i, o),
        Ds(n.vueApp.config.globalProperties, i, o)
    }
    ,
    Ds(n.vueApp, "$nuxt", n),
    Ds(n.vueApp.config.globalProperties, "$nuxt", n);
    {
        window.addEventListener("nuxt.preloadError", o=>{
            n.callHook("app:chunkError", {
                error: o.payload
            })
        }
        ),
        window.useNuxtApp = window.useNuxtApp || ie;
        const s = n.hook("app:error", (...o)=>{
            console.error("[nuxt] error caught during app initialization", ...o)
        }
        );
        n.hook("app:mounted", s)
    }
    const r = n.payload.config;
    return n.provide("config", r),
    n
}
async function rv(e, t) {
    if (t.hooks && e.hooks.addHooks(t.hooks),
    typeof t == "function") {
        const {provide: n} = await e.runWithContext(()=>t(e)) || {};
        if (n && typeof n == "object")
            for (const r in n)
                e.provide(r, n[r])
    }
}
async function sv(e, t) {
    const n = []
      , r = []
      , s = []
      , o = [];
    let i = 0;
    async function a(l) {
        var c;
        const u = ((c = l.dependsOn) == null ? void 0 : c.filter(f=>t.some(d=>d._name === f) && !n.includes(f))) ?? [];
        if (u.length > 0)
            r.push([new Set(u), l]);
        else {
            const f = rv(e, l).then(async()=>{
                l._name && (n.push(l._name),
                await Promise.all(r.map(async([d,h])=>{
                    d.has(l._name) && (d.delete(l._name),
                    d.size === 0 && (i++,
                    await a(h)))
                }
                )))
            }
            );
            l.parallel ? s.push(f.catch(d=>o.push(d))) : await f
        }
    }
    for (const l of t)
        await a(l);
    if (await Promise.all(s),
    i)
        for (let l = 0; l < i; l++)
            await Promise.all(s);
    if (o.length)
        throw o[0]
}
function ke(e) {
    if (typeof e == "function")
        return e;
    const t = e._name || e.name;
    return delete e.name,
    Object.assign(e.setup || (()=>{}
    ), e, {
        [tv]: !0,
        _name: t
    })
}
function ov(e, t, n) {
    const r = ()=>n ? t(...n) : t();
    return $d.set(e),
    e.vueApp.runWithContext(r)
}
function iv() {
    var t;
    let e;
    return Ec() && (e = (t = Gt()) == null ? void 0 : t.appContext.app.$nuxt),
    e = e || $d.tryUse(),
    e || null
}
function ie() {
    const e = iv();
    if (!e)
        throw new Error("[nuxt] instance unavailable");
    return e
}
function kr(e) {
    return ie().$config
}
function Ds(e, t, n) {
    Object.defineProperty(e, t, {
        get: ()=>n
    })
}
const xs = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
function av(e, t) {
    if (typeof e != "string")
        throw new TypeError("argument str must be a string");
    const n = {}
      , s = (t || {}).decode || uv;
    let o = 0;
    for (; o < e.length; ) {
        const i = e.indexOf("=", o);
        if (i === -1)
            break;
        let a = e.indexOf(";", o);
        if (a === -1)
            a = e.length;
        else if (a < i) {
            o = e.lastIndexOf(";", i - 1) + 1;
            continue
        }
        const l = e.slice(o, i).trim();
        if (n[l] === void 0) {
            let u = e.slice(i + 1, a).trim();
            u.codePointAt(0) === 34 && (u = u.slice(1, -1)),
            n[l] = lv(u, s)
        }
        o = a + 1
    }
    return n
}
function zl(e, t, n) {
    const r = n || {}
      , s = r.encode || fv;
    if (typeof s != "function")
        throw new TypeError("option encode is invalid");
    if (!xs.test(e))
        throw new TypeError("argument name is invalid");
    const o = s(t);
    if (o && !xs.test(o))
        throw new TypeError("argument val is invalid");
    let i = e + "=" + o;
    if (r.maxAge !== void 0 && r.maxAge !== null) {
        const a = r.maxAge - 0;
        if (Number.isNaN(a) || !Number.isFinite(a))
            throw new TypeError("option maxAge is invalid");
        i += "; Max-Age=" + Math.floor(a)
    }
    if (r.domain) {
        if (!xs.test(r.domain))
            throw new TypeError("option domain is invalid");
        i += "; Domain=" + r.domain
    }
    if (r.path) {
        if (!xs.test(r.path))
            throw new TypeError("option path is invalid");
        i += "; Path=" + r.path
    }
    if (r.expires) {
        if (!cv(r.expires) || Number.isNaN(r.expires.valueOf()))
            throw new TypeError("option expires is invalid");
        i += "; Expires=" + r.expires.toUTCString()
    }
    if (r.httpOnly && (i += "; HttpOnly"),
    r.secure && (i += "; Secure"),
    r.priority)
        switch (typeof r.priority == "string" ? r.priority.toLowerCase() : r.priority) {
        case "low":
            {
                i += "; Priority=Low";
                break
            }
        case "medium":
            {
                i += "; Priority=Medium";
                break
            }
        case "high":
            {
                i += "; Priority=High";
                break
            }
        default:
            throw new TypeError("option priority is invalid")
        }
    if (r.sameSite)
        switch (typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite) {
        case !0:
            {
                i += "; SameSite=Strict";
                break
            }
        case "lax":
            {
                i += "; SameSite=Lax";
                break
            }
        case "strict":
            {
                i += "; SameSite=Strict";
                break
            }
        case "none":
            {
                i += "; SameSite=None";
                break
            }
        default:
            throw new TypeError("option sameSite is invalid")
        }
    return r.partitioned && (i += "; Partitioned"),
    i
}
function cv(e) {
    return Object.prototype.toString.call(e) === "[object Date]" || e instanceof Date
}
function lv(e, t) {
    try {
        return t(e)
    } catch {
        return e
    }
}
function uv(e) {
    return e.includes("%") ? decodeURIComponent(e) : e
}
function fv(e) {
    return encodeURIComponent(e)
}
const Gl = Object.freeze({
    ignoreUnknown: !1,
    respectType: !1,
    respectFunctionNames: !1,
    respectFunctionProperties: !1,
    unorderedObjects: !0,
    unorderedArrays: !1,
    unorderedSets: !1,
    excludeKeys: void 0,
    excludeValues: void 0,
    replacer: void 0
});
function Jl(e, t) {
    t ? t = {
        ...Gl,
        ...t
    } : t = Gl;
    const n = jd(t);
    return n.dispatch(e),
    n.toString()
}
const dv = Object.freeze(["prototype", "__proto__", "constructor"]);
function jd(e) {
    let t = ""
      , n = new Map;
    const r = s=>{
        t += s
    }
    ;
    return {
        toString() {
            return t
        },
        getContext() {
            return n
        },
        dispatch(s) {
            return e.replacer && (s = e.replacer(s)),
            this[s === null ? "null" : typeof s](s)
        },
        object(s) {
            if (s && typeof s.toJSON == "function")
                return this.object(s.toJSON());
            const o = Object.prototype.toString.call(s);
            let i = "";
            const a = o.length;
            a < 10 ? i = "unknown:[" + o + "]" : i = o.slice(8, a - 1),
            i = i.toLowerCase();
            let l = null;
            if ((l = n.get(s)) === void 0)
                n.set(s, n.size);
            else
                return this.dispatch("[CIRCULAR:" + l + "]");
            if (typeof Buffer < "u" && Buffer.isBuffer && Buffer.isBuffer(s))
                return r("buffer:"),
                r(s.toString("utf8"));
            if (i !== "object" && i !== "function" && i !== "asyncfunction")
                this[i] ? this[i](s) : e.ignoreUnknown || this.unkown(s, i);
            else {
                let u = Object.keys(s);
                e.unorderedObjects && (u = u.sort());
                let c = [];
                e.respectType !== !1 && !Xl(s) && (c = dv),
                e.excludeKeys && (u = u.filter(d=>!e.excludeKeys(d)),
                c = c.filter(d=>!e.excludeKeys(d))),
                r("object:" + (u.length + c.length) + ":");
                const f = d=>{
                    this.dispatch(d),
                    r(":"),
                    e.excludeValues || this.dispatch(s[d]),
                    r(",")
                }
                ;
                for (const d of u)
                    f(d);
                for (const d of c)
                    f(d)
            }
        },
        array(s, o) {
            if (o = o === void 0 ? e.unorderedArrays !== !1 : o,
            r("array:" + s.length + ":"),
            !o || s.length <= 1) {
                for (const l of s)
                    this.dispatch(l);
                return
            }
            const i = new Map
              , a = s.map(l=>{
                const u = jd(e);
                u.dispatch(l);
                for (const [c,f] of u.getContext())
                    i.set(c, f);
                return u.toString()
            }
            );
            return n = i,
            a.sort(),
            this.array(a, !1)
        },
        date(s) {
            return r("date:" + s.toJSON())
        },
        symbol(s) {
            return r("symbol:" + s.toString())
        },
        unkown(s, o) {
            if (r(o),
            !!s && (r(":"),
            s && typeof s.entries == "function"))
                return this.array(Array.from(s.entries()), !0)
        },
        error(s) {
            return r("error:" + s.toString())
        },
        boolean(s) {
            return r("bool:" + s)
        },
        string(s) {
            r("string:" + s.length + ":"),
            r(s)
        },
        function(s) {
            r("fn:"),
            Xl(s) ? this.dispatch("[native]") : this.dispatch(s.toString()),
            e.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(s.name)),
            e.respectFunctionProperties && this.object(s)
        },
        number(s) {
            return r("number:" + s)
        },
        xml(s) {
            return r("xml:" + s.toString())
        },
        null() {
            return r("Null")
        },
        undefined() {
            return r("Undefined")
        },
        regexp(s) {
            return r("regex:" + s.toString())
        },
        uint8array(s) {
            return r("uint8array:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        uint8clampedarray(s) {
            return r("uint8clampedarray:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        int8array(s) {
            return r("int8array:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        uint16array(s) {
            return r("uint16array:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        int16array(s) {
            return r("int16array:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        uint32array(s) {
            return r("uint32array:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        int32array(s) {
            return r("int32array:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        float32array(s) {
            return r("float32array:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        float64array(s) {
            return r("float64array:"),
            this.dispatch(Array.prototype.slice.call(s))
        },
        arraybuffer(s) {
            return r("arraybuffer:"),
            this.dispatch(new Uint8Array(s))
        },
        url(s) {
            return r("url:" + s.toString())
        },
        map(s) {
            r("map:");
            const o = [...s];
            return this.array(o, e.unorderedSets !== !1)
        },
        set(s) {
            r("set:");
            const o = [...s];
            return this.array(o, e.unorderedSets !== !1)
        },
        file(s) {
            return r("file:"),
            this.dispatch([s.name, s.size, s.type, s.lastModfied])
        },
        blob() {
            if (e.ignoreUnknown)
                return r("[blob]");
            throw new Error(`Hashing Blob objects is currently not supported
Use "options.replacer" or "options.ignoreUnknown"
`)
        },
        domwindow() {
            return r("domwindow")
        },
        bigint(s) {
            return r("bigint:" + s.toString())
        },
        process() {
            return r("process")
        },
        timer() {
            return r("timer")
        },
        pipe() {
            return r("pipe")
        },
        tcp() {
            return r("tcp")
        },
        udp() {
            return r("udp")
        },
        tty() {
            return r("tty")
        },
        statwatcher() {
            return r("statwatcher")
        },
        securecontext() {
            return r("securecontext")
        },
        connection() {
            return r("connection")
        },
        zlib() {
            return r("zlib")
        },
        context() {
            return r("context")
        },
        nodescript() {
            return r("nodescript")
        },
        httpparser() {
            return r("httpparser")
        },
        dataview() {
            return r("dataview")
        },
        signal() {
            return r("signal")
        },
        fsevent() {
            return r("fsevent")
        },
        tlswrap() {
            return r("tlswrap")
        }
    }
}
const Vd = "[native code] }"
  , hv = Vd.length;
function Xl(e) {
    return typeof e != "function" ? !1 : Function.prototype.toString.call(e).slice(-hv) === Vd
}
function pv(e, t, n={}) {
    return e === t || Jl(e, n) === Jl(t, n)
}
function mv(e, t) {
    return {
        ctx: {
            table: e
        },
        matchAll: n=>qd(n, e, t)
    }
}
function Ud(e) {
    const t = {};
    for (const n in e)
        t[n] = n === "dynamic" ? new Map(Object.entries(e[n]).map(([r,s])=>[r, Ud(s)])) : new Map(Object.entries(e[n]));
    return t
}
function gv(e) {
    return mv(Ud(e))
}
function qd(e, t, n) {
    n !== !0 && e.endsWith("/") && (e = e.slice(0, -1) || "/");
    const r = [];
    for (const [o,i] of Yl(t.wildcard))
        (e === o || e.startsWith(o + "/")) && r.push(i);
    for (const [o,i] of Yl(t.dynamic))
        if (e.startsWith(o + "/")) {
            const a = "/" + e.slice(o.length).split("/").splice(2).join("/");
            r.push(...qd(a, i))
        }
    const s = t.static.get(e);
    return s && r.push(s),
    r.filter(Boolean)
}
function Yl(e) {
    return [...e.entries()].sort((t,n)=>t[0].length - n[0].length)
}
function fi(e) {
    if (e === null || typeof e != "object")
        return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0
}
function wa(e, t, n=".", r) {
    if (!fi(t))
        return wa(e, {}, n, r);
    const s = Object.assign({}, t);
    for (const o in e) {
        if (o === "__proto__" || o === "constructor")
            continue;
        const i = e[o];
        i != null && (r && r(s, o, i, n) || (Array.isArray(i) && Array.isArray(s[o]) ? s[o] = [...i, ...s[o]] : fi(i) && fi(s[o]) ? s[o] = wa(i, s[o], (n ? `${n}.` : "") + o.toString(), r) : s[o] = i))
    }
    return s
}
function Wd(e) {
    return (...t)=>t.reduce((n,r)=>wa(n, r, "", e), {})
}
const Kd = Wd()
  , yv = Wd((e,t,n)=>{
    if (e[t] !== void 0 && typeof n == "function")
        return e[t] = n(e[t]),
        !0
}
);
function vv(e, t) {
    try {
        return t in e
    } catch {
        return !1
    }
}
var bv = Object.defineProperty
  , wv = (e,t,n)=>t in e ? bv(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n
  , Nn = (e,t,n)=>(wv(e, typeof t != "symbol" ? t + "" : t, n),
n);
class Ea extends Error {
    constructor(t, n={}) {
        super(t, n),
        Nn(this, "statusCode", 500),
        Nn(this, "fatal", !1),
        Nn(this, "unhandled", !1),
        Nn(this, "statusMessage"),
        Nn(this, "data"),
        Nn(this, "cause"),
        n.cause && !this.cause && (this.cause = n.cause)
    }
    toJSON() {
        const t = {
            message: this.message,
            statusCode: Ta(this.statusCode, 500)
        };
        return this.statusMessage && (t.statusMessage = zd(this.statusMessage)),
        this.data !== void 0 && (t.data = this.data),
        t
    }
}
Nn(Ea, "__h3_error__", !0);
function Ca(e) {
    if (typeof e == "string")
        return new Ea(e);
    if (Ev(e))
        return e;
    const t = new Ea(e.message ?? e.statusMessage ?? "",{
        cause: e.cause || e
    });
    if (vv(e, "stack"))
        try {
            Object.defineProperty(t, "stack", {
                get() {
                    return e.stack
                }
            })
        } catch {
            try {
                t.stack = e.stack
            } catch {}
        }
    if (e.data && (t.data = e.data),
    e.statusCode ? t.statusCode = Ta(e.statusCode, t.statusCode) : e.status && (t.statusCode = Ta(e.status, t.statusCode)),
    e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText),
    t.statusMessage) {
        const n = t.statusMessage;
        zd(t.statusMessage) !== n && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
    }
    return e.fatal !== void 0 && (t.fatal = e.fatal),
    e.unhandled !== void 0 && (t.unhandled = e.unhandled),
    t
}
function Ev(e) {
    var t;
    return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0
}
const Cv = /[^\u0009\u0020-\u007E]/g;
function zd(e="") {
    return e.replace(Cv, "")
}
function Ta(e, t=200) {
    return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)),
    e < 100 || e > 999) ? t : e
}
const Gd = Symbol("layout-meta")
  , gs = Symbol("route")
  , xt = ()=>{
    var e;
    return (e = ie()) == null ? void 0 : e.$router
}
  , Gn = ()=>Ec() ? Oe(gs, ie()._route) : ie()._route;
const Tv = ()=>{
    try {
        if (ie()._processingMiddleware)
            return !0
    } catch {
        return !1
    }
    return !1
}
  , Jd = (e,t)=>{
    e || (e = "/");
    const n = typeof e == "string" ? e : Ld(e.path || "/", e.query || {}) + (e.hash || "");
    if (t != null && t.open) {
        const {target: a="_blank", windowFeatures: l={}} = t.open
          , u = Object.entries(l).filter(([c,f])=>f !== void 0).map(([c,f])=>`${c.toLowerCase()}=${f}`).join(", ");
        return open(n, a, u),
        Promise.resolve()
    }
    const r = (t == null ? void 0 : t.external) || zn(n, {
        acceptRelative: !0
    });
    if (r) {
        if (!(t != null && t.external))
            throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
        const a = $o(n).protocol;
        if (a && Cy(a))
            throw new Error(`Cannot navigate to a URL with '${a}' protocol.`)
    }
    const s = Tv();
    if (!r && s)
        return e;
    const o = xt()
      , i = ie();
    return r ? (i._scope.stop(),
    t != null && t.replace ? location.replace(n) : location.href = n,
    s ? i.isHydrating ? new Promise(()=>{}
    ) : !1 : Promise.resolve()) : t != null && t.replace ? o.replace(e) : o.push(e)
}
  , Xd = "__nuxt_error"
  , jo = ()=>Df(ie().payload, "error")
  , rr = e=>{
    const t = Vo(e);
    try {
        const n = ie()
          , r = jo();
        n.hooks.callHook("app:error", t),
        r.value = r.value || t
    } catch {
        throw t
    }
    return t
}
  , _v = async(e={})=>{
    const t = ie()
      , n = jo();
    t.callHook("app:error:cleared", e),
    e.redirect && await xt().replace(e.redirect),
    n.value = null
}
  , Sv = e=>!!e && typeof e == "object" && Xd in e
  , Vo = e=>{
    const t = Ca(e);
    return Object.defineProperty(t, Xd, {
        value: !0,
        configurable: !1,
        writable: !1
    }),
    t
}
  , kv = "modulepreload"
  , Rv = function(e, t) {
    return e[0] === "." ? new URL(e,t).href : e
}
  , Ql = {}
  , Av = function(t, n, r) {
    let s = Promise.resolve();
    if (n && n.length > 0) {
        const o = document.getElementsByTagName("link")
          , i = document.querySelector("meta[property=csp-nonce]")
          , a = (i == null ? void 0 : i.nonce) || (i == null ? void 0 : i.getAttribute("nonce"));
        s = Promise.all(n.map(l=>{
            if (l = Rv(l, r),
            l in Ql)
                return;
            Ql[l] = !0;
            const u = l.endsWith(".css")
              , c = u ? '[rel="stylesheet"]' : "";
            if (!!r)
                for (let h = o.length - 1; h >= 0; h--) {
                    const m = o[h];
                    if (m.href === l && (!u || m.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${l}"]${c}`))
                return;
            const d = document.createElement("link");
            if (d.rel = u ? "stylesheet" : kv,
            u || (d.as = "script",
            d.crossOrigin = ""),
            d.href = l,
            a && d.setAttribute("nonce", a),
            document.head.appendChild(d),
            u)
                return new Promise((h,m)=>{
                    d.addEventListener("load", h),
                    d.addEventListener("error", ()=>m(new Error(`Unable to preload CSS for ${l}`)))
                }
                )
        }
        ))
    }
    return s.then(()=>t()).catch(o=>{
        const i = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (i.payload = o,
        window.dispatchEvent(i),
        !i.defaultPrevented)
            throw o
    }
    )
}
  , J = (...e)=>Av(...e).catch(t=>{
    const n = new Event("nuxt.preloadError");
    throw n.payload = t,
    window.dispatchEvent(n),
    t
}
)
  , Pv = -1
  , Ov = -2
  , Iv = -3
  , Lv = -4
  , Nv = -5
  , Mv = -6;
function Bv(e, t) {
    return Dv(JSON.parse(e), t)
}
function Dv(e, t) {
    if (typeof e == "number")
        return s(e, !0);
    if (!Array.isArray(e) || e.length === 0)
        throw new Error("Invalid input");
    const n = e
      , r = Array(n.length);
    function s(o, i=!1) {
        if (o === Pv)
            return;
        if (o === Iv)
            return NaN;
        if (o === Lv)
            return 1 / 0;
        if (o === Nv)
            return -1 / 0;
        if (o === Mv)
            return -0;
        if (i)
            throw new Error("Invalid input");
        if (o in r)
            return r[o];
        const a = n[o];
        if (!a || typeof a != "object")
            r[o] = a;
        else if (Array.isArray(a))
            if (typeof a[0] == "string") {
                const l = a[0]
                  , u = t == null ? void 0 : t[l];
                if (u)
                    return r[o] = u(s(a[1]));
                switch (l) {
                case "Date":
                    r[o] = new Date(a[1]);
                    break;
                case "Set":
                    const c = new Set;
                    r[o] = c;
                    for (let h = 1; h < a.length; h += 1)
                        c.add(s(a[h]));
                    break;
                case "Map":
                    const f = new Map;
                    r[o] = f;
                    for (let h = 1; h < a.length; h += 2)
                        f.set(s(a[h]), s(a[h + 1]));
                    break;
                case "RegExp":
                    r[o] = new RegExp(a[1],a[2]);
                    break;
                case "Object":
                    r[o] = Object(a[1]);
                    break;
                case "BigInt":
                    r[o] = BigInt(a[1]);
                    break;
                case "null":
                    const d = Object.create(null);
                    r[o] = d;
                    for (let h = 1; h < a.length; h += 2)
                        d[a[h]] = s(a[h + 1]);
                    break;
                default:
                    throw new Error(`Unknown type ${l}`)
                }
            } else {
                const l = new Array(a.length);
                r[o] = l;
                for (let u = 0; u < a.length; u += 1) {
                    const c = a[u];
                    c !== Ov && (l[u] = s(c))
                }
            }
        else {
            const l = {};
            r[o] = l;
            for (const u in a) {
                const c = a[u];
                l[u] = s(c)
            }
        }
        return r[o]
    }
    return s(0)
}
function xv(e) {
    return Array.isArray(e) ? e : [e]
}
const Fv = ["title", "titleTemplate", "script", "style", "noscript"]
  , Gs = ["base", "meta", "link", "style", "script", "noscript"]
  , Hv = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]
  , $v = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]
  , Yd = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"]
  , jv = typeof window < "u";
function Oc(e) {
    let t = 9;
    for (let n = 0; n < e.length; )
        t = Math.imul(t ^ e.charCodeAt(n++), 9 ** 9);
    return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}
function Zl(e) {
    return e._h || Oc(e._d ? e._d : `${e.tag}:${e.textContent || e.innerHTML || ""}:${Object.entries(e.props).map(([t,n])=>`${t}:${String(n)}`).join(",")}`)
}
function Qd(e, t) {
    const {props: n, tag: r} = e;
    if ($v.includes(r))
        return r;
    if (r === "link" && n.rel === "canonical")
        return "canonical";
    if (n.charset)
        return "charset";
    const s = ["id"];
    r === "meta" && s.push("name", "property", "http-equiv");
    for (const o of s)
        if (typeof n[o] < "u") {
            const i = String(n[o]);
            return t && !t(i) ? !1 : `${r}:${o}:${i}`
        }
    return !1
}
function eu(e, t) {
    return e == null ? t || null : typeof e == "function" ? e(t) : e
}
async function Vv(e, t, n) {
    const r = {
        tag: e,
        props: await Zd(typeof t == "object" && typeof t != "function" && !(t instanceof Promise) ? {
            ...t
        } : {
            [["script", "noscript", "style"].includes(e) ? "innerHTML" : "textContent"]: t
        }, ["templateParams", "titleTemplate"].includes(e))
    };
    return Yd.forEach(s=>{
        const o = typeof r.props[s] < "u" ? r.props[s] : n[s];
        typeof o < "u" && ((!["innerHTML", "textContent", "children"].includes(s) || Fv.includes(r.tag)) && (r[s === "children" ? "innerHTML" : s] = o),
        delete r.props[s])
    }
    ),
    r.props.body && (r.tagPosition = "bodyClose",
    delete r.props.body),
    r.tag === "script" && typeof r.innerHTML == "object" && (r.innerHTML = JSON.stringify(r.innerHTML),
    r.props.type = r.props.type || "application/json"),
    Array.isArray(r.props.content) ? r.props.content.map(s=>({
        ...r,
        props: {
            ...r.props,
            content: s
        }
    })) : r
}
function Uv(e, t) {
    var r;
    const n = e === "class" ? " " : ";";
    return typeof t == "object" && !Array.isArray(t) && (t = Object.entries(t).filter(([,s])=>s).map(([s,o])=>e === "style" ? `${s}:${o}` : s)),
    (r = Array.isArray(t) ? t.join(n) : t) == null ? void 0 : r.split(n).filter(s=>s.trim()).filter(Boolean).join(n)
}
async function Zd(e, t) {
    for (const n of Object.keys(e)) {
        if (["class", "style"].includes(n)) {
            e[n] = Uv(n, e[n]);
            continue
        }
        if (e[n]instanceof Promise && (e[n] = await e[n]),
        !t && !Yd.includes(n)) {
            const r = String(e[n])
              , s = n.startsWith("data-");
            r === "true" || r === "" ? e[n] = s ? "true" : !0 : e[n] || (s && r === "false" ? e[n] = "false" : delete e[n])
        }
    }
    return e
}
const qv = 10;
async function Wv(e) {
    const t = [];
    return Object.entries(e.resolvedInput).filter(([n,r])=>typeof r < "u" && Hv.includes(n)).forEach(([n,r])=>{
        const s = xv(r);
        t.push(...s.map(o=>Vv(n, o, e)).flat())
    }
    ),
    (await Promise.all(t)).flat().filter(Boolean).map((n,r)=>(n._e = e._i,
    e.mode && (n._m = e.mode),
    n._p = (e._i << qv) + r,
    n))
}
const tu = {
    base: -10,
    title: 10
}
  , nu = {
    critical: -80,
    high: -10,
    low: 20
};
function mo(e) {
    let t = 100;
    const n = e.tagPriority;
    return typeof n == "number" ? n : (e.tag === "meta" ? (e.props["http-equiv"] === "content-security-policy" && (t = -30),
    e.props.charset && (t = -20),
    e.props.name === "viewport" && (t = -15)) : e.tag === "link" && e.props.rel === "preconnect" ? t = 20 : e.tag in tu && (t = tu[e.tag]),
    typeof n == "string" && n in nu ? t + nu[n] : t)
}
const Kv = [{
    prefix: "before:",
    offset: -1
}, {
    prefix: "after:",
    offset: 1
}]
  , ru = ["onload", "onerror", "onabort", "onprogress", "onloadstart"]
  , un = "%separator";
function Js(e, t, n) {
    if (typeof e != "string" || !e.includes("%"))
        return e;
    function r(i) {
        let a;
        return ["s", "pageTitle"].includes(i) ? a = t.pageTitle : i.includes(".") ? a = i.split(".").reduce((l,u)=>l && l[u] || void 0, t) : a = t[i],
        typeof a < "u" ? (a || "").replace(/"/g, '\\"') : !1
    }
    let s = e;
    try {
        s = decodeURI(e)
    } catch {}
    return (s.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(i=>{
        const a = r(i.slice(1));
        typeof a == "string" && (e = e.replace(new RegExp(`\\${i}(\\W|$)`,"g"), (l,u)=>`${a}${u}`).trim())
    }
    ),
    e.includes(un) && (e.endsWith(un) && (e = e.slice(0, -un.length).trim()),
    e.startsWith(un) && (e = e.slice(un.length).trim()),
    e = e.replace(new RegExp(`\\${un}\\s*\\${un}`,"g"), un),
    e = Js(e, {
        separator: n
    }, n)),
    e
}
async function eh(e, t={}) {
    var c;
    const n = t.document || e.resolvedOptions.document;
    if (!n || !e.dirty)
        return;
    const r = {
        shouldRender: !0,
        tags: []
    };
    if (await e.hooks.callHook("dom:beforeRender", r),
    !r.shouldRender)
        return;
    const s = (await e.resolveTags()).map(f=>({
        tag: f,
        id: Gs.includes(f.tag) ? Zl(f) : f.tag,
        shouldRender: !0
    }));
    let o = e._dom;
    if (!o) {
        o = {
            elMap: {
                htmlAttrs: n.documentElement,
                bodyAttrs: n.body
            }
        };
        for (const f of ["body", "head"]) {
            const d = (c = n[f]) == null ? void 0 : c.children
              , h = [];
            for (const m of [...d].filter(v=>Gs.includes(v.tagName.toLowerCase()))) {
                const v = {
                    tag: m.tagName.toLowerCase(),
                    props: await Zd(m.getAttributeNames().reduce((b,y)=>({
                        ...b,
                        [y]: m.getAttribute(y)
                    }), {})),
                    innerHTML: m.innerHTML
                };
                let T = 1
                  , k = Qd(v);
                for (; k && h.find(b=>b._d === k); )
                    k = `${k}:${T++}`;
                v._d = k || void 0,
                h.push(v),
                o.elMap[m.getAttribute("data-hid") || Zl(v)] = m
            }
        }
    }
    o.pendingSideEffects = {
        ...o.sideEffects || {}
    },
    o.sideEffects = {};
    function i(f, d, h) {
        const m = `${f}:${d}`;
        o.sideEffects[m] = h,
        delete o.pendingSideEffects[m]
    }
    function a({id: f, $el: d, tag: h}) {
        const m = h.tag.endsWith("Attrs");
        o.elMap[f] = d,
        m || (["textContent", "innerHTML"].forEach(v=>{
            h[v] && h[v] !== d[v] && (d[v] = h[v])
        }
        ),
        i(f, "el", ()=>{
            var v;
            (v = o.elMap[f]) == null || v.remove(),
            delete o.elMap[f]
        }
        ));
        for (const [v,T] of Object.entries(h._eventHandlers || {}))
            d.getAttribute(`data-${v}`) !== "" && ((h.tag === "bodyAttrs" ? n.defaultView : d).addEventListener(v.replace("on", ""), T.bind(d)),
            d.setAttribute(`data-${v}`, ""));
        Object.entries(h.props).forEach(([v,T])=>{
            const k = `attr:${v}`;
            if (v === "class")
                for (const b of (T || "").split(" ").filter(Boolean))
                    m && i(f, `${k}:${b}`, ()=>d.classList.remove(b)),
                    !d.classList.contains(b) && d.classList.add(b);
            else if (v === "style")
                for (const b of (T || "").split(";").filter(Boolean)) {
                    const [y,...w] = b.split(":").map(E=>E.trim());
                    i(f, `${k}:${b}:${y}`, ()=>{
                        d.style.removeProperty(y)
                    }
                    ),
                    d.style.setProperty(y, w.join(":"))
                }
            else
                d.getAttribute(v) !== T && d.setAttribute(v, T === !0 ? "" : String(T)),
                m && i(f, k, ()=>d.removeAttribute(v))
        }
        )
    }
    const l = []
      , u = {
        bodyClose: void 0,
        bodyOpen: void 0,
        head: void 0
    };
    for (const f of s) {
        const {tag: d, shouldRender: h, id: m} = f;
        if (h) {
            if (d.tag === "title") {
                n.title = d.textContent;
                continue
            }
            f.$el = f.$el || o.elMap[m],
            f.$el ? a(f) : Gs.includes(d.tag) && l.push(f)
        }
    }
    for (const f of l) {
        const d = f.tag.tagPosition || "head";
        f.$el = n.createElement(f.tag.tag),
        a(f),
        u[d] = u[d] || n.createDocumentFragment(),
        u[d].appendChild(f.$el)
    }
    for (const f of s)
        await e.hooks.callHook("dom:renderTag", f, n, i);
    u.head && n.head.appendChild(u.head),
    u.bodyOpen && n.body.insertBefore(u.bodyOpen, n.body.firstChild),
    u.bodyClose && n.body.appendChild(u.bodyClose),
    Object.values(o.pendingSideEffects).forEach(f=>f()),
    e._dom = o,
    e.dirty = !1,
    await e.hooks.callHook("dom:rendered", {
        renders: s
    })
}
async function zv(e, t={}) {
    const n = t.delayFn || (r=>setTimeout(r, 10));
    return e._domUpdatePromise = e._domUpdatePromise || new Promise(r=>n(async()=>{
        await eh(e, t),
        delete e._domUpdatePromise,
        r()
    }
    ))
}
function Gv(e) {
    return t=>{
        var r, s;
        const n = ((s = (r = t.resolvedOptions.document) == null ? void 0 : r.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : s.innerHTML) || !1;
        return n && t.push(JSON.parse(n)),
        {
            mode: "client",
            hooks: {
                "entries:updated": function(o) {
                    zv(o, e)
                }
            }
        }
    }
}
const Jv = ["templateParams", "htmlAttrs", "bodyAttrs"]
  , Xv = {
    hooks: {
        "tag:normalise": function({tag: e}) {
            ["hid", "vmid", "key"].forEach(r=>{
                e.props[r] && (e.key = e.props[r],
                delete e.props[r])
            }
            );
            const n = Qd(e) || (e.key ? `${e.tag}:${e.key}` : !1);
            n && (e._d = n)
        },
        "tags:resolve": function(e) {
            const t = {};
            e.tags.forEach(r=>{
                const s = (r.key ? `${r.tag}:${r.key}` : r._d) || r._p
                  , o = t[s];
                if (o) {
                    let a = r == null ? void 0 : r.tagDuplicateStrategy;
                    if (!a && Jv.includes(r.tag) && (a = "merge"),
                    a === "merge") {
                        const l = o.props;
                        ["class", "style"].forEach(u=>{
                            l[u] && (r.props[u] ? (u === "style" && !l[u].endsWith(";") && (l[u] += ";"),
                            r.props[u] = `${l[u]} ${r.props[u]}`) : r.props[u] = l[u])
                        }
                        ),
                        t[s].props = {
                            ...l,
                            ...r.props
                        };
                        return
                    } else if (r._e === o._e) {
                        o._duped = o._duped || [],
                        r._d = `${o._d}:${o._duped.length + 1}`,
                        o._duped.push(r);
                        return
                    } else if (mo(r) > mo(o))
                        return
                }
                const i = Object.keys(r.props).length + (r.innerHTML ? 1 : 0) + (r.textContent ? 1 : 0);
                if (Gs.includes(r.tag) && i === 0) {
                    delete t[s];
                    return
                }
                t[s] = r
            }
            );
            const n = [];
            Object.values(t).forEach(r=>{
                const s = r._duped;
                delete r._duped,
                n.push(r),
                s && n.push(...s)
            }
            ),
            e.tags = n,
            e.tags = e.tags.filter(r=>!(r.tag === "meta" && (r.props.name || r.props.property) && !r.props.content))
        }
    }
}
  , Yv = {
    mode: "server",
    hooks: {
        "tags:resolve": function(e) {
            const t = {};
            e.tags.filter(n=>["titleTemplate", "templateParams", "title"].includes(n.tag) && n._m === "server").forEach(n=>{
                t[n.tag] = n.tag.startsWith("title") ? n.textContent : n.props
            }
            ),
            Object.keys(t).length && e.tags.push({
                tag: "script",
                innerHTML: JSON.stringify(t),
                props: {
                    id: "unhead:payload",
                    type: "application/json"
                }
            })
        }
    }
}
  , Qv = ["script", "link", "bodyAttrs"]
  , Zv = e=>({
    hooks: {
        "tags:resolve": function(t) {
            for (const n of t.tags.filter(r=>Qv.includes(r.tag)))
                Object.entries(n.props).forEach(([r,s])=>{
                    r.startsWith("on") && typeof s == "function" && (e.ssr && ru.includes(r) ? n.props[r] = `this.dataset.${r}fired = true` : delete n.props[r],
                    n._eventHandlers = n._eventHandlers || {},
                    n._eventHandlers[r] = s)
                }
                ),
                e.ssr && n._eventHandlers && (n.props.src || n.props.href) && (n.key = n.key || Oc(n.props.src || n.props.href))
        },
        "dom:renderTag": function({$el: t, tag: n}) {
            var r, s;
            for (const o of Object.keys((t == null ? void 0 : t.dataset) || {}).filter(i=>ru.some(a=>`${a}fired` === i))) {
                const i = o.replace("fired", "");
                (s = (r = n._eventHandlers) == null ? void 0 : r[i]) == null || s.call(t, new Event(i.replace("on", "")))
            }
        }
    }
})
  , eb = ["link", "style", "script", "noscript"]
  , tb = {
    hooks: {
        "tag:normalise": ({tag: e})=>{
            e.key && eb.includes(e.tag) && (e.props["data-hid"] = e._h = Oc(e.key))
        }
    }
}
  , nb = {
    hooks: {
        "tags:resolve": e=>{
            const t = n=>{
                var r;
                return (r = e.tags.find(s=>s._d === n)) == null ? void 0 : r._p
            }
            ;
            for (const {prefix: n, offset: r} of Kv)
                for (const s of e.tags.filter(o=>typeof o.tagPriority == "string" && o.tagPriority.startsWith(n))) {
                    const o = t(s.tagPriority.replace(n, ""));
                    typeof o < "u" && (s._p = o + r)
                }
            e.tags.sort((n,r)=>n._p - r._p).sort((n,r)=>mo(n) - mo(r))
        }
    }
}
  , rb = {
    meta: "content",
    link: "href",
    htmlAttrs: "lang"
}
  , sb = e=>({
    hooks: {
        "tags:resolve": t=>{
            var a;
            const {tags: n} = t
              , r = (a = n.find(l=>l.tag === "title")) == null ? void 0 : a.textContent
              , s = n.findIndex(l=>l.tag === "templateParams")
              , o = s !== -1 ? n[s].props : {}
              , i = o.separator || "|";
            delete o.separator,
            o.pageTitle = Js(o.pageTitle || r || "", o, i);
            for (const l of n.filter(u=>u.processTemplateParams !== !1)) {
                const u = rb[l.tag];
                u && typeof l.props[u] == "string" ? l.props[u] = Js(l.props[u], o, i) : (l.processTemplateParams === !0 || ["titleTemplate", "title"].includes(l.tag)) && ["innerHTML", "textContent"].forEach(c=>{
                    typeof l[c] == "string" && (l[c] = Js(l[c], o, i))
                }
                )
            }
            e._templateParams = o,
            e._separator = i,
            t.tags = n.filter(l=>l.tag !== "templateParams")
        }
    }
})
  , ob = {
    hooks: {
        "tags:resolve": e=>{
            const {tags: t} = e;
            let n = t.findIndex(s=>s.tag === "titleTemplate");
            const r = t.findIndex(s=>s.tag === "title");
            if (r !== -1 && n !== -1) {
                const s = eu(t[n].textContent, t[r].textContent);
                s !== null ? t[r].textContent = s || t[r].textContent : delete t[r]
            } else if (n !== -1) {
                const s = eu(t[n].textContent);
                s !== null && (t[n].textContent = s,
                t[n].tag = "title",
                n = -1)
            }
            n !== -1 && delete t[n],
            e.tags = t.filter(Boolean)
        }
    }
}
  , ib = {
    hooks: {
        "tags:afterResolve": function(e) {
            for (const t of e.tags)
                typeof t.innerHTML == "string" && (t.innerHTML && ["application/ld+json", "application/json"].includes(t.props.type) ? t.innerHTML = t.innerHTML.replace(/</g, "\\u003C") : t.innerHTML = t.innerHTML.replace(new RegExp(`</${t.tag}`,"g"), `<\\/${t.tag}`))
        }
    }
};
let th;
function ab(e={}) {
    const t = cb(e);
    return t.use(Gv()),
    th = t
}
function su(e, t) {
    return !e || e === "server" && t || e === "client" && !t
}
function cb(e={}) {
    const t = Hd();
    t.addHooks(e.hooks || {}),
    e.document = e.document || (jv ? document : void 0);
    const n = !e.document
      , r = ()=>{
        a.dirty = !0,
        t.callHook("entries:updated", a)
    }
    ;
    let s = 0
      , o = [];
    const i = []
      , a = {
        plugins: i,
        dirty: !1,
        resolvedOptions: e,
        hooks: t,
        headEntries() {
            return o
        },
        use(l) {
            const u = typeof l == "function" ? l(a) : l;
            (!u.key || !i.some(c=>c.key === u.key)) && (i.push(u),
            su(u.mode, n) && t.addHooks(u.hooks || {}))
        },
        push(l, u) {
            u == null || delete u.head;
            const c = {
                _i: s++,
                input: l,
                ...u
            };
            return su(c.mode, n) && (o.push(c),
            r()),
            {
                dispose() {
                    o = o.filter(f=>f._i !== c._i),
                    t.callHook("entries:updated", a),
                    r()
                },
                patch(f) {
                    o = o.map(d=>(d._i === c._i && (d.input = c.input = f),
                    d)),
                    r()
                }
            }
        },
        async resolveTags() {
            const l = {
                tags: [],
                entries: [...o]
            };
            await t.callHook("entries:resolve", l);
            for (const u of l.entries) {
                const c = u.resolvedInput || u.input;
                if (u.resolvedInput = await (u.transform ? u.transform(c) : c),
                u.resolvedInput)
                    for (const f of await Wv(u)) {
                        const d = {
                            tag: f,
                            entry: u,
                            resolvedOptions: a.resolvedOptions
                        };
                        await t.callHook("tag:normalise", d),
                        l.tags.push(d.tag)
                    }
            }
            return await t.callHook("tags:beforeResolve", l),
            await t.callHook("tags:resolve", l),
            await t.callHook("tags:afterResolve", l),
            l.tags
        },
        ssr: n
    };
    return [Xv, Yv, Zv, tb, nb, sb, ob, ib, ...(e == null ? void 0 : e.plugins) || []].forEach(l=>a.use(l)),
    a.hooks.callHook("init", a),
    a
}
function lb() {
    return th
}
const ub = yd.startsWith("3");
function fb(e) {
    return typeof e == "function" ? e() : he(e)
}
function _a(e, t="") {
    if (e instanceof Promise)
        return e;
    const n = fb(e);
    return !e || !n ? n : Array.isArray(n) ? n.map(r=>_a(r, t)) : typeof n == "object" ? Object.fromEntries(Object.entries(n).map(([r,s])=>r === "titleTemplate" || r.startsWith("on") ? [r, he(s)] : [r, _a(s, r)])) : n
}
const db = {
    hooks: {
        "entries:resolve": function(e) {
            for (const t of e.entries)
                t.resolvedInput = _a(t.input)
        }
    }
}
  , nh = "usehead";
function hb(e) {
    return {
        install(n) {
            ub && (n.config.globalProperties.$unhead = e,
            n.config.globalProperties.$head = e,
            n.provide(nh, e))
        }
    }.install
}
function pb(e={}) {
    e.domDelayFn = e.domDelayFn || (n=>Dt(()=>setTimeout(()=>n(), 0)));
    const t = ab(e);
    return t.use(db),
    t.install = hb(t),
    t
}
const Sa = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , ka = "__unhead_injection_handler__";
function mb(e) {
    Sa[ka] = e
}
function a_() {
    if (ka in Sa)
        return Sa[ka]();
    const e = Oe(nh);
    return e || lb()
}
function jt(e) {
    if (typeof e != "object")
        return e;
    var t, n, r = Object.prototype.toString.call(e);
    if (r === "[object Object]") {
        if (e.constructor !== Object && typeof e.constructor == "function") {
            n = new e.constructor;
            for (t in e)
                e.hasOwnProperty(t) && n[t] !== e[t] && (n[t] = jt(e[t]))
        } else {
            n = {};
            for (t in e)
                t === "__proto__" ? Object.defineProperty(n, t, {
                    value: jt(e[t]),
                    configurable: !0,
                    enumerable: !0,
                    writable: !0
                }) : n[t] = jt(e[t])
        }
        return n
    }
    if (r === "[object Array]") {
        for (t = e.length,
        n = Array(t); t--; )
            n[t] = jt(e[t]);
        return n
    }
    return r === "[object Set]" ? (n = new Set,
    e.forEach(function(s) {
        n.add(jt(s))
    }),
    n) : r === "[object Map]" ? (n = new Map,
    e.forEach(function(s, o) {
        n.set(jt(o), jt(s))
    }),
    n) : r === "[object Date]" ? new Date(+e) : r === "[object RegExp]" ? (n = new RegExp(e.source,e.flags),
    n.lastIndex = e.lastIndex,
    n) : r === "[object DataView]" ? new e.constructor(jt(e.buffer)) : r === "[object ArrayBuffer]" ? e.slice(0) : r.slice(-6) === "Array]" ? new e.constructor(e) : e
}
const gb = {
    nuxt: {
        buildId: "c58e4d0f-aba3-4434-b748-fa534382ac2a"
    }
}
  , yb = yv(gb);
function rh() {
    const e = ie();
    return e._appConfig || (e._appConfig = nn(yb)),
    e._appConfig
}
const vb = !1
  , Ra = !1
  , bb = !1
  , c_ = {
    componentName: "NuxtLink"
}
  , wb = "#__nuxt";
let Xs, sh;
function Eb() {
    var t;
    const e = (t = rh().nuxt) == null ? void 0 : t.buildId;
    return Xs = $fetch(Pc(`builds/meta/${e}.json`)),
    Xs.then(n=>{
        sh = gv(n.matcher)
    }
    ),
    Xs
}
function Uo() {
    return Xs || Eb()
}
async function Ic(e) {
    return await Uo(),
    Kd({}, ...sh.matchAll(e).reverse())
}
function ou(e, t={}) {
    const n = Tb(e, t)
      , r = ie()
      , s = r._payloadCache = r._payloadCache || {};
    return n in s || (s[n] = _b(e).then(o=>o ? oh(n).then(i=>i || (delete s[n],
    null)) : (s[n] = null,
    null))),
    s[n]
}
const Cb = "_payload.json";
function Tb(e, t={}) {
    var s;
    const n = new URL(e,"http://localhost");
    if (n.host !== "localhost" || zn(n.pathname, {
        acceptRelative: !0
    }))
        throw new Error("Payload URL must not include hostname: " + e);
    const r = t.hash || (t.fresh ? Date.now() : (s = rh().nuxt) == null ? void 0 : s.buildId);
    return Rc(kr().app.baseURL, n.pathname, Cb + (r ? `?${r}` : ""))
}
async function oh(e) {
    const t = fetch(e).then(n=>n.text().then(ih));
    try {
        return await t
    } catch (n) {
        console.warn("[nuxt] Cannot load payload ", e, n)
    }
    return null
}
async function _b(e=Gn().path) {
    if (e = kc(e),
    (await Uo()).prerendered.includes(e))
        return !0;
    const n = await Ic(e);
    return !!n.prerender && !n.redirect
}
let Fs = null;
async function Sb() {
    if (Fs)
        return Fs;
    const e = document.getElementById("__NUXT_DATA__");
    if (!e)
        return {};
    const t = await ih(e.textContent || "")
      , n = e.dataset.src ? await oh(e.dataset.src) : void 0;
    return Fs = {
        ...t,
        ...n,
        ...window.__NUXT__
    },
    Fs
}
async function ih(e) {
    return await Bv(e, ie()._payloadRevivers)
}
function kb(e, t) {
    ie()._payloadRevivers[e] = t
}
const Aa = {
    NuxtError: e=>Vo(e),
    EmptyShallowRef: e=>Kr(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Yr(e)),
    EmptyRef: e=>pt(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Yr(e)),
    ShallowRef: e=>Kr(e),
    ShallowReactive: e=>ls(e),
    Ref: e=>pt(e),
    Reactive: e=>nn(e)
};
Aa.Island = ({key: e, params: t, result: n})=>{
    const r = ie();
    return r.isHydrating || (r.payload.data[e] = r.payload.data[e] || $fetch(`/__nuxt_island/${e}.json`, {
        responseType: "json",
        ...t ? {
            params: t
        } : {}
    }).then(s=>(r.payload.data[e] = s,
    s))),
    {
        html: "",
        state: {},
        head: {
            link: [],
            style: []
        },
        ...n
    }
}
;
const Rb = ke({
    name: "nuxt:revive-payload:client",
    order: -30,
    async setup(e) {
        let t, n;
        for (const r in Aa)
            kb(r, Aa[r]);
        Object.assign(e.payload, ([t,n] = Qr(()=>e.runWithContext(Sb)),
        t = await t,
        n(),
        t)),
        window.__NUXT__ = e.payload
    }
})
  , Ab = []
  , Pb = ke({
    name: "nuxt:head",
    enforce: "pre",
    setup(e) {
        const t = pb({
            plugins: Ab
        });
        mb(()=>ie().vueApp._context.provides.usehead),
        e.vueApp.use(t);
        {
            let n = !0;
            const r = async()=>{
                n = !1,
                await eh(t)
            }
            ;
            t.hooks.hook("dom:beforeRender", s=>{
                s.shouldRender = !n
            }
            ),
            e.hooks.hook("page:start", ()=>{
                n = !0
            }
            ),
            e.hooks.hook("page:finish", ()=>{
                e.isHydrating || r()
            }
            ),
            e.hooks.hook("app:error", r),
            e.hooks.hook("app:suspense:resolve", r)
        }
    }
});
/*!
  * vue-router v4.3.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const tr = typeof document < "u";
function Ob(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const le = Object.assign;
function di(e, t) {
    const n = {};
    for (const r in t) {
        const s = t[r];
        n[r] = Bt(s) ? s.map(e) : e(s)
    }
    return n
}
const jr = ()=>{}
  , Bt = Array.isArray
  , ah = /#/g
  , Ib = /&/g
  , Lb = /\//g
  , Nb = /=/g
  , Mb = /\?/g
  , ch = /\+/g
  , Bb = /%5B/g
  , Db = /%5D/g
  , lh = /%5E/g
  , xb = /%60/g
  , uh = /%7B/g
  , Fb = /%7C/g
  , fh = /%7D/g
  , Hb = /%20/g;
function Lc(e) {
    return encodeURI("" + e).replace(Fb, "|").replace(Bb, "[").replace(Db, "]")
}
function $b(e) {
    return Lc(e).replace(uh, "{").replace(fh, "}").replace(lh, "^")
}
function Pa(e) {
    return Lc(e).replace(ch, "%2B").replace(Hb, "+").replace(ah, "%23").replace(Ib, "%26").replace(xb, "`").replace(uh, "{").replace(fh, "}").replace(lh, "^")
}
function jb(e) {
    return Pa(e).replace(Nb, "%3D")
}
function Vb(e) {
    return Lc(e).replace(ah, "%23").replace(Mb, "%3F")
}
function Ub(e) {
    return e == null ? "" : Vb(e).replace(Lb, "%2F")
}
function Zr(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
const qb = /\/$/
  , Wb = e=>e.replace(qb, "");
function hi(e, t, n="/") {
    let r, s = {}, o = "", i = "";
    const a = t.indexOf("#");
    let l = t.indexOf("?");
    return a < l && a >= 0 && (l = -1),
    l > -1 && (r = t.slice(0, l),
    o = t.slice(l + 1, a > -1 ? a : t.length),
    s = e(o)),
    a > -1 && (r = r || t.slice(0, a),
    i = t.slice(a, t.length)),
    r = Jb(r ?? t, n),
    {
        fullPath: r + (o && "?") + o + i,
        path: r,
        query: s,
        hash: Zr(i)
    }
}
function Kb(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "")
}
function iu(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}
function zb(e, t, n) {
    const r = t.matched.length - 1
      , s = n.matched.length - 1;
    return r > -1 && r === s && Er(t.matched[r], n.matched[s]) && dh(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}
function Er(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function dh(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (!Gb(e[n], t[n]))
            return !1;
    return !0
}
function Gb(e, t) {
    return Bt(e) ? au(e, t) : Bt(t) ? au(t, e) : e === t
}
function au(e, t) {
    return Bt(t) ? e.length === t.length && e.every((n,r)=>n === t[r]) : e.length === 1 && e[0] === t
}
function Jb(e, t) {
    if (e.startsWith("/"))
        return e;
    if (!e)
        return t;
    const n = t.split("/")
      , r = e.split("/")
      , s = r[r.length - 1];
    (s === ".." || s === ".") && r.push("");
    let o = n.length - 1, i, a;
    for (i = 0; i < r.length; i++)
        if (a = r[i],
        a !== ".")
            if (a === "..")
                o > 1 && o--;
            else
                break;
    return n.slice(0, o).join("/") + "/" + r.slice(i).join("/")
}
var es;
(function(e) {
    e.pop = "pop",
    e.push = "push"
}
)(es || (es = {}));
var Vr;
(function(e) {
    e.back = "back",
    e.forward = "forward",
    e.unknown = ""
}
)(Vr || (Vr = {}));
function Xb(e) {
    if (!e)
        if (tr) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/",
            e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e),
    Wb(e)
}
const Yb = /^[^#]+#/;
function Qb(e, t) {
    return e.replace(Yb, "#") + t
}
function Zb(e, t) {
    const n = document.documentElement.getBoundingClientRect()
      , r = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: r.left - n.left - (t.left || 0),
        top: r.top - n.top - (t.top || 0)
    }
}
const qo = ()=>({
    left: window.scrollX,
    top: window.scrollY
});
function e0(e) {
    let t;
    if ("el"in e) {
        const n = e.el
          , r = typeof n == "string" && n.startsWith("#")
          , s = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!s)
            return;
        t = Zb(s, e)
    } else
        t = e;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}
function cu(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const Oa = new Map;
function t0(e, t) {
    Oa.set(e, t)
}
function n0(e) {
    const t = Oa.get(e);
    return Oa.delete(e),
    t
}
let r0 = ()=>location.protocol + "//" + location.host;
function hh(e, t) {
    const {pathname: n, search: r, hash: s} = t
      , o = e.indexOf("#");
    if (o > -1) {
        let a = s.includes(e.slice(o)) ? e.slice(o).length : 1
          , l = s.slice(a);
        return l[0] !== "/" && (l = "/" + l),
        iu(l, "")
    }
    return iu(n, e) + r + s
}
function s0(e, t, n, r) {
    let s = []
      , o = []
      , i = null;
    const a = ({state: d})=>{
        const h = hh(e, location)
          , m = n.value
          , v = t.value;
        let T = 0;
        if (d) {
            if (n.value = h,
            t.value = d,
            i && i === m) {
                i = null;
                return
            }
            T = v ? d.position - v.position : 0
        } else
            r(h);
        s.forEach(k=>{
            k(n.value, m, {
                delta: T,
                type: es.pop,
                direction: T ? T > 0 ? Vr.forward : Vr.back : Vr.unknown
            })
        }
        )
    }
    ;
    function l() {
        i = n.value
    }
    function u(d) {
        s.push(d);
        const h = ()=>{
            const m = s.indexOf(d);
            m > -1 && s.splice(m, 1)
        }
        ;
        return o.push(h),
        h
    }
    function c() {
        const {history: d} = window;
        d.state && d.replaceState(le({}, d.state, {
            scroll: qo()
        }), "")
    }
    function f() {
        for (const d of o)
            d();
        o = [],
        window.removeEventListener("popstate", a),
        window.removeEventListener("beforeunload", c)
    }
    return window.addEventListener("popstate", a),
    window.addEventListener("beforeunload", c, {
        passive: !0
    }),
    {
        pauseListeners: l,
        listen: u,
        destroy: f
    }
}
function lu(e, t, n, r=!1, s=!1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: s ? qo() : null
    }
}
function o0(e) {
    const {history: t, location: n} = window
      , r = {
        value: hh(e, n)
    }
      , s = {
        value: t.state
    };
    s.value || o(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function o(l, u, c) {
        const f = e.indexOf("#")
          , d = f > -1 ? (n.host && document.querySelector("base") ? e : e.slice(f)) + l : r0() + e + l;
        try {
            t[c ? "replaceState" : "pushState"](u, "", d),
            s.value = u
        } catch (h) {
            console.error(h),
            n[c ? "replace" : "assign"](d)
        }
    }
    function i(l, u) {
        const c = le({}, t.state, lu(s.value.back, l, s.value.forward, !0), u, {
            position: s.value.position
        });
        o(l, c, !0),
        r.value = l
    }
    function a(l, u) {
        const c = le({}, s.value, t.state, {
            forward: l,
            scroll: qo()
        });
        o(c.current, c, !0);
        const f = le({}, lu(r.value, l, null), {
            position: c.position + 1
        }, u);
        o(l, f, !1),
        r.value = l
    }
    return {
        location: r,
        state: s,
        push: a,
        replace: i
    }
}
function ph(e) {
    e = Xb(e);
    const t = o0(e)
      , n = s0(e, t.state, t.location, t.replace);
    function r(o, i=!0) {
        i || n.pauseListeners(),
        history.go(o)
    }
    const s = le({
        location: "",
        base: e,
        go: r,
        createHref: Qb.bind(null, e)
    }, t, n);
    return Object.defineProperty(s, "location", {
        enumerable: !0,
        get: ()=>t.location.value
    }),
    Object.defineProperty(s, "state", {
        enumerable: !0,
        get: ()=>t.state.value
    }),
    s
}
function i0(e) {
    return e = location.host ? e || location.pathname + location.search : "",
    e.includes("#") || (e += "#"),
    ph(e)
}
function a0(e) {
    return typeof e == "string" || e && typeof e == "object"
}
function mh(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const At = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
}
  , gh = Symbol("");
var uu;
(function(e) {
    e[e.aborted = 4] = "aborted",
    e[e.cancelled = 8] = "cancelled",
    e[e.duplicated = 16] = "duplicated"
}
)(uu || (uu = {}));
function Cr(e, t) {
    return le(new Error, {
        type: e,
        [gh]: !0
    }, t)
}
function Jt(e, t) {
    return e instanceof Error && gh in e && (t == null || !!(e.type & t))
}
const fu = "[^/]+?"
  , c0 = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , l0 = /[.+*?^${}()[\]/\\]/g;
function u0(e, t) {
    const n = le({}, c0, t)
      , r = [];
    let s = n.start ? "^" : "";
    const o = [];
    for (const u of e) {
        const c = u.length ? [] : [90];
        n.strict && !u.length && (s += "/");
        for (let f = 0; f < u.length; f++) {
            const d = u[f];
            let h = 40 + (n.sensitive ? .25 : 0);
            if (d.type === 0)
                f || (s += "/"),
                s += d.value.replace(l0, "\\$&"),
                h += 40;
            else if (d.type === 1) {
                const {value: m, repeatable: v, optional: T, regexp: k} = d;
                o.push({
                    name: m,
                    repeatable: v,
                    optional: T
                });
                const b = k || fu;
                if (b !== fu) {
                    h += 10;
                    try {
                        new RegExp(`(${b})`)
                    } catch (w) {
                        throw new Error(`Invalid custom RegExp for param "${m}" (${b}): ` + w.message)
                    }
                }
                let y = v ? `((?:${b})(?:/(?:${b}))*)` : `(${b})`;
                f || (y = T && u.length < 2 ? `(?:/${y})` : "/" + y),
                T && (y += "?"),
                s += y,
                h += 20,
                T && (h += -8),
                v && (h += -20),
                b === ".*" && (h += -50)
            }
            c.push(h)
        }
        r.push(c)
    }
    if (n.strict && n.end) {
        const u = r.length - 1;
        r[u][r[u].length - 1] += .7000000000000001
    }
    n.strict || (s += "/?"),
    n.end ? s += "$" : n.strict && (s += "(?:/|$)");
    const i = new RegExp(s,n.sensitive ? "" : "i");
    function a(u) {
        const c = u.match(i)
          , f = {};
        if (!c)
            return null;
        for (let d = 1; d < c.length; d++) {
            const h = c[d] || ""
              , m = o[d - 1];
            f[m.name] = h && m.repeatable ? h.split("/") : h
        }
        return f
    }
    function l(u) {
        let c = ""
          , f = !1;
        for (const d of e) {
            (!f || !c.endsWith("/")) && (c += "/"),
            f = !1;
            for (const h of d)
                if (h.type === 0)
                    c += h.value;
                else if (h.type === 1) {
                    const {value: m, repeatable: v, optional: T} = h
                      , k = m in u ? u[m] : "";
                    if (Bt(k) && !v)
                        throw new Error(`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`);
                    const b = Bt(k) ? k.join("/") : k;
                    if (!b)
                        if (T)
                            d.length < 2 && (c.endsWith("/") ? c = c.slice(0, -1) : f = !0);
                        else
                            throw new Error(`Missing required param "${m}"`);
                    c += b
                }
        }
        return c || "/"
    }
    return {
        re: i,
        score: r,
        keys: o,
        parse: a,
        stringify: l
    }
}
function f0(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length; ) {
        const r = t[n] - e[n];
        if (r)
            return r;
        n++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}
function d0(e, t) {
    let n = 0;
    const r = e.score
      , s = t.score;
    for (; n < r.length && n < s.length; ) {
        const o = f0(r[n], s[n]);
        if (o)
            return o;
        n++
    }
    if (Math.abs(s.length - r.length) === 1) {
        if (du(r))
            return 1;
        if (du(s))
            return -1
    }
    return s.length - r.length
}
function du(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const h0 = {
    type: 0,
    value: ""
}
  , p0 = /[a-zA-Z0-9_]/;
function m0(e) {
    if (!e)
        return [[]];
    if (e === "/")
        return [[h0]];
    if (!e.startsWith("/"))
        throw new Error(`Invalid path "${e}"`);
    function t(h) {
        throw new Error(`ERR (${n})/"${u}": ${h}`)
    }
    let n = 0
      , r = n;
    const s = [];
    let o;
    function i() {
        o && s.push(o),
        o = []
    }
    let a = 0, l, u = "", c = "";
    function f() {
        u && (n === 0 ? o.push({
            type: 0,
            value: u
        }) : n === 1 || n === 2 || n === 3 ? (o.length > 1 && (l === "*" || l === "+") && t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),
        o.push({
            type: 1,
            value: u,
            regexp: c,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : t("Invalid state to consume buffer"),
        u = "")
    }
    function d() {
        u += l
    }
    for (; a < e.length; ) {
        if (l = e[a++],
        l === "\\" && n !== 2) {
            r = n,
            n = 4;
            continue
        }
        switch (n) {
        case 0:
            l === "/" ? (u && f(),
            i()) : l === ":" ? (f(),
            n = 1) : d();
            break;
        case 4:
            d(),
            n = r;
            break;
        case 1:
            l === "(" ? n = 2 : p0.test(l) ? d() : (f(),
            n = 0,
            l !== "*" && l !== "?" && l !== "+" && a--);
            break;
        case 2:
            l === ")" ? c[c.length - 1] == "\\" ? c = c.slice(0, -1) + l : n = 3 : c += l;
            break;
        case 3:
            f(),
            n = 0,
            l !== "*" && l !== "?" && l !== "+" && a--,
            c = "";
            break;
        default:
            t("Unknown state");
            break
        }
    }
    return n === 2 && t(`Unfinished custom RegExp for param "${u}"`),
    f(),
    i(),
    s
}
function g0(e, t, n) {
    const r = u0(m0(e.path), n)
      , s = le(r, {
        record: e,
        parent: t,
        children: [],
        alias: []
    });
    return t && !s.record.aliasOf == !t.record.aliasOf && t.children.push(s),
    s
}
function y0(e, t) {
    const n = []
      , r = new Map;
    t = mu({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);
    function s(c) {
        return r.get(c)
    }
    function o(c, f, d) {
        const h = !d
          , m = v0(c);
        m.aliasOf = d && d.record;
        const v = mu(t, c)
          , T = [m];
        if ("alias"in c) {
            const y = typeof c.alias == "string" ? [c.alias] : c.alias;
            for (const w of y)
                T.push(le({}, m, {
                    components: d ? d.record.components : m.components,
                    path: w,
                    aliasOf: d ? d.record : m
                }))
        }
        let k, b;
        for (const y of T) {
            const {path: w} = y;
            if (f && w[0] !== "/") {
                const E = f.record.path
                  , _ = E[E.length - 1] === "/" ? "" : "/";
                y.path = f.record.path + (w && _ + w)
            }
            if (k = g0(y, f, v),
            d ? d.alias.push(k) : (b = b || k,
            b !== k && b.alias.push(k),
            h && c.name && !pu(k) && i(c.name)),
            m.children) {
                const E = m.children;
                for (let _ = 0; _ < E.length; _++)
                    o(E[_], k, d && d.children[_])
            }
            d = d || k,
            (k.record.components && Object.keys(k.record.components).length || k.record.name || k.record.redirect) && l(k)
        }
        return b ? ()=>{
            i(b)
        }
        : jr
    }
    function i(c) {
        if (mh(c)) {
            const f = r.get(c);
            f && (r.delete(c),
            n.splice(n.indexOf(f), 1),
            f.children.forEach(i),
            f.alias.forEach(i))
        } else {
            const f = n.indexOf(c);
            f > -1 && (n.splice(f, 1),
            c.record.name && r.delete(c.record.name),
            c.children.forEach(i),
            c.alias.forEach(i))
        }
    }
    function a() {
        return n
    }
    function l(c) {
        let f = 0;
        for (; f < n.length && d0(c, n[f]) >= 0 && (c.record.path !== n[f].record.path || !yh(c, n[f])); )
            f++;
        n.splice(f, 0, c),
        c.record.name && !pu(c) && r.set(c.record.name, c)
    }
    function u(c, f) {
        let d, h = {}, m, v;
        if ("name"in c && c.name) {
            if (d = r.get(c.name),
            !d)
                throw Cr(1, {
                    location: c
                });
            v = d.record.name,
            h = le(hu(f.params, d.keys.filter(b=>!b.optional).concat(d.parent ? d.parent.keys.filter(b=>b.optional) : []).map(b=>b.name)), c.params && hu(c.params, d.keys.map(b=>b.name))),
            m = d.stringify(h)
        } else if (c.path != null)
            m = c.path,
            d = n.find(b=>b.re.test(m)),
            d && (h = d.parse(m),
            v = d.record.name);
        else {
            if (d = f.name ? r.get(f.name) : n.find(b=>b.re.test(f.path)),
            !d)
                throw Cr(1, {
                    location: c,
                    currentLocation: f
                });
            v = d.record.name,
            h = le({}, f.params, c.params),
            m = d.stringify(h)
        }
        const T = [];
        let k = d;
        for (; k; )
            T.unshift(k.record),
            k = k.parent;
        return {
            name: v,
            path: m,
            params: h,
            matched: T,
            meta: w0(T)
        }
    }
    return e.forEach(c=>o(c)),
    {
        addRoute: o,
        resolve: u,
        removeRoute: i,
        getRoutes: a,
        getRecordMatcher: s
    }
}
function hu(e, t) {
    const n = {};
    for (const r of t)
        r in e && (n[r] = e[r]);
    return n
}
function v0(e) {
    return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: b0(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in e ? e.components || null : e.component && {
            default: e.component
        }
    }
}
function b0(e) {
    const t = {}
      , n = e.props || !1;
    if ("component"in e)
        t.default = n;
    else
        for (const r in e.components)
            t[r] = typeof n == "object" ? n[r] : n;
    return t
}
function pu(e) {
    for (; e; ) {
        if (e.record.aliasOf)
            return !0;
        e = e.parent
    }
    return !1
}
function w0(e) {
    return e.reduce((t,n)=>le(t, n.meta), {})
}
function mu(e, t) {
    const n = {};
    for (const r in e)
        n[r] = r in t ? t[r] : e[r];
    return n
}
function yh(e, t) {
    return t.children.some(n=>n === e || yh(e, n))
}
function E0(e) {
    const t = {};
    if (e === "" || e === "?")
        return t;
    const r = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let s = 0; s < r.length; ++s) {
        const o = r[s].replace(ch, " ")
          , i = o.indexOf("=")
          , a = Zr(i < 0 ? o : o.slice(0, i))
          , l = i < 0 ? null : Zr(o.slice(i + 1));
        if (a in t) {
            let u = t[a];
            Bt(u) || (u = t[a] = [u]),
            u.push(l)
        } else
            t[a] = l
    }
    return t
}
function gu(e) {
    let t = "";
    for (let n in e) {
        const r = e[n];
        if (n = jb(n),
        r == null) {
            r !== void 0 && (t += (t.length ? "&" : "") + n);
            continue
        }
        (Bt(r) ? r.map(o=>o && Pa(o)) : [r && Pa(r)]).forEach(o=>{
            o !== void 0 && (t += (t.length ? "&" : "") + n,
            o != null && (t += "=" + o))
        }
        )
    }
    return t
}
function C0(e) {
    const t = {};
    for (const n in e) {
        const r = e[n];
        r !== void 0 && (t[n] = Bt(r) ? r.map(s=>s == null ? null : "" + s) : r == null ? r : "" + r)
    }
    return t
}
const T0 = Symbol("")
  , yu = Symbol("")
  , Nc = Symbol("")
  , Mc = Symbol("")
  , Ia = Symbol("");
function Ir() {
    let e = [];
    function t(r) {
        return e.push(r),
        ()=>{
            const s = e.indexOf(r);
            s > -1 && e.splice(s, 1)
        }
    }
    function n() {
        e = []
    }
    return {
        add: t,
        list: ()=>e.slice(),
        reset: n
    }
}
function yn(e, t, n, r, s, o=i=>i()) {
    const i = r && (r.enterCallbacks[s] = r.enterCallbacks[s] || []);
    return ()=>new Promise((a,l)=>{
        const u = d=>{
            d === !1 ? l(Cr(4, {
                from: n,
                to: t
            })) : d instanceof Error ? l(d) : a0(d) ? l(Cr(2, {
                from: t,
                to: d
            })) : (i && r.enterCallbacks[s] === i && typeof d == "function" && i.push(d),
            a())
        }
          , c = o(()=>e.call(r && r.instances[s], t, n, u));
        let f = Promise.resolve(c);
        e.length < 3 && (f = f.then(u)),
        f.catch(d=>l(d))
    }
    )
}
function pi(e, t, n, r, s=o=>o()) {
    const o = [];
    for (const i of e)
        for (const a in i.components) {
            let l = i.components[a];
            if (!(t !== "beforeRouteEnter" && !i.instances[a]))
                if (_0(l)) {
                    const c = (l.__vccOpts || l)[t];
                    c && o.push(yn(c, n, r, i, a, s))
                } else {
                    let u = l();
                    o.push(()=>u.then(c=>{
                        if (!c)
                            return Promise.reject(new Error(`Couldn't resolve component "${a}" at "${i.path}"`));
                        const f = Ob(c) ? c.default : c;
                        i.components[a] = f;
                        const h = (f.__vccOpts || f)[t];
                        return h && yn(h, n, r, i, a, s)()
                    }
                    ))
                }
        }
    return o
}
function _0(e) {
    return typeof e == "object" || "displayName"in e || "props"in e || "__vccOpts"in e
}
function vu(e) {
    const t = Oe(Nc)
      , n = Oe(Mc)
      , r = ft(()=>t.resolve(he(e.to)))
      , s = ft(()=>{
        const {matched: l} = r.value
          , {length: u} = l
          , c = l[u - 1]
          , f = n.matched;
        if (!c || !f.length)
            return -1;
        const d = f.findIndex(Er.bind(null, c));
        if (d > -1)
            return d;
        const h = bu(l[u - 2]);
        return u > 1 && bu(c) === h && f[f.length - 1].path !== h ? f.findIndex(Er.bind(null, l[u - 2])) : d
    }
    )
      , o = ft(()=>s.value > -1 && A0(n.params, r.value.params))
      , i = ft(()=>s.value > -1 && s.value === n.matched.length - 1 && dh(n.params, r.value.params));
    function a(l={}) {
        return R0(l) ? t[he(e.replace) ? "replace" : "push"](he(e.to)).catch(jr) : Promise.resolve()
    }
    return {
        route: r,
        href: ft(()=>r.value.href),
        isActive: o,
        isExactActive: i,
        navigate: a
    }
}
const S0 = De({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: vu,
    setup(e, {slots: t}) {
        const n = nn(vu(e))
          , {options: r} = Oe(Nc)
          , s = ft(()=>({
            [wu(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
            [wu(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
        }));
        return ()=>{
            const o = t.default && t.default(n);
            return e.custom ? o : gt("a", {
                "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: s.value
            }, o)
        }
    }
})
  , k0 = S0;
function R0(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t))
                return
        }
        return e.preventDefault && e.preventDefault(),
        !0
    }
}
function A0(e, t) {
    for (const n in t) {
        const r = t[n]
          , s = e[n];
        if (typeof r == "string") {
            if (r !== s)
                return !1
        } else if (!Bt(s) || s.length !== r.length || r.some((o,i)=>o !== s[i]))
            return !1
    }
    return !0
}
function bu(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const wu = (e,t,n)=>e ?? t ?? n
  , P0 = De({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(e, {attrs: t, slots: n}) {
        const r = Oe(Ia)
          , s = ft(()=>e.route || r.value)
          , o = Oe(yu, 0)
          , i = ft(()=>{
            let u = he(o);
            const {matched: c} = s.value;
            let f;
            for (; (f = c[u]) && !f.components; )
                u++;
            return u
        }
        )
          , a = ft(()=>s.value.matched[i.value]);
        jn(yu, ft(()=>i.value + 1)),
        jn(T0, a),
        jn(Ia, s);
        const l = pt();
        return mt(()=>[l.value, a.value, e.name], ([u,c,f],[d,h,m])=>{
            c && (c.instances[f] = u,
            h && h !== c && u && u === d && (c.leaveGuards.size || (c.leaveGuards = h.leaveGuards),
            c.updateGuards.size || (c.updateGuards = h.updateGuards))),
            u && c && (!h || !Er(c, h) || !d) && (c.enterCallbacks[f] || []).forEach(v=>v(u))
        }
        , {
            flush: "post"
        }),
        ()=>{
            const u = s.value
              , c = e.name
              , f = a.value
              , d = f && f.components[c];
            if (!d)
                return Eu(n.default, {
                    Component: d,
                    route: u
                });
            const h = f.props[c]
              , m = h ? h === !0 ? u.params : typeof h == "function" ? h(u) : h : null
              , T = gt(d, le({}, m, t, {
                onVnodeUnmounted: k=>{
                    k.component.isUnmounted && (f.instances[c] = null)
                }
                ,
                ref: l
            }));
            return Eu(n.default, {
                Component: T,
                route: u
            }) || T
        }
    }
});
function Eu(e, t) {
    if (!e)
        return null;
    const n = e(t);
    return n.length === 1 ? n[0] : n
}
const vh = P0;
function O0(e) {
    const t = y0(e.routes, e)
      , n = e.parseQuery || E0
      , r = e.stringifyQuery || gu
      , s = e.history
      , o = Ir()
      , i = Ir()
      , a = Ir()
      , l = Kr(At);
    let u = At;
    tr && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const c = di.bind(null, P=>"" + P)
      , f = di.bind(null, Ub)
      , d = di.bind(null, Zr);
    function h(P, V) {
        let $, W;
        return mh(P) ? ($ = t.getRecordMatcher(P),
        W = V) : W = P,
        t.addRoute(W, $)
    }
    function m(P) {
        const V = t.getRecordMatcher(P);
        V && t.removeRoute(V)
    }
    function v() {
        return t.getRoutes().map(P=>P.record)
    }
    function T(P) {
        return !!t.getRecordMatcher(P)
    }
    function k(P, V) {
        if (V = le({}, V || l.value),
        typeof P == "string") {
            const g = hi(n, P, V.path)
              , S = t.resolve({
                path: g.path
            }, V)
              , O = s.createHref(g.fullPath);
            return le(g, S, {
                params: d(S.params),
                hash: Zr(g.hash),
                redirectedFrom: void 0,
                href: O
            })
        }
        let $;
        if (P.path != null)
            $ = le({}, P, {
                path: hi(n, P.path, V.path).path
            });
        else {
            const g = le({}, P.params);
            for (const S in g)
                g[S] == null && delete g[S];
            $ = le({}, P, {
                params: f(g)
            }),
            V.params = f(V.params)
        }
        const W = t.resolve($, V)
          , ae = P.hash || "";
        W.params = c(d(W.params));
        const me = Kb(r, le({}, P, {
            hash: $b(ae),
            path: W.path
        }))
          , p = s.createHref(me);
        return le({
            fullPath: me,
            hash: ae,
            query: r === gu ? C0(P.query) : P.query || {}
        }, W, {
            redirectedFrom: void 0,
            href: p
        })
    }
    function b(P) {
        return typeof P == "string" ? hi(n, P, l.value.path) : le({}, P)
    }
    function y(P, V) {
        if (u !== P)
            return Cr(8, {
                from: V,
                to: P
            })
    }
    function w(P) {
        return I(P)
    }
    function E(P) {
        return w(le(b(P), {
            replace: !0
        }))
    }
    function _(P) {
        const V = P.matched[P.matched.length - 1];
        if (V && V.redirect) {
            const {redirect: $} = V;
            let W = typeof $ == "function" ? $(P) : $;
            return typeof W == "string" && (W = W.includes("?") || W.includes("#") ? W = b(W) : {
                path: W
            },
            W.params = {}),
            le({
                query: P.query,
                hash: P.hash,
                params: W.path != null ? {} : P.params
            }, W)
        }
    }
    function I(P, V) {
        const $ = u = k(P)
          , W = l.value
          , ae = P.state
          , me = P.force
          , p = P.replace === !0
          , g = _($);
        if (g)
            return I(le(b(g), {
                state: typeof g == "object" ? le({}, ae, g.state) : ae,
                force: me,
                replace: p
            }), V || $);
        const S = $;
        S.redirectedFrom = V;
        let O;
        return !me && zb(r, W, $) && (O = Cr(16, {
            to: S,
            from: W
        }),
        Ht(W, W, !0, !1)),
        (O ? Promise.resolve(O) : L(S, W)).catch(A=>Jt(A) ? Jt(A, 2) ? A : sn(A) : q(A, S, W)).then(A=>{
            if (A) {
                if (Jt(A, 2))
                    return I(le({
                        replace: p
                    }, b(A.to), {
                        state: typeof A.to == "object" ? le({}, ae, A.to.state) : ae,
                        force: me
                    }), V || S)
            } else
                A = N(S, W, !0, p, ae);
            return H(S, W, A),
            A
        }
        )
    }
    function C(P, V) {
        const $ = y(P, V);
        return $ ? Promise.reject($) : Promise.resolve()
    }
    function R(P) {
        const V = Yn.values().next().value;
        return V && typeof V.runWithContext == "function" ? V.runWithContext(P) : P()
    }
    function L(P, V) {
        let $;
        const [W,ae,me] = I0(P, V);
        $ = pi(W.reverse(), "beforeRouteLeave", P, V);
        for (const g of W)
            g.leaveGuards.forEach(S=>{
                $.push(yn(S, P, V))
            }
            );
        const p = C.bind(null, P, V);
        return $.push(p),
        Ie($).then(()=>{
            $ = [];
            for (const g of o.list())
                $.push(yn(g, P, V));
            return $.push(p),
            Ie($)
        }
        ).then(()=>{
            $ = pi(ae, "beforeRouteUpdate", P, V);
            for (const g of ae)
                g.updateGuards.forEach(S=>{
                    $.push(yn(S, P, V))
                }
                );
            return $.push(p),
            Ie($)
        }
        ).then(()=>{
            $ = [];
            for (const g of me)
                if (g.beforeEnter)
                    if (Bt(g.beforeEnter))
                        for (const S of g.beforeEnter)
                            $.push(yn(S, P, V));
                    else
                        $.push(yn(g.beforeEnter, P, V));
            return $.push(p),
            Ie($)
        }
        ).then(()=>(P.matched.forEach(g=>g.enterCallbacks = {}),
        $ = pi(me, "beforeRouteEnter", P, V, R),
        $.push(p),
        Ie($))).then(()=>{
            $ = [];
            for (const g of i.list())
                $.push(yn(g, P, V));
            return $.push(p),
            Ie($)
        }
        ).catch(g=>Jt(g, 8) ? g : Promise.reject(g))
    }
    function H(P, V, $) {
        a.list().forEach(W=>R(()=>W(P, V, $)))
    }
    function N(P, V, $, W, ae) {
        const me = y(P, V);
        if (me)
            return me;
        const p = V === At
          , g = tr ? history.state : {};
        $ && (W || p ? s.replace(P.fullPath, le({
            scroll: p && g && g.scroll
        }, ae)) : s.push(P.fullPath, ae)),
        l.value = P,
        Ht(P, V, $, p),
        sn()
    }
    let z;
    function se() {
        z || (z = s.listen((P,V,$)=>{
            if (!Ss.listening)
                return;
            const W = k(P)
              , ae = _(W);
            if (ae) {
                I(le(ae, {
                    replace: !0
                }), W).catch(jr);
                return
            }
            u = W;
            const me = l.value;
            tr && t0(cu(me.fullPath, $.delta), qo()),
            L(W, me).catch(p=>Jt(p, 12) ? p : Jt(p, 2) ? (I(p.to, W).then(g=>{
                Jt(g, 20) && !$.delta && $.type === es.pop && s.go(-1, !1)
            }
            ).catch(jr),
            Promise.reject()) : ($.delta && s.go(-$.delta, !1),
            q(p, W, me))).then(p=>{
                p = p || N(W, me, !1),
                p && ($.delta && !Jt(p, 8) ? s.go(-$.delta, !1) : $.type === es.pop && Jt(p, 20) && s.go(-1, !1)),
                H(W, me, p)
            }
            ).catch(jr)
        }
        ))
    }
    let re = Ir(), x = Ir(), Z;
    function q(P, V, $) {
        sn(P);
        const W = x.list();
        return W.length ? W.forEach(ae=>ae(P, V, $)) : console.error(P),
        Promise.reject(P)
    }
    function St() {
        return Z && l.value !== At ? Promise.resolve() : new Promise((P,V)=>{
            re.add([P, V])
        }
        )
    }
    function sn(P) {
        return Z || (Z = !P,
        se(),
        re.list().forEach(([V,$])=>P ? $(P) : V()),
        re.reset()),
        P
    }
    function Ht(P, V, $, W) {
        const {scrollBehavior: ae} = e;
        if (!tr || !ae)
            return Promise.resolve();
        const me = !$ && n0(cu(P.fullPath, 0)) || (W || !$) && history.state && history.state.scroll || null;
        return Dt().then(()=>ae(P, V, me)).then(p=>p && e0(p)).catch(p=>q(p, P, V))
    }
    const xe = P=>s.go(P);
    let Xn;
    const Yn = new Set
      , Ss = {
        currentRoute: l,
        listening: !0,
        addRoute: h,
        removeRoute: m,
        hasRoute: T,
        getRoutes: v,
        resolve: k,
        options: e,
        push: w,
        replace: E,
        go: xe,
        back: ()=>xe(-1),
        forward: ()=>xe(1),
        beforeEach: o.add,
        beforeResolve: i.add,
        afterEach: a.add,
        onError: x.add,
        isReady: St,
        install(P) {
            const V = this;
            P.component("RouterLink", k0),
            P.component("RouterView", vh),
            P.config.globalProperties.$router = V,
            Object.defineProperty(P.config.globalProperties, "$route", {
                enumerable: !0,
                get: ()=>he(l)
            }),
            tr && !Xn && l.value === At && (Xn = !0,
            w(s.location).catch(ae=>{}
            ));
            const $ = {};
            for (const ae in At)
                Object.defineProperty($, ae, {
                    get: ()=>l.value[ae],
                    enumerable: !0
                });
            P.provide(Nc, V),
            P.provide(Mc, ls($)),
            P.provide(Ia, l);
            const W = P.unmount;
            Yn.add(P),
            P.unmount = function() {
                Yn.delete(P),
                Yn.size < 1 && (u = At,
                z && z(),
                z = null,
                l.value = At,
                Xn = !1,
                Z = !1),
                W()
            }
        }
    };
    function Ie(P) {
        return P.reduce((V,$)=>V.then(()=>R($)), Promise.resolve())
    }
    return Ss
}
function I0(e, t) {
    const n = []
      , r = []
      , s = []
      , o = Math.max(t.matched.length, e.matched.length);
    for (let i = 0; i < o; i++) {
        const a = t.matched[i];
        a && (e.matched.find(u=>Er(u, a)) ? r.push(a) : n.push(a));
        const l = e.matched[i];
        l && (t.matched.find(u=>Er(u, l)) || s.push(l))
    }
    return [n, r, s]
}
function L0() {
    return Oe(Mc)
}
const N0 = (e,t)=>t.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, n=>{
    var r;
    return ((r = e.params[n.slice(1)]) == null ? void 0 : r.toString()) || ""
}
)
  , La = (e,t)=>{
    const n = e.route.matched.find(s=>{
        var o;
        return ((o = s.components) == null ? void 0 : o.default) === e.Component.type
    }
    )
      , r = t ?? (n == null ? void 0 : n.meta.key) ?? (n && N0(e.route, n));
    return typeof r == "function" ? r(e.route) : r
}
  , M0 = (e,t)=>({
    default: ()=>e ? gt(Am, e === !0 ? {} : e, t) : t
});
function Bc(e) {
    return Array.isArray(e) ? e : [e]
}
const mi = null
  , Ve = {
    pageBackground: "bg1"
}
  , gi = null
  , yi = null
  , vi = null
  , bi = null
  , wi = null
  , Ei = null
  , Ci = null
  , Ue = {
    pageBackground: "bg3"
}
  , Ti = null
  , qe = {
    pageBackground: "bg1"
}
  , _i = null
  , We = {
    pageBackground: "bg1"
}
  , Ke = {
    pageBackground: "bg1"
}
  , ze = {
    pageBackground: "bg2"
}
  , Ge = {
    pageBackground: "bg1"
}
  , Si = null
  , ki = null
  , Ri = null
  , Je = {
    pageBackground: "bg1"
}
  , Ai = null
  , Pi = null
  , Oi = null
  , Ii = null
  , Li = null
  , Ni = null
  , Mi = null
  , Bi = null
  , Xe = {
    pageBackground: "bg1"
}
  , Ye = {
    pageBackground: "bg1"
}
  , Qe = {
    pageBackground: "bg1"
}
  , Ze = {
    pageBackground: "bg1"
}
  , et = {
    pageBackground: "bg1"
}
  , tt = {
    pageBackground: "bg1"
}
  , nt = {
    pageBackground: "bg1"
}
  , rt = {
    pageBackground: "bg1"
}
  , st = {
    pageBackground: "bg1"
}
  , ot = {
    pageBackground: "bg1"
}
  , it = {
    pageBackground: "bg1"
}
  , at = {
    pageBackground: "bg1"
}
  , ct = {
    pageBackground: "bg1"
}
  , Di = null
  , xi = null
  , Fi = null
  , Hi = null
  , $i = null
  , ji = null
  , Cu = [{
    name: "about-cryptodrop",
    path: "/about-cryptodrop",
    meta: {},
    alias: [],
    redirect: mi == null ? void 0 : mi.redirect,
    component: ()=>J(()=>import("./DRSVZzvX.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Ve == null ? void 0 : Ve.name) ?? "cryptodrop",
    path: (Ve == null ? void 0 : Ve.path) ?? "/cryptodrop",
    meta: Ve || {},
    alias: (Ve == null ? void 0 : Ve.alias) || [],
    redirect: Ve == null ? void 0 : Ve.redirect,
    component: ()=>J(()=>import("./BCulhAmO.js"), __vite__mapDeps([16, 12, 17, 3, 2, 4, 18]), import.meta.url).then(e=>e.default || e)
}, {
    name: "error",
    path: "/error",
    meta: {},
    alias: [],
    redirect: gi == null ? void 0 : gi.redirect,
    component: ()=>J(()=>import("./CDaE1xxE.js"), __vite__mapDeps([19, 20, 10, 3, 2, 4, 11, 21]), import.meta.url).then(e=>e.default || e)
}, {
    name: "free-crypto-boost",
    path: "/free-crypto/boost",
    meta: {},
    alias: [],
    redirect: yi == null ? void 0 : yi.redirect,
    component: ()=>J(()=>import("./DOffT44F.js"), __vite__mapDeps([22, 23, 2, 24]), import.meta.url).then(e=>e.default || e)
}, {
    name: "free-crypto",
    path: "/free-crypto",
    meta: {},
    alias: [],
    redirect: vi == null ? void 0 : vi.redirect,
    component: ()=>J(()=>import("./BtSe6vDq.js"), __vite__mapDeps([25, 26, 27, 10, 3, 2, 4, 11, 8, 9, 28, 29, 30, 23, 31, 5, 32, 33, 6, 7, 34, 35, 36, 37]), import.meta.url).then(e=>e.default || e)
}, {
    name: "free-crypto-overview",
    path: "/free-crypto/overview",
    meta: {},
    alias: [],
    redirect: bi == null ? void 0 : bi.redirect,
    component: ()=>J(()=>import("./TaH7hA6k.js"), __vite__mapDeps([38, 39, 26, 8, 2, 9, 13, 3, 4, 14, 40, 32, 33, 41, 1, 42, 43]), import.meta.url).then(e=>e.default || e)
}, {
    name: "free-crypto-refer",
    path: "/free-crypto/refer",
    meta: {},
    alias: [],
    redirect: wi == null ? void 0 : wi.redirect,
    component: ()=>J(()=>import("./UslH2yVv.js"), __vite__mapDeps([44, 39, 26, 8, 2, 9, 13, 3, 4, 14, 40, 45, 10, 11, 46]), import.meta.url).then(e=>e.default || e)
}, {
    name: "free-crypto-reward",
    path: "/free-crypto/reward",
    meta: {},
    alias: [],
    redirect: Ei == null ? void 0 : Ei.redirect,
    component: ()=>J(()=>import("./BMA4abMV.js"), __vite__mapDeps([47, 48, 10, 3, 2, 4, 11, 8, 9, 23, 29, 32, 33, 30, 28, 49]), import.meta.url).then(e=>e.default || e)
}, {
    name: "friends",
    path: "/friends",
    meta: {},
    alias: [],
    redirect: Ci == null ? void 0 : Ci.redirect,
    component: ()=>J(()=>import("./BvsFPunx.js"), __vite__mapDeps([50, 45, 51, 3, 2, 4, 1, 52, 39, 26, 8, 9, 13, 14, 40, 53, 54, 55, 56, 41, 42, 57, 58, 59, 60, 10, 11, 61, 62]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Ue == null ? void 0 : Ue.name) ?? "game-boost",
    path: (Ue == null ? void 0 : Ue.path) ?? "/game-boost",
    meta: Ue || {},
    alias: (Ue == null ? void 0 : Ue.alias) || [],
    redirect: Ue == null ? void 0 : Ue.redirect,
    component: ()=>J(()=>import("./DhJWq1T8.js"), __vite__mapDeps([63, 64, 65, 30, 8, 2, 9, 10, 3, 4, 11, 66, 5, 29, 28, 67, 68]), import.meta.url).then(e=>e.default || e)
}, {
    name: "game",
    path: "/game",
    meta: {},
    alias: [],
    redirect: Ti == null ? void 0 : Ti.redirect,
    component: ()=>J(()=>import("./BxxvWGPF.js"), __vite__mapDeps([69, 26, 70, 5, 30, 10, 3, 2, 4, 11, 8, 9, 71]), import.meta.url).then(e=>e.default || e)
}, {
    name: (qe == null ? void 0 : qe.name) ?? "index",
    path: (qe == null ? void 0 : qe.path) ?? "/",
    meta: qe || {},
    alias: (qe == null ? void 0 : qe.alias) || [],
    redirect: qe == null ? void 0 : qe.redirect,
    component: ()=>J(()=>import("./CZrXGl1Z.js"), __vite__mapDeps([72, 73, 35, 58, 3, 2, 4, 59, 8, 9, 26, 10, 11, 74, 5, 75, 55, 56, 32, 33, 30, 76]), import.meta.url).then(e=>e.default || e)
}, {
    name: "leaderboard",
    path: "/leaderboard",
    meta: {},
    alias: [],
    redirect: _i == null ? void 0 : _i.redirect,
    component: ()=>J(()=>import("./B6WLvY07.js"), __vite__mapDeps([77, 41, 2, 1, 42, 51, 3, 4, 52, 55, 56, 8, 9, 78]), import.meta.url).then(e=>e.default || e)
}, {
    name: (We == null ? void 0 : We.name) ?? "lvl-info",
    path: (We == null ? void 0 : We.path) ?? "/lvl-info",
    meta: We || {},
    alias: (We == null ? void 0 : We.alias) || [],
    redirect: We == null ? void 0 : We.redirect,
    component: ()=>J(()=>import("./BHTI34Nq.js"), __vite__mapDeps([79, 10, 3, 2, 4, 11, 80]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Ke == null ? void 0 : Ke.name) ?? "overview-history",
    path: (Ke == null ? void 0 : Ke.path) ?? "/overview/history",
    meta: Ke || {},
    alias: (Ke == null ? void 0 : Ke.alias) || [],
    redirect: Ke == null ? void 0 : Ke.redirect,
    component: ()=>J(()=>import("./ew5ON6Jg.js"), __vite__mapDeps([81, 41, 2, 1, 42, 8, 9, 57, 58, 3, 4, 59, 60, 82, 83]), import.meta.url).then(e=>e.default || e)
}, {
    name: (ze == null ? void 0 : ze.name) ?? "overview",
    path: (ze == null ? void 0 : ze.path) ?? "/overview",
    meta: ze || {},
    alias: (ze == null ? void 0 : ze.alias) || [],
    redirect: ze == null ? void 0 : ze.redirect,
    component: ()=>J(()=>import("./bRcxTqP0.js"), __vite__mapDeps([84, 39, 26, 8, 2, 9, 13, 3, 4, 14, 40, 35, 54, 30, 82, 85]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Ge == null ? void 0 : Ge.name) ?? "overview-info",
    path: (Ge == null ? void 0 : Ge.path) ?? "/overview/info",
    meta: Ge || {},
    alias: (Ge == null ? void 0 : Ge.alias) || [],
    redirect: Ge == null ? void 0 : Ge.redirect,
    component: ()=>J(()=>import("./xIlgjzeZ.js"), __vite__mapDeps([86, 87, 2, 88]), import.meta.url).then(e=>e.default || e)
}, {
    name: "overview-lottery",
    path: "/overview/lottery",
    meta: {},
    alias: [],
    redirect: Si == null ? void 0 : Si.redirect,
    component: ()=>J(()=>import("./uWP3-j0i.js"), __vite__mapDeps([89, 2]), import.meta.url).then(e=>e.default || e)
}, {
    name: "overview-withdraw",
    path: "/overview/withdraw",
    meta: {},
    alias: [],
    redirect: ki == null ? void 0 : ki.redirect,
    component: ()=>J(()=>import("./B3S4fow_.js"), __vite__mapDeps([90, 12, 8, 2, 9, 10, 3, 4, 11, 30, 91, 92]), import.meta.url).then(e=>e.default || e)
}, {
    name: "quests-earn",
    path: "/quests/earn",
    meta: {},
    alias: [],
    redirect: Ri == null ? void 0 : Ri.redirect,
    component: ()=>J(()=>import("./B6VUJOmQ.js"), __vite__mapDeps([93, 94, 2, 95, 96, 65, 3, 4, 97, 39, 26, 8, 9, 13, 14, 40, 98, 66, 5, 33, 99, 100, 10, 11, 91, 101]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Je == null ? void 0 : Je.name) ?? "quests",
    path: (Je == null ? void 0 : Je.path) ?? "/quests",
    meta: Je || {},
    alias: (Je == null ? void 0 : Je.alias) || [],
    redirect: Je == null ? void 0 : Je.redirect,
    component: ()=>J(()=>import("./CFXYgp9I.js"), __vite__mapDeps([102, 3, 2, 4, 34, 26, 5, 35, 8, 9, 36, 33, 54, 99, 51, 1, 52, 103]), import.meta.url).then(e=>e.default || e)
}, {
    name: "quests-social-connect",
    path: "/quests/social/connect",
    meta: {},
    alias: [],
    redirect: Ai == null ? void 0 : Ai.redirect,
    component: ()=>J(()=>import("./-SXVdFqo.js"), __vite__mapDeps([104, 94, 2, 95, 10, 3, 4, 11, 29, 105]), import.meta.url).then(e=>e.default || e)
}, {
    name: "quests-social",
    path: "/quests/social",
    meta: {},
    alias: [],
    redirect: Pi == null ? void 0 : Pi.redirect,
    component: ()=>J(()=>import("./CanG2eKc.js"), __vite__mapDeps([106, 94, 2, 95, 96, 65, 3, 4, 97, 98, 66, 5, 33, 99, 100, 10, 11, 29, 91, 107, 108]), import.meta.url).then(e=>e.default || e)
}, {
    name: "quests-social-twitter-qr",
    path: "/quests/social/twitter-qr",
    meta: {},
    alias: [],
    redirect: Oi == null ? void 0 : Oi.redirect,
    component: ()=>J(()=>import("./BsLiiQf9.js"), __vite__mapDeps([109, 2, 110]), import.meta.url).then(e=>e.default || e)
}, {
    name: "quests-social-unfortunately",
    path: "/quests/social/unfortunately",
    meta: {},
    alias: [],
    redirect: Ii == null ? void 0 : Ii.redirect,
    component: ()=>J(()=>import("./R7Bj7EkF.js"), __vite__mapDeps([111, 20, 10, 3, 2, 4, 11, 112]), import.meta.url).then(e=>e.default || e)
}, {
    name: "quests-trading",
    path: "/quests/trading",
    meta: {},
    alias: [],
    redirect: Li == null ? void 0 : Li.redirect,
    component: ()=>J(()=>import("./ByzsbMhi.js"), __vite__mapDeps([113, 94, 2, 95, 96, 65, 3, 4, 97, 39, 26, 8, 9, 13, 14, 40, 98, 66, 5, 33, 99, 100, 10, 11, 91, 114]), import.meta.url).then(e=>e.default || e)
}, {
    name: "quests-wager",
    path: "/quests/wager",
    meta: {},
    alias: [],
    redirect: Ni == null ? void 0 : Ni.redirect,
    component: ()=>J(()=>import("./CODubv1W.js"), __vite__mapDeps([115, 94, 2, 95, 96, 65, 3, 4, 97, 39, 26, 8, 9, 13, 14, 40, 98, 66, 5, 33, 99, 100, 10, 11, 91, 116]), import.meta.url).then(e=>e.default || e)
}, {
    name: "share-image-path-imageId-type",
    path: "/share-image/:path()/:imageId()/:type()",
    meta: {},
    alias: [],
    redirect: Mi == null ? void 0 : Mi.redirect,
    component: ()=>J(()=>import("./DnHc53EX.js"), __vite__mapDeps([117, 118]), import.meta.url).then(e=>e.default || e)
}, {
    name: "share-type-referral-image",
    path: "/share/:type()/:referral()/:image()",
    meta: {},
    alias: [],
    redirect: Bi == null ? void 0 : Bi.redirect,
    component: ()=>J(()=>import("./DzuNNOBc.js"), __vite__mapDeps([119, 118]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Xe == null ? void 0 : Xe.name) ?? "squad-bank",
    path: (Xe == null ? void 0 : Xe.path) ?? "/squad/bank",
    meta: Xe || {},
    alias: (Xe == null ? void 0 : Xe.alias) || [],
    redirect: Xe == null ? void 0 : Xe.redirect,
    component: ()=>J(()=>import("./CSq0OXW2.js"), __vite__mapDeps([120, 2, 51, 3, 4, 1, 52, 121, 122, 26, 8, 9, 123, 124, 55, 56, 75, 125]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Ye == null ? void 0 : Ye.name) ?? "squad-confirm-delete",
    path: (Ye == null ? void 0 : Ye.path) ?? "/squad/confirm-delete",
    meta: Ye || {},
    alias: (Ye == null ? void 0 : Ye.alias) || [],
    redirect: Ye == null ? void 0 : Ye.redirect,
    component: ()=>J(()=>import("./0rpJEqYI.js"), __vite__mapDeps([126, 10, 3, 2, 4, 11, 8, 9, 75, 55, 56, 127]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Qe == null ? void 0 : Qe.name) ?? "squad-confirm-leave",
    path: (Qe == null ? void 0 : Qe.path) ?? "/squad/confirm-leave",
    meta: Qe || {},
    alias: (Qe == null ? void 0 : Qe.alias) || [],
    redirect: Qe == null ? void 0 : Qe.redirect,
    component: ()=>J(()=>import("./bLKZshdW.js"), __vite__mapDeps([128, 10, 3, 2, 4, 11, 129, 130, 131, 132, 75, 55, 56, 133]), import.meta.url).then(e=>e.default || e)
}, {
    name: (Ze == null ? void 0 : Ze.name) ?? "squad-confirm-stop-join",
    path: (Ze == null ? void 0 : Ze.path) ?? "/squad/confirm-stop-join",
    meta: Ze || {},
    alias: (Ze == null ? void 0 : Ze.alias) || [],
    redirect: Ze == null ? void 0 : Ze.redirect,
    component: ()=>J(()=>import("./CjGpVctZ.js"), __vite__mapDeps([134, 10, 3, 2, 4, 11, 75, 55, 56, 135]), import.meta.url).then(e=>e.default || e)
}, {
    name: (et == null ? void 0 : et.name) ?? "squad-creation",
    path: (et == null ? void 0 : et.path) ?? "/squad/creation",
    meta: et || {},
    alias: (et == null ? void 0 : et.alias) || [],
    redirect: et == null ? void 0 : et.redirect,
    component: ()=>J(()=>import("./Boc6SjAf.js"), __vite__mapDeps([136, 2, 3, 4, 55, 56, 75, 137, 138, 13, 14, 10, 11, 139]), import.meta.url).then(e=>e.default || e)
}, {
    name: (tt == null ? void 0 : tt.name) ?? "squad-donat-history",
    path: (tt == null ? void 0 : tt.path) ?? "/squad/donat-history",
    meta: tt || {},
    alias: (tt == null ? void 0 : tt.alias) || [],
    redirect: tt == null ? void 0 : tt.redirect,
    component: ()=>J(()=>import("./DpgICpPI.js"), __vite__mapDeps([140, 51, 3, 2, 4, 1, 52, 8, 9, 123, 124, 55, 56, 75, 141]), import.meta.url).then(e=>e.default || e)
}, {
    name: (nt == null ? void 0 : nt.name) ?? "squad-donat-info",
    path: (nt == null ? void 0 : nt.path) ?? "/squad/donat-info",
    meta: nt || {},
    alias: (nt == null ? void 0 : nt.alias) || [],
    redirect: nt == null ? void 0 : nt.redirect,
    component: ()=>J(()=>import("./C_ei97nG.js"), __vite__mapDeps([142, 143, 10, 3, 2, 4, 11, 129, 130, 131, 132, 75, 55, 56, 144]), import.meta.url).then(e=>e.default || e)
}, {
    name: (rt == null ? void 0 : rt.name) ?? "squad-donate",
    path: (rt == null ? void 0 : rt.path) ?? "/squad/donate",
    meta: rt || {},
    alias: (rt == null ? void 0 : rt.alias) || [],
    redirect: rt == null ? void 0 : rt.redirect,
    component: ()=>J(()=>import("./B8BQRA6-.js"), __vite__mapDeps([145, 143, 13, 3, 2, 4, 14, 10, 11, 146, 1, 147, 61, 58, 59, 129, 130, 131, 132, 75, 148]), import.meta.url).then(e=>e.default || e)
}, {
    name: (st == null ? void 0 : st.name) ?? "squad-hint-to-join",
    path: (st == null ? void 0 : st.path) ?? "/squad/hint-to-join",
    meta: st || {},
    alias: (st == null ? void 0 : st.alias) || [],
    redirect: st == null ? void 0 : st.redirect,
    component: ()=>J(()=>import("./4R4UHT6r.js"), __vite__mapDeps([149, 10, 3, 2, 4, 11, 129, 130, 131, 132, 75, 55, 56, 150]), import.meta.url).then(e=>e.default || e)
}, {
    name: (ot == null ? void 0 : ot.name) ?? "squad",
    path: (ot == null ? void 0 : ot.path) ?? "/squad",
    meta: ot || {},
    alias: (ot == null ? void 0 : ot.alias) || [],
    redirect: ot == null ? void 0 : ot.redirect,
    component: ()=>J(()=>import("./n8ffhApi.js"), __vite__mapDeps([151, 39, 26, 8, 2, 9, 13, 3, 4, 14, 40, 55, 56, 41, 1, 42, 143, 57, 58, 59, 60, 75, 152]), import.meta.url).then(e=>e.default || e)
}, {
    name: (it == null ? void 0 : it.name) ?? "squad-points",
    path: (it == null ? void 0 : it.path) ?? "/squad/points",
    meta: it || {},
    alias: (it == null ? void 0 : it.alias) || [],
    redirect: it == null ? void 0 : it.redirect,
    component: ()=>J(()=>import("./Cviz7YWC.js"), __vite__mapDeps([153, 129, 130, 2, 131, 132, 154, 26, 155, 3, 4, 156]), import.meta.url).then(e=>e.default || e)
}, {
    name: (at == null ? void 0 : at.name) ?? "squads",
    path: (at == null ? void 0 : at.path) ?? "/squads",
    meta: at || {},
    alias: (at == null ? void 0 : at.alias) || [],
    redirect: at == null ? void 0 : at.redirect,
    component: ()=>J(()=>import("./Cgxc4yiX.js"), __vite__mapDeps([157, 2, 51, 3, 4, 1, 52, 129, 130, 131, 132, 154, 26, 155, 10, 11, 75, 158]), import.meta.url).then(e=>e.default || e)
}, {
    name: (ct == null ? void 0 : ct.name) ?? "squads-join",
    path: (ct == null ? void 0 : ct.path) ?? "/squads/join",
    meta: ct || {},
    alias: (ct == null ? void 0 : ct.alias) || [],
    redirect: ct == null ? void 0 : ct.redirect,
    component: ()=>J(()=>import("./DN83ABVv.js"), __vite__mapDeps([159, 2, 160, 8, 9, 3, 4, 55, 56, 161, 162]), import.meta.url).then(e=>e.default || e)
}, {
    name: "ui",
    path: "/ui",
    meta: {},
    alias: [],
    redirect: Di == null ? void 0 : Di.redirect,
    component: ()=>J(()=>import("./BQyrV1Jw.js"), __vite__mapDeps([163, 73, 35, 58, 3, 2, 4, 59, 8, 9, 26, 10, 11, 74, 39, 13, 14, 40, 96, 65, 97, 51, 1, 52, 34, 5, 36, 57, 60, 41, 42, 6, 7, 94, 95, 160, 55, 56, 161, 130, 131, 146, 147, 129, 132, 154, 155, 137, 138, 164, 165, 166]), import.meta.url).then(e=>e.default || e)
}, {
    name: "wheel-history",
    path: "/wheel/history",
    meta: {},
    alias: [],
    redirect: xi == null ? void 0 : xi.redirect,
    component: ()=>J(()=>import("./iRb33dxa.js"), __vite__mapDeps([167, 51, 3, 2, 4, 1, 52, 41, 42, 55, 56, 8, 9, 30, 168]), import.meta.url).then(e=>e.default || e)
}, {
    name: "wheel",
    path: "/wheel",
    meta: {},
    alias: [],
    redirect: Fi == null ? void 0 : Fi.redirect,
    component: ()=>J(()=>import("./B7HM4yIT.js"), __vite__mapDeps([169, 54, 5, 2, 27, 10, 3, 4, 11, 8, 9, 28, 29, 30, 23, 31, 130, 131, 58, 59, 170]), import.meta.url).then(e=>e.default || e)
}, {
    name: "wheel-overview",
    path: "/wheel/overview",
    meta: {},
    alias: [],
    redirect: Hi == null ? void 0 : Hi.redirect,
    component: ()=>J(()=>import("./Dh1fxTJO.js"), __vite__mapDeps([171, 87, 130, 2, 131, 30, 172]), import.meta.url).then(e=>e.default || e)
}, {
    name: "wheel-reward",
    path: "/wheel/reward",
    meta: {},
    alias: [],
    redirect: $i == null ? void 0 : $i.redirect,
    component: ()=>J(()=>import("./Bi0AbUKn.js"), __vite__mapDeps([173, 48, 10, 3, 2, 4, 11, 8, 9, 23, 29, 32, 33, 30, 28, 49]), import.meta.url).then(e=>e.default || e)
}, {
    name: "AllIcons",
    path: "/all-icons",
    meta: {},
    alias: [],
    redirect: ji == null ? void 0 : ji.redirect,
    component: ()=>J(()=>import("./XSVBfF8g.js"), __vite__mapDeps([174, 70, 3, 2, 4, 175]), import.meta.url).then(e=>e.default || e)
}]
  , bh = (e,t,n)=>(t = t === !0 ? {} : t,
{
    default: ()=>{
        var r;
        return t ? gt(e, t, n) : (r = n.default) == null ? void 0 : r.call(n)
    }
});
function Tu(e) {
    const t = (e == null ? void 0 : e.meta.key) ?? e.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, n=>{
        var r;
        return ((r = e.params[n.slice(1)]) == null ? void 0 : r.toString()) || ""
    }
    );
    return typeof t == "function" ? t(e) : t
}
function B0(e, t) {
    return e === t || t === At ? !1 : Tu(e) !== Tu(t) ? !0 : !e.matched.every((r,s)=>{
        var o, i;
        return r.components && r.components.default === ((i = (o = t.matched[s]) == null ? void 0 : o.components) == null ? void 0 : i.default)
    }
    )
}
const D0 = {
    scrollBehavior(e, t, n) {
        var u;
        const r = ie()
          , s = ((u = xt().options) == null ? void 0 : u.scrollBehaviorType) ?? "auto";
        let o = n || void 0;
        const i = typeof e.meta.scrollToTop == "function" ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop;
        if (!o && t && e && i !== !1 && B0(e, t) && (o = {
            left: 0,
            top: 0
        }),
        e.path === t.path)
            return t.hash && !e.hash ? {
                left: 0,
                top: 0
            } : e.hash ? {
                el: e.hash,
                top: _u(e.hash),
                behavior: s
            } : !1;
        const a = c=>!!(c.meta.pageTransition ?? Ra)
          , l = a(t) && a(e) ? "page:transition:finish" : "page:finish";
        return new Promise(c=>{
            r.hooks.hookOnce(l, async()=>{
                await new Promise(f=>setTimeout(f, 0)),
                e.hash && (o = {
                    el: e.hash,
                    top: _u(e.hash),
                    behavior: s
                }),
                c(o)
            }
            )
        }
        )
    }
};
function _u(e) {
    try {
        const t = document.querySelector(e);
        if (t)
            return parseFloat(getComputedStyle(t).scrollMarginTop)
    } catch {}
    return 0
}
const x0 = {
    hashMode: !1,
    scrollBehaviorType: "auto"
}
  , lt = {
    ...x0,
    ...D0
}
  , F0 = async e=>{
    var l;
    let t, n;
    if (!((l = e.meta) != null && l.validate))
        return;
    const r = ie()
      , s = xt();
    if (([t,n] = Qr(()=>Promise.resolve(e.meta.validate(e))),
    t = await t,
    n(),
    t) === !0)
        return;
    const i = Vo({
        statusCode: 404,
        statusMessage: `Page Not Found: ${e.fullPath}`,
        data: {
            path: e.fullPath
        }
    })
      , a = s.beforeResolve(u=>{
        if (a(),
        u === e) {
            const c = s.afterEach(async()=>{
                c(),
                await r.runWithContext(()=>rr(i)),
                window.history.pushState({}, "", e.fullPath)
            }
            );
            return !1
        }
    }
    )
}
  , H0 = async e=>{
    let t, n;
    const r = ([t,n] = Qr(()=>Ic(e.path)),
    t = await t,
    n(),
    t);
    if (r.redirect)
        return zn(r.redirect, {
            acceptRelative: !0
        }) ? (window.location.href = r.redirect,
        !1) : r.redirect
}
  , $0 = [F0, H0]
  , Ur = {};
function j0(e, t, n) {
    const {pathname: r, search: s, hash: o} = t
      , i = e.indexOf("#");
    if (i > -1) {
        const u = o.includes(e.slice(i)) ? e.slice(i).length : 1;
        let c = o.slice(u);
        return c[0] !== "/" && (c = "/" + c),
        Vl(c, "")
    }
    const a = Vl(r, e)
      , l = !n || ky(a, n, {
        trailingSlash: !0
    }) ? a : n;
    return l + (l.includes("?") ? "" : s) + o
}
const V0 = ke({
    name: "nuxt:router",
    enforce: "pre",
    async setup(e) {
        var T, k;
        let t, n, r = kr().app.baseURL;
        lt.hashMode && !r.includes("#") && (r += "#");
        const s = ((T = lt.history) == null ? void 0 : T.call(lt, r)) ?? (lt.hashMode ? i0(r) : ph(r))
          , o = ((k = lt.routes) == null ? void 0 : k.call(lt, Cu)) ?? Cu;
        let i;
        const a = O0({
            ...lt,
            scrollBehavior: (b,y,w)=>{
                if (y === At) {
                    i = w;
                    return
                }
                if (lt.scrollBehavior) {
                    if (a.options.scrollBehavior = lt.scrollBehavior,
                    "scrollRestoration"in window.history) {
                        const E = a.beforeEach(()=>{
                            E(),
                            window.history.scrollRestoration = "manual"
                        }
                        )
                    }
                    return lt.scrollBehavior(b, At, i || w)
                }
            }
            ,
            history: s,
            routes: o
        });
        "scrollRestoration"in window.history && (window.history.scrollRestoration = "auto"),
        e.vueApp.use(a);
        const l = Kr(a.currentRoute.value);
        a.afterEach((b,y)=>{
            l.value = y
        }
        ),
        Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", {
            get: ()=>l.value
        });
        const u = j0(r, window.location, e.payload.path)
          , c = Kr(a.currentRoute.value)
          , f = ()=>{
            c.value = a.currentRoute.value
        }
        ;
        e.hook("page:finish", f),
        a.afterEach((b,y)=>{
            var w, E, _, I;
            ((E = (w = b.matched[0]) == null ? void 0 : w.components) == null ? void 0 : E.default) === ((I = (_ = y.matched[0]) == null ? void 0 : _.components) == null ? void 0 : I.default) && f()
        }
        );
        const d = {};
        for (const b in c.value)
            Object.defineProperty(d, b, {
                get: ()=>c.value[b]
            });
        e._route = ls(d),
        e._middleware = e._middleware || {
            global: [],
            named: {}
        };
        try {
            [t,n] = Qr(()=>a.isReady()),
            await t,
            n()
        } catch (b) {
            [t,n] = Qr(()=>e.runWithContext(()=>rr(b))),
            await t,
            n()
        }
        const h = u !== a.currentRoute.value.fullPath ? a.resolve(u) : a.currentRoute.value;
        f();
        const m = e.payload.state._layout;
        a.beforeEach(async(b,y)=>{
            var w;
            await e.callHook("page:loading:start"),
            b.meta = nn(b.meta),
            e.isHydrating && m && !Vn(b.meta.layout) && (b.meta.layout = m),
            e._processingMiddleware = !0;
            {
                const E = new Set([...$0, ...e._middleware.global]);
                for (const _ of b.matched) {
                    const I = _.meta.middleware;
                    if (I)
                        for (const C of Bc(I))
                            E.add(C)
                }
                {
                    const _ = await e.runWithContext(()=>Ic(b.path));
                    if (_.appMiddleware)
                        for (const I in _.appMiddleware)
                            _.appMiddleware[I] ? E.add(I) : E.delete(I)
                }
                for (const _ of E) {
                    const I = typeof _ == "string" ? e._middleware.named[_] || await ((w = Ur[_]) == null ? void 0 : w.call(Ur).then(R=>R.default || R)) : _;
                    if (!I)
                        throw new Error(`Unknown route middleware: '${_}'.`);
                    const C = await e.runWithContext(()=>I(b, y));
                    if (!e.payload.serverRendered && e.isHydrating && (C === !1 || C instanceof Error)) {
                        const R = C || Ca({
                            statusCode: 404,
                            statusMessage: `Page Not Found: ${u}`
                        });
                        return await e.runWithContext(()=>rr(R)),
                        !1
                    }
                    if (C !== !0 && (C || C === !1))
                        return C
                }
            }
        }
        ),
        a.onError(async()=>{
            delete e._processingMiddleware,
            await e.callHook("page:loading:end")
        }
        );
        const v = jo();
        return a.afterEach(async(b,y,w)=>{
            delete e._processingMiddleware,
            !e.isHydrating && v.value && await e.runWithContext(_v),
            w && await e.callHook("page:loading:end"),
            b.matched.length === 0 && await e.runWithContext(()=>rr(Ca({
                statusCode: 404,
                fatal: !1,
                statusMessage: `Page not found: ${b.fullPath}`,
                data: {
                    path: b.fullPath
                }
            })))
        }
        ),
        e.hooks.hookOnce("app:created", async()=>{
            try {
                "name"in h && (h.name = void 0),
                await a.replace({
                    ...h,
                    force: !0
                }),
                a.options.scrollBehavior = lt.scrollBehavior
            } catch (b) {
                await e.runWithContext(()=>rr(b))
            }
        }
        ),
        {
            provide: {
                router: a
            }
        }
    }
})
  , Su = globalThis.requestIdleCallback || (e=>{
    const t = Date.now()
      , n = {
        didTimeout: !1,
        timeRemaining: ()=>Math.max(0, 50 - (Date.now() - t))
    };
    return setTimeout(()=>{
        e(n)
    }
    , 1)
}
)
  , l_ = globalThis.cancelIdleCallback || (e=>{
    clearTimeout(e)
}
)
  , wh = e=>{
    const t = ie();
    t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", ()=>{
        Su(e)
    }
    ) : Su(e)
}
  , U0 = ke({
    name: "nuxt:payload",
    setup(e) {
        xt().beforeResolve(async(t,n)=>{
            if (t.path === n.path)
                return;
            const r = await ou(t.path);
            r && Object.assign(e.static.data, r.data)
        }
        ),
        wh(()=>{
            var t;
            e.hooks.hook("link:prefetch", async n=>{
                $o(n).protocol || await ou(n)
            }
            ),
            ((t = navigator.connection) == null ? void 0 : t.effectiveType) !== "slow-2g" && setTimeout(Uo, 1e3)
        }
        )
    }
})
  , q0 = ke(e=>{
    let t;
    async function n() {
        const r = await Uo();
        t && clearTimeout(t),
        t = setTimeout(n, 1e3 * 60 * 60);
        try {
            const s = await $fetch(Pc("builds/latest.json") + `?${Date.now()}`);
            s.id !== r.id && e.hooks.callHook("app:manifest:update", s)
        } catch {}
    }
    wh(()=>{
        t = setTimeout(n, 1e3 * 60 * 60)
    }
    )
}
)
  , W0 = !1;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let Eh;
const ys = e=>Eh = e
  , Ch = Symbol();
function Na(e) {
    return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function"
}
var qr;
(function(e) {
    e.direct = "direct",
    e.patchObject = "patch object",
    e.patchFunction = "patch function"
}
)(qr || (qr = {}));
function K0() {
    const e = tc(!0)
      , t = e.run(()=>pt({}));
    let n = []
      , r = [];
    const s = Io({
        install(o) {
            ys(s),
            s._a = o,
            o.provide(Ch, s),
            o.config.globalProperties.$pinia = s,
            r.forEach(i=>n.push(i)),
            r = []
        },
        use(o) {
            return !this._a && !W0 ? r.push(o) : n.push(o),
            this
        },
        _p: n,
        _a: null,
        _e: e,
        _s: new Map,
        state: t
    });
    return s
}
const Th = ()=>{}
;
function ku(e, t, n, r=Th) {
    e.push(t);
    const s = ()=>{
        const o = e.indexOf(t);
        o > -1 && (e.splice(o, 1),
        r())
    }
    ;
    return !n && cs() && Po(s),
    s
}
function Zn(e, ...t) {
    e.slice().forEach(n=>{
        n(...t)
    }
    )
}
const z0 = e=>e();
function Ma(e, t) {
    e instanceof Map && t instanceof Map && t.forEach((n,r)=>e.set(r, n)),
    e instanceof Set && t instanceof Set && t.forEach(e.add, e);
    for (const n in t) {
        if (!t.hasOwnProperty(n))
            continue;
        const r = t[n]
          , s = e[n];
        Na(s) && Na(r) && e.hasOwnProperty(n) && !ve(r) && !Cn(r) ? e[n] = Ma(s, r) : e[n] = r
    }
    return e
}
const G0 = Symbol();
function J0(e) {
    return !Na(e) || !e.hasOwnProperty(G0)
}
const {assign: dn} = Object;
function X0(e) {
    return !!(ve(e) && e.effect)
}
function Y0(e, t, n, r) {
    const {state: s, actions: o, getters: i} = t
      , a = n.state.value[e];
    let l;
    function u() {
        a || (n.state.value[e] = s ? s() : {});
        const c = tm(n.state.value[e]);
        return dn(c, o, Object.keys(i || {}).reduce((f,d)=>(f[d] = Io(ft(()=>{
            ys(n);
            const h = n._s.get(e);
            return i[d].call(h, h)
        }
        )),
        f), {}))
    }
    return l = _h(e, u, t, n, r, !0),
    l
}
function _h(e, t, n={}, r, s, o) {
    let i;
    const a = dn({
        actions: {}
    }, n)
      , l = {
        deep: !0
    };
    let u, c, f = [], d = [], h;
    const m = r.state.value[e];
    !o && !m && (r.state.value[e] = {}),
    pt({});
    let v;
    function T(C) {
        let R;
        u = c = !1,
        typeof C == "function" ? (C(r.state.value[e]),
        R = {
            type: qr.patchFunction,
            storeId: e,
            events: h
        }) : (Ma(r.state.value[e], C),
        R = {
            type: qr.patchObject,
            payload: C,
            storeId: e,
            events: h
        });
        const L = v = Symbol();
        Dt().then(()=>{
            v === L && (u = !0)
        }
        ),
        c = !0,
        Zn(f, R, r.state.value[e])
    }
    const k = o ? function() {
        const {state: R} = n
          , L = R ? R() : {};
        this.$patch(H=>{
            dn(H, L)
        }
        )
    }
    : Th;
    function b() {
        i.stop(),
        f = [],
        d = [],
        r._s.delete(e)
    }
    function y(C, R) {
        return function() {
            ys(r);
            const L = Array.from(arguments)
              , H = []
              , N = [];
            function z(x) {
                H.push(x)
            }
            function se(x) {
                N.push(x)
            }
            Zn(d, {
                args: L,
                name: C,
                store: E,
                after: z,
                onError: se
            });
            let re;
            try {
                re = R.apply(this && this.$id === e ? this : E, L)
            } catch (x) {
                throw Zn(N, x),
                x
            }
            return re instanceof Promise ? re.then(x=>(Zn(H, x),
            x)).catch(x=>(Zn(N, x),
            Promise.reject(x))) : (Zn(H, re),
            re)
        }
    }
    const w = {
        _p: r,
        $id: e,
        $onAction: ku.bind(null, d),
        $patch: T,
        $reset: k,
        $subscribe(C, R={}) {
            const L = ku(f, C, R.detached, ()=>H())
              , H = i.run(()=>mt(()=>r.state.value[e], N=>{
                (R.flush === "sync" ? c : u) && C({
                    storeId: e,
                    type: qr.direct,
                    events: h
                }, N)
            }
            , dn({}, l, R)));
            return L
        },
        $dispose: b
    }
      , E = nn(w);
    r._s.set(e, E);
    const I = (r._a && r._a.runWithContext || z0)(()=>r._e.run(()=>(i = tc()).run(t)));
    for (const C in I) {
        const R = I[C];
        if (ve(R) && !X0(R) || Cn(R))
            o || (m && J0(R) && (ve(R) ? R.value = m[C] : Ma(R, m[C])),
            r.state.value[e][C] = R);
        else if (typeof R == "function") {
            const L = y(C, R);
            I[C] = L,
            a.actions[C] = R
        }
    }
    return dn(E, I),
    dn(ne(E), I),
    Object.defineProperty(E, "$state", {
        get: ()=>r.state.value[e],
        set: C=>{
            T(R=>{
                dn(R, C)
            }
            )
        }
    }),
    r._p.forEach(C=>{
        dn(E, i.run(()=>C({
            store: E,
            app: r._a,
            pinia: r,
            options: a
        })))
    }
    ),
    m && o && n.hydrate && n.hydrate(E.$state, m),
    u = !0,
    c = !0,
    E
}
function Dc(e, t, n) {
    let r, s;
    const o = typeof t == "function";
    typeof e == "string" ? (r = e,
    s = o ? n : t) : (s = e,
    r = e.id);
    function i(a, l) {
        const u = Ec();
        return a = a || (u ? Oe(Ch, null) : null),
        a && ys(a),
        a = Eh,
        a._s.has(r) || (o ? _h(r, t, s, a) : Y0(r, s, a)),
        a._s.get(r)
    }
    return i.$id = r,
    i
}
const Q0 = "$s";
function Sh(...e) {
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && e.unshift(t);
    const [n,r] = e;
    if (!n || typeof n != "string")
        throw new TypeError("[nuxt] [useState] key must be a string: " + n);
    if (r !== void 0 && typeof r != "function")
        throw new Error("[nuxt] [useState] init must be a function: " + r);
    const s = Q0 + n
      , o = ie()
      , i = Df(o.payload.state, s);
    if (i.value === void 0 && r) {
        const a = r();
        if (ve(a))
            return o.payload.state[s] = a,
            a;
        i.value = a
    }
    return i
}
const Z0 = {
    path: "/",
    watch: !0,
    decode: e=>Yr(decodeURIComponent(e)),
    encode: e=>encodeURIComponent(typeof e == "string" ? e : JSON.stringify(e))
}
  , ew = void 0;
function Ba(e, t) {
    var l;
    const n = {
        ...Z0,
        ...t
    }
      , r = Ru(n) || {};
    let s;
    n.maxAge !== void 0 ? s = n.maxAge * 1e3 : n.expires && (s = n.expires.getTime() - Date.now());
    const o = s !== void 0 && s <= 0
      , i = jt(o ? void 0 : r[e] ?? ((l = n.default) == null ? void 0 : l.call(n)))
      , a = s && !o ? rw(i, s, n.watch && n.watch !== "shallow") : pt(i);
    {
        let u = null;
        try {
            !ew && typeof BroadcastChannel < "u" && (u = new BroadcastChannel(`nuxt:cookies:${e}`))
        } catch {}
        const c = ()=>{
            n.readonly || pv(a.value, r[e]) || (nw(e, a.value, n),
            r[e] = jt(a.value),
            u == null || u.postMessage({
                value: n.encode(a.value)
            }))
        }
          , f = h=>{
            var v;
            const m = h.refresh ? (v = Ru(n)) == null ? void 0 : v[e] : n.decode(h.value);
            d = !0,
            r[e] = a.value = m,
            Dt(()=>{
                d = !1
            }
            )
        }
        ;
        let d = !1;
        cs() && Po(()=>{
            d = !0,
            c(),
            u == null || u.close()
        }
        ),
        u && (u.onmessage = ({data: h})=>f(h)),
        n.watch ? mt(a, ()=>{
            d || c()
        }
        , {
            deep: n.watch !== "shallow"
        }) : c()
    }
    return a
}
function Ru(e={}) {
    return av(document.cookie, e)
}
function tw(e, t, n={}) {
    return t == null ? zl(e, t, {
        ...n,
        maxAge: -1
    }) : zl(e, t, n)
}
function nw(e, t, n={}) {
    document.cookie = tw(e, t, n)
}
const Au = 2147483647;
function rw(e, t, n) {
    let r, s, o = 0;
    const i = n ? pt(e) : {
        value: e
    };
    return cs() && Po(()=>{
        s == null || s(),
        clearTimeout(r)
    }
    ),
    Bf((a,l)=>{
        n && (s = mt(i, l));
        function u() {
            clearTimeout(r);
            const c = t - o
              , f = c < Au ? c : Au;
            r = setTimeout(()=>{
                if (o += f,
                o < t)
                    return u();
                i.value = void 0,
                l()
            }
            , f)
        }
        return {
            get() {
                return a(),
                i.value
            },
            set(c) {
                u(),
                i.value = c,
                l()
            }
        }
    }
    )
}
function sw(e={}) {
    const t = e.path || window.location.pathname;
    let n = {};
    try {
        n = Yr(sessionStorage.getItem("nuxt:reload") || "{}")
    } catch {}
    if (e.force || (n == null ? void 0 : n.path) !== t || (n == null ? void 0 : n.expires) < Date.now()) {
        try {
            sessionStorage.setItem("nuxt:reload", JSON.stringify({
                path: t,
                expires: Date.now() + (e.ttl ?? 1e4)
            }))
        } catch {}
        if (e.persistState)
            try {
                sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                    state: ie().payload.state
                }))
            } catch {}
        window.location.pathname !== t ? window.location.href = t : window.location.reload()
    }
}
const ow = ke(e=>{
    const t = K0();
    return e.vueApp.use(t),
    ys(t),
    e.payload && e.payload.pinia && (t.state.value = e.payload.pinia),
    {
        provide: {
            pinia: t
        }
    }
}
)
  , iw = ke({
    name: "nuxt:global-components"
})
  , bn = {
    default: ()=>J(()=>import("./BWazXSaF.js"), __vite__mapDeps([176, 5, 2, 26, 10, 3, 4, 11, 58, 59, 54, 17, 30, 70, 20, 75, 32, 33, 1, 177]), import.meta.url).then(e=>e.default || e)
}
  , aw = ke({
    name: "nuxt:prefetch",
    setup(e) {
        const t = xt();
        e.hooks.hook("app:mounted", ()=>{
            t.beforeEach(async n=>{
                var s;
                const r = (s = n == null ? void 0 : n.meta) == null ? void 0 : s.layout;
                r && typeof bn[r] == "function" && await bn[r]()
            }
            )
        }
        ),
        e.hooks.hook("link:prefetch", n=>{
            if (zn(n))
                return;
            const r = t.resolve(n);
            if (!r)
                return;
            const s = r.meta.layout;
            let o = Bc(r.meta.middleware);
            o = o.filter(i=>typeof i == "string");
            for (const i of o)
                typeof Ur[i] == "function" && Ur[i]();
            s && typeof bn[s] == "function" && bn[s]()
        }
        )
    }
});
var u_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xc(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var Da = {
    exports: {}
}
  , Wo = {}
  , cw = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  , lw = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]
  , kh = function(t) {
    var n = t
      , r = t.indexOf("[")
      , s = t.indexOf("]");
    r != -1 && s != -1 && (t = t.substring(0, r) + t.substring(r, s).replace(/:/g, ";") + t.substring(s, t.length));
    for (var o = cw.exec(t || ""), i = {}, a = 14; a--; )
        i[lw[a]] = o[a] || "";
    return r != -1 && s != -1 && (i.source = n,
    i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, ":"),
    i.authority = i.authority.replace("[", "").replace("]", "").replace(/;/g, ":"),
    i.ipv6uri = !0),
    i.pathNames = uw(i, i.path),
    i.queryKey = fw(i, i.query),
    i
};
function uw(e, t) {
    var n = /\/{2,9}/g
      , r = t.replace(n, "/").split("/");
    return (t.substr(0, 1) == "/" || t.length === 0) && r.splice(0, 1),
    t.substr(t.length - 1, 1) == "/" && r.splice(r.length - 1, 1),
    r
}
function fw(e, t) {
    var n = {};
    return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, s, o) {
        s && (n[s] = o)
    }),
    n
}
var xa = {
    exports: {}
}, Vi, Pu;
function dw() {
    if (Pu)
        return Vi;
    Pu = 1;
    var e = 1e3
      , t = e * 60
      , n = t * 60
      , r = n * 24
      , s = r * 7
      , o = r * 365.25;
    Vi = function(c, f) {
        f = f || {};
        var d = typeof c;
        if (d === "string" && c.length > 0)
            return i(c);
        if (d === "number" && isFinite(c))
            return f.long ? l(c) : a(c);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(c))
    }
    ;
    function i(c) {
        if (c = String(c),
        !(c.length > 100)) {
            var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(c);
            if (f) {
                var d = parseFloat(f[1])
                  , h = (f[2] || "ms").toLowerCase();
                switch (h) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                    return d * o;
                case "weeks":
                case "week":
                case "w":
                    return d * s;
                case "days":
                case "day":
                case "d":
                    return d * r;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                    return d * n;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                    return d * t;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                    return d * e;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                    return d;
                default:
                    return
                }
            }
        }
    }
    function a(c) {
        var f = Math.abs(c);
        return f >= r ? Math.round(c / r) + "d" : f >= n ? Math.round(c / n) + "h" : f >= t ? Math.round(c / t) + "m" : f >= e ? Math.round(c / e) + "s" : c + "ms"
    }
    function l(c) {
        var f = Math.abs(c);
        return f >= r ? u(c, f, r, "day") : f >= n ? u(c, f, n, "hour") : f >= t ? u(c, f, t, "minute") : f >= e ? u(c, f, e, "second") : c + " ms"
    }
    function u(c, f, d, h) {
        var m = f >= d * 1.5;
        return Math.round(c / d) + " " + h + (m ? "s" : "")
    }
    return Vi
}
function hw(e) {
    n.debug = n,
    n.default = n,
    n.coerce = l,
    n.disable = o,
    n.enable = s,
    n.enabled = i,
    n.humanize = dw(),
    n.destroy = u,
    Object.keys(e).forEach(c=>{
        n[c] = e[c]
    }
    ),
    n.names = [],
    n.skips = [],
    n.formatters = {};
    function t(c) {
        let f = 0;
        for (let d = 0; d < c.length; d++)
            f = (f << 5) - f + c.charCodeAt(d),
            f |= 0;
        return n.colors[Math.abs(f) % n.colors.length]
    }
    n.selectColor = t;
    function n(c) {
        let f, d = null, h, m;
        function v(...T) {
            if (!v.enabled)
                return;
            const k = v
              , b = Number(new Date)
              , y = b - (f || b);
            k.diff = y,
            k.prev = f,
            k.curr = b,
            f = b,
            T[0] = n.coerce(T[0]),
            typeof T[0] != "string" && T.unshift("%O");
            let w = 0;
            T[0] = T[0].replace(/%([a-zA-Z%])/g, (_,I)=>{
                if (_ === "%%")
                    return "%";
                w++;
                const C = n.formatters[I];
                if (typeof C == "function") {
                    const R = T[w];
                    _ = C.call(k, R),
                    T.splice(w, 1),
                    w--
                }
                return _
            }
            ),
            n.formatArgs.call(k, T),
            (k.log || n.log).apply(k, T)
        }
        return v.namespace = c,
        v.useColors = n.useColors(),
        v.color = n.selectColor(c),
        v.extend = r,
        v.destroy = n.destroy,
        Object.defineProperty(v, "enabled", {
            enumerable: !0,
            configurable: !1,
            get: ()=>d !== null ? d : (h !== n.namespaces && (h = n.namespaces,
            m = n.enabled(c)),
            m),
            set: T=>{
                d = T
            }
        }),
        typeof n.init == "function" && n.init(v),
        v
    }
    function r(c, f) {
        const d = n(this.namespace + (typeof f > "u" ? ":" : f) + c);
        return d.log = this.log,
        d
    }
    function s(c) {
        n.save(c),
        n.namespaces = c,
        n.names = [],
        n.skips = [];
        let f;
        const d = (typeof c == "string" ? c : "").split(/[\s,]+/)
          , h = d.length;
        for (f = 0; f < h; f++)
            d[f] && (c = d[f].replace(/\*/g, ".*?"),
            c[0] === "-" ? n.skips.push(new RegExp("^" + c.slice(1) + "$")) : n.names.push(new RegExp("^" + c + "$")))
    }
    function o() {
        const c = [...n.names.map(a), ...n.skips.map(a).map(f=>"-" + f)].join(",");
        return n.enable(""),
        c
    }
    function i(c) {
        if (c[c.length - 1] === "*")
            return !0;
        let f, d;
        for (f = 0,
        d = n.skips.length; f < d; f++)
            if (n.skips[f].test(c))
                return !1;
        for (f = 0,
        d = n.names.length; f < d; f++)
            if (n.names[f].test(c))
                return !0;
        return !1
    }
    function a(c) {
        return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*")
    }
    function l(c) {
        return c instanceof Error ? c.stack || c.message : c
    }
    function u() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
    }
    return n.enable(n.load()),
    n
}
var pw = hw;
(function(e, t) {
    var n = {};
    t.formatArgs = s,
    t.save = o,
    t.load = i,
    t.useColors = r,
    t.storage = a(),
    t.destroy = (()=>{
        let u = !1;
        return ()=>{
            u || (u = !0,
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
        }
    }
    )(),
    t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function r() {
        return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
    }
    function s(u) {
        if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff),
        !this.useColors)
            return;
        const c = "color: " + this.color;
        u.splice(1, 0, c, "color: inherit");
        let f = 0
          , d = 0;
        u[0].replace(/%[a-zA-Z%]/g, h=>{
            h !== "%%" && (f++,
            h === "%c" && (d = f))
        }
        ),
        u.splice(d, 0, c)
    }
    t.log = console.debug || console.log || (()=>{}
    );
    function o(u) {
        try {
            u ? t.storage.setItem("debug", u) : t.storage.removeItem("debug")
        } catch {}
    }
    function i() {
        let u;
        try {
            u = t.storage.getItem("debug")
        } catch {}
        return !u && typeof process < "u" && "env"in process && (u = n.DEBUG),
        u
    }
    function a() {
        try {
            return localStorage
        } catch {}
    }
    e.exports = pw(t);
    const {formatters: l} = e.exports;
    l.j = function(u) {
        try {
            return JSON.stringify(u)
        } catch (c) {
            return "[UnexpectedJSONParseError]: " + c.message
        }
    }
}
)(xa, xa.exports);
var Ft = xa.exports;
const mw = xc(Ft);
Object.defineProperty(Wo, "__esModule", {
    value: !0
});
Wo.url = void 0;
const gw = kh
  , Ou = Ft("socket.io-client:url");
function yw(e, t="", n) {
    let r = e;
    n = n || typeof location < "u" && location,
    e == null && (e = n.protocol + "//" + n.host),
    typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = n.protocol + e : e = n.host + e),
    /^(https?|wss?):\/\//.test(e) || (Ou("protocol-less url %s", e),
    typeof n < "u" ? e = n.protocol + "//" + e : e = "https://" + e),
    Ou("parse %s", e),
    r = gw(e)),
    r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")),
    r.path = r.path || "/";
    const o = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
    return r.id = r.protocol + "://" + o + ":" + r.port + t,
    r.href = r.protocol + "://" + o + (n && n.port === r.port ? "" : ":" + r.port),
    r
}
Wo.url = yw;
var ts = {}
  , Jn = {
    exports: {}
}
  , Ko = {}
  , Fa = {
    exports: {}
};
try {
    Fa.exports = typeof XMLHttpRequest < "u" && "withCredentials"in new XMLHttpRequest
} catch {
    Fa.exports = !1
}
var vw = Fa.exports
  , zo = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
const bw = vw
  , ww = zo;
var Rh = function(e) {
    const t = e.xdomain
      , n = e.xscheme
      , r = e.enablesXDR;
    try {
        if (typeof XMLHttpRequest < "u" && (!t || bw))
            return new XMLHttpRequest
    } catch {}
    try {
        if (typeof XDomainRequest < "u" && !n && r)
            return new XDomainRequest
    } catch {}
    if (!t)
        try {
            return new ww[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")
        } catch {}
}
  , Fc = {
    exports: {}
};
const zt = Object.create(null);
zt.open = "0";
zt.close = "1";
zt.ping = "2";
zt.pong = "3";
zt.message = "4";
zt.upgrade = "5";
zt.noop = "6";
const Ah = Object.create(null);
Object.keys(zt).forEach(e=>{
    Ah[zt[e]] = e
}
);
const Ew = {
    type: "error",
    data: "parser error"
};
var Ph = {
    PACKET_TYPES: zt,
    PACKET_TYPES_REVERSE: Ah,
    ERROR_PACKET: Ew
};
const {PACKET_TYPES: Cw} = Ph
  , Tw = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]"
  , _w = typeof ArrayBuffer == "function"
  , Sw = e=>typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer
  , kw = ({type: e, data: t},n,r)=>Tw && t instanceof Blob ? n ? r(t) : Iu(t, r) : _w && (t instanceof ArrayBuffer || Sw(t)) ? n ? r(t) : Iu(new Blob([t]), r) : r(Cw[e] + (t || ""))
  , Iu = (e,t)=>{
    const n = new FileReader;
    return n.onload = function() {
        const r = n.result.split(",")[1];
        t("b" + r)
    }
    ,
    n.readAsDataURL(e)
}
;
var Rw = kw, Hs = {}, Lu;
function Aw() {
    return Lu || (Lu = 1,
    function(e) {
        Hs.encode = function(t) {
            var n = new Uint8Array(t), r, s = n.length, o = "";
            for (r = 0; r < s; r += 3)
                o += e[n[r] >> 2],
                o += e[(n[r] & 3) << 4 | n[r + 1] >> 4],
                o += e[(n[r + 1] & 15) << 2 | n[r + 2] >> 6],
                o += e[n[r + 2] & 63];
            return s % 3 === 2 ? o = o.substring(0, o.length - 1) + "=" : s % 3 === 1 && (o = o.substring(0, o.length - 2) + "=="),
            o
        }
        ,
        Hs.decode = function(t) {
            var n = t.length * .75, r = t.length, s, o = 0, i, a, l, u;
            t[t.length - 1] === "=" && (n--,
            t[t.length - 2] === "=" && n--);
            var c = new ArrayBuffer(n)
              , f = new Uint8Array(c);
            for (s = 0; s < r; s += 4)
                i = e.indexOf(t[s]),
                a = e.indexOf(t[s + 1]),
                l = e.indexOf(t[s + 2]),
                u = e.indexOf(t[s + 3]),
                f[o++] = i << 2 | a >> 4,
                f[o++] = (a & 15) << 4 | l >> 2,
                f[o++] = (l & 3) << 6 | u & 63;
            return c
        }
    }("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")),
    Hs
}
const {PACKET_TYPES_REVERSE: Ui, ERROR_PACKET: Pw} = Ph
  , Ow = typeof ArrayBuffer == "function";
let Ha;
Ow && (Ha = Aw());
const Iw = (e,t)=>{
    if (typeof e != "string")
        return {
            type: "message",
            data: Oh(e, t)
        };
    const n = e.charAt(0);
    return n === "b" ? {
        type: "message",
        data: Lw(e.substring(1), t)
    } : Ui[n] ? e.length > 1 ? {
        type: Ui[n],
        data: e.substring(1)
    } : {
        type: Ui[n]
    } : Pw
}
  , Lw = (e,t)=>{
    if (Ha) {
        const n = Ha.decode(e);
        return Oh(n, t)
    } else
        return {
            base64: !0,
            data: e
        }
}
  , Oh = (e,t)=>{
    switch (t) {
    case "blob":
        return e instanceof ArrayBuffer ? new Blob([e]) : e;
    case "arraybuffer":
    default:
        return e
    }
}
;
var Nw = Iw;
const Ih = Rw
  , Lh = Nw
  , Nh = ""
  , Mw = (e,t)=>{
    const n = e.length
      , r = new Array(n);
    let s = 0;
    e.forEach((o,i)=>{
        Ih(o, !1, a=>{
            r[i] = a,
            ++s === n && t(r.join(Nh))
        }
        )
    }
    )
}
  , Bw = (e,t)=>{
    const n = e.split(Nh)
      , r = [];
    for (let s = 0; s < n.length; s++) {
        const o = Lh(n[s], t);
        if (r.push(o),
        o.type === "error")
            break
    }
    return r
}
;
var vs = {
    protocol: 4,
    encodePacket: Ih,
    encodePayload: Mw,
    decodePacket: Lh,
    decodePayload: Bw
}, qi = {
    exports: {}
}, Nu;
function bs() {
    return Nu || (Nu = 1,
    function(e) {
        e.exports = t;
        function t(r) {
            if (r)
                return n(r)
        }
        function n(r) {
            for (var s in t.prototype)
                r[s] = t.prototype[s];
            return r
        }
        t.prototype.on = t.prototype.addEventListener = function(r, s) {
            return this._callbacks = this._callbacks || {},
            (this._callbacks["$" + r] = this._callbacks["$" + r] || []).push(s),
            this
        }
        ,
        t.prototype.once = function(r, s) {
            function o() {
                this.off(r, o),
                s.apply(this, arguments)
            }
            return o.fn = s,
            this.on(r, o),
            this
        }
        ,
        t.prototype.off = t.prototype.removeListener = t.prototype.removeAllListeners = t.prototype.removeEventListener = function(r, s) {
            if (this._callbacks = this._callbacks || {},
            arguments.length == 0)
                return this._callbacks = {},
                this;
            var o = this._callbacks["$" + r];
            if (!o)
                return this;
            if (arguments.length == 1)
                return delete this._callbacks["$" + r],
                this;
            for (var i, a = 0; a < o.length; a++)
                if (i = o[a],
                i === s || i.fn === s) {
                    o.splice(a, 1);
                    break
                }
            return o.length === 0 && delete this._callbacks["$" + r],
            this
        }
        ,
        t.prototype.emit = function(r) {
            this._callbacks = this._callbacks || {};
            for (var s = new Array(arguments.length - 1), o = this._callbacks["$" + r], i = 1; i < arguments.length; i++)
                s[i - 1] = arguments[i];
            if (o) {
                o = o.slice(0);
                for (var i = 0, a = o.length; i < a; ++i)
                    o[i].apply(this, s)
            }
            return this
        }
        ,
        t.prototype.listeners = function(r) {
            return this._callbacks = this._callbacks || {},
            this._callbacks["$" + r] || []
        }
        ,
        t.prototype.hasListeners = function(r) {
            return !!this.listeners(r).length
        }
    }(qi)),
    qi.exports
}
const Dw = vs
  , xw = bs()
  , Fw = Ft("engine.io-client:transport");
let Hw = class extends xw {
    constructor(t) {
        super(),
        this.opts = t,
        this.query = t.query,
        this.readyState = "",
        this.socket = t.socket
    }
    onError(t, n) {
        const r = new Error(t);
        return r.type = "TransportError",
        r.description = n,
        this.emit("error", r),
        this
    }
    open() {
        return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening",
        this.doOpen()),
        this
    }
    close() {
        return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(),
        this.onClose()),
        this
    }
    send(t) {
        this.readyState === "open" ? this.write(t) : Fw("transport is not open, discarding packets")
    }
    onOpen() {
        this.readyState = "open",
        this.writable = !0,
        this.emit("open")
    }
    onData(t) {
        const n = Dw.decodePacket(t, this.socket.binaryType);
        this.onPacket(n)
    }
    onPacket(t) {
        this.emit("packet", t)
    }
    onClose() {
        this.readyState = "closed",
        this.emit("close")
    }
}
;
var Hc = Hw
  , ws = {};
ws.encode = function(e) {
    var t = "";
    for (var n in e)
        e.hasOwnProperty(n) && (t.length && (t += "&"),
        t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
    return t
}
;
ws.decode = function(e) {
    for (var t = {}, n = e.split("&"), r = 0, s = n.length; r < s; r++) {
        var o = n[r].split("=");
        t[decodeURIComponent(o[0])] = decodeURIComponent(o[1])
    }
    return t
}
;
var Mh = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), go = 64, Bh = {}, Mu = 0, wn = 0, Bu;
function $a(e) {
    var t = "";
    do
        t = Mh[e % go] + t,
        e = Math.floor(e / go);
    while (e > 0);
    return t
}
function $w(e) {
    var t = 0;
    for (wn = 0; wn < e.length; wn++)
        t = t * go + Bh[e.charAt(wn)];
    return t
}
function $c() {
    var e = $a(+new Date);
    return e !== Bu ? (Mu = 0,
    Bu = e) : e + "." + $a(Mu++)
}
for (; wn < go; wn++)
    Bh[Mh[wn]] = wn;
$c.encode = $a;
$c.decode = $w;
var Dh = $c;
const jw = Hc
  , Vw = ws
  , Du = vs
  , Uw = Dh
  , Rt = Ft("engine.io-client:polling");
let qw = class extends jw {
    get name() {
        return "polling"
    }
    doOpen() {
        this.poll()
    }
    pause(t) {
        this.readyState = "pausing";
        const n = ()=>{
            Rt("paused"),
            this.readyState = "paused",
            t()
        }
        ;
        if (this.polling || !this.writable) {
            let r = 0;
            this.polling && (Rt("we are currently polling - waiting to pause"),
            r++,
            this.once("pollComplete", function() {
                Rt("pre-pause polling complete"),
                --r || n()
            })),
            this.writable || (Rt("we are currently writing - waiting to pause"),
            r++,
            this.once("drain", function() {
                Rt("pre-pause writing complete"),
                --r || n()
            }))
        } else
            n()
    }
    poll() {
        Rt("polling"),
        this.polling = !0,
        this.doPoll(),
        this.emit("poll")
    }
    onData(t) {
        Rt("polling got data %s", t);
        const n = r=>{
            if (this.readyState === "opening" && r.type === "open" && this.onOpen(),
            r.type === "close")
                return this.onClose(),
                !1;
            this.onPacket(r)
        }
        ;
        Du.decodePayload(t, this.socket.binaryType).forEach(n),
        this.readyState !== "closed" && (this.polling = !1,
        this.emit("pollComplete"),
        this.readyState === "open" ? this.poll() : Rt('ignoring poll - transport state "%s"', this.readyState))
    }
    doClose() {
        const t = ()=>{
            Rt("writing close packet"),
            this.write([{
                type: "close"
            }])
        }
        ;
        this.readyState === "open" ? (Rt("transport open - closing"),
        t()) : (Rt("transport not open - deferring close"),
        this.once("open", t))
    }
    write(t) {
        this.writable = !1,
        Du.encodePayload(t, n=>{
            this.doWrite(n, ()=>{
                this.writable = !0,
                this.emit("drain")
            }
            )
        }
        )
    }
    uri() {
        let t = this.query || {};
        const n = this.opts.secure ? "https" : "http";
        let r = "";
        this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = Uw()),
        !this.supportsBinary && !t.sid && (t.b64 = 1),
        t = Vw.encode(t),
        this.opts.port && (n === "https" && Number(this.opts.port) !== 443 || n === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port),
        t.length && (t = "?" + t);
        const s = this.opts.hostname.indexOf(":") !== -1;
        return n + "://" + (s ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + t
    }
}
;
var xh = qw
  , jc = {};
jc.pick = (e,...t)=>t.reduce((n,r)=>(e.hasOwnProperty(r) && (n[r] = e[r]),
n), {});
const Fh = Rh
  , Ww = xh
  , Kw = bs()
  , {pick: zw} = jc
  , Gw = zo
  , ja = Ft("engine.io-client:polling-xhr");
function xu() {}
const Jw = function() {
    return new Fh({
        xdomain: !1
    }).responseType != null
}();
let Xw = class extends Ww {
    constructor(t) {
        if (super(t),
        typeof location < "u") {
            const r = location.protocol === "https:";
            let s = location.port;
            s || (s = r ? 443 : 80),
            this.xd = typeof location < "u" && t.hostname !== location.hostname || s !== t.port,
            this.xs = t.secure !== r
        }
        const n = t && t.forceBase64;
        this.supportsBinary = Jw && !n
    }
    request(t={}) {
        return Object.assign(t, {
            xd: this.xd,
            xs: this.xs
        }, this.opts),
        new Nt(this.uri(),t)
    }
    doWrite(t, n) {
        const r = this.request({
            method: "POST",
            data: t
        });
        r.on("success", n),
        r.on("error", s=>{
            this.onError("xhr post error", s)
        }
        )
    }
    doPoll() {
        ja("xhr poll");
        const t = this.request();
        t.on("data", this.onData.bind(this)),
        t.on("error", n=>{
            this.onError("xhr poll error", n)
        }
        ),
        this.pollXhr = t
    }
}
;
class Nt extends Kw {
    constructor(t, n) {
        super(),
        this.opts = n,
        this.method = n.method || "GET",
        this.uri = t,
        this.async = n.async !== !1,
        this.data = n.data !== void 0 ? n.data : null,
        this.create()
    }
    create() {
        const t = zw(this.opts, "agent", "enablesXDR", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        t.xdomain = !!this.opts.xd,
        t.xscheme = !!this.opts.xs;
        const n = this.xhr = new Fh(t);
        try {
            ja("xhr open %s: %s", this.method, this.uri),
            n.open(this.method, this.uri, this.async);
            try {
                if (this.opts.extraHeaders) {
                    n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0);
                    for (let r in this.opts.extraHeaders)
                        this.opts.extraHeaders.hasOwnProperty(r) && n.setRequestHeader(r, this.opts.extraHeaders[r])
                }
            } catch {}
            if (this.method === "POST")
                try {
                    n.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                } catch {}
            try {
                n.setRequestHeader("Accept", "*/*")
            } catch {}
            "withCredentials"in n && (n.withCredentials = this.opts.withCredentials),
            this.opts.requestTimeout && (n.timeout = this.opts.requestTimeout),
            this.hasXDR() ? (n.onload = ()=>{
                this.onLoad()
            }
            ,
            n.onerror = ()=>{
                this.onError(n.responseText)
            }
            ) : n.onreadystatechange = ()=>{
                n.readyState === 4 && (n.status === 200 || n.status === 1223 ? this.onLoad() : setTimeout(()=>{
                    this.onError(typeof n.status == "number" ? n.status : 0)
                }
                , 0))
            }
            ,
            ja("xhr data %s", this.data),
            n.send(this.data)
        } catch (r) {
            setTimeout(()=>{
                this.onError(r)
            }
            , 0);
            return
        }
        typeof document < "u" && (this.index = Nt.requestsCount++,
        Nt.requests[this.index] = this)
    }
    onSuccess() {
        this.emit("success"),
        this.cleanup()
    }
    onData(t) {
        this.emit("data", t),
        this.onSuccess()
    }
    onError(t) {
        this.emit("error", t),
        this.cleanup(!0)
    }
    cleanup(t) {
        if (!(typeof this.xhr > "u" || this.xhr === null)) {
            if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = xu : this.xhr.onreadystatechange = xu,
            t)
                try {
                    this.xhr.abort()
                } catch {}
            typeof document < "u" && delete Nt.requests[this.index],
            this.xhr = null
        }
    }
    onLoad() {
        const t = this.xhr.responseText;
        t !== null && this.onData(t)
    }
    hasXDR() {
        return typeof XDomainRequest < "u" && !this.xs && this.enablesXDR
    }
    abort() {
        this.cleanup()
    }
}
Nt.requestsCount = 0;
Nt.requests = {};
if (typeof document < "u") {
    if (typeof attachEvent == "function")
        attachEvent("onunload", Fu);
    else if (typeof addEventListener == "function") {
        const e = "onpagehide"in Gw ? "pagehide" : "unload";
        addEventListener(e, Fu, !1)
    }
}
function Fu() {
    for (let e in Nt.requests)
        Nt.requests.hasOwnProperty(e) && Nt.requests[e].abort()
}
Fc.exports = Xw;
Fc.exports.Request = Nt;
var Yw = Fc.exports;
const Qw = xh
  , Hu = zo
  , Zw = /\n/g
  , eE = /\\n/g;
let $s;
class tE extends Qw {
    constructor(t) {
        super(t),
        this.query = this.query || {},
        $s || ($s = Hu.___eio = Hu.___eio || []),
        this.index = $s.length,
        $s.push(this.onData.bind(this)),
        this.query.j = this.index
    }
    get supportsBinary() {
        return !1
    }
    doClose() {
        this.script && (this.script.onerror = ()=>{}
        ,
        this.script.parentNode.removeChild(this.script),
        this.script = null),
        this.form && (this.form.parentNode.removeChild(this.form),
        this.form = null,
        this.iframe = null),
        super.doClose()
    }
    doPoll() {
        const t = document.createElement("script");
        this.script && (this.script.parentNode.removeChild(this.script),
        this.script = null),
        t.async = !0,
        t.src = this.uri(),
        t.onerror = s=>{
            this.onError("jsonp poll error", s)
        }
        ;
        const n = document.getElementsByTagName("script")[0];
        n ? n.parentNode.insertBefore(t, n) : (document.head || document.body).appendChild(t),
        this.script = t,
        typeof navigator < "u" && /gecko/i.test(navigator.userAgent) && setTimeout(function() {
            const s = document.createElement("iframe");
            document.body.appendChild(s),
            document.body.removeChild(s)
        }, 100)
    }
    doWrite(t, n) {
        let r;
        if (!this.form) {
            const i = document.createElement("form")
              , a = document.createElement("textarea")
              , l = this.iframeId = "eio_iframe_" + this.index;
            i.className = "socketio",
            i.style.position = "absolute",
            i.style.top = "-1000px",
            i.style.left = "-1000px",
            i.target = l,
            i.method = "POST",
            i.setAttribute("accept-charset", "utf-8"),
            a.name = "d",
            i.appendChild(a),
            document.body.appendChild(i),
            this.form = i,
            this.area = a
        }
        this.form.action = this.uri();
        function s() {
            o(),
            n()
        }
        const o = ()=>{
            if (this.iframe)
                try {
                    this.form.removeChild(this.iframe)
                } catch (i) {
                    this.onError("jsonp polling iframe removal error", i)
                }
            try {
                const i = '<iframe src="javascript:0" name="' + this.iframeId + '">';
                r = document.createElement(i)
            } catch {
                r = document.createElement("iframe"),
                r.name = this.iframeId,
                r.src = "javascript:0"
            }
            r.id = this.iframeId,
            this.form.appendChild(r),
            this.iframe = r
        }
        ;
        o(),
        t = t.replace(eE, `\\
`),
        this.area.value = t.replace(Zw, "\\n");
        try {
            this.form.submit()
        } catch {}
        this.iframe.attachEvent ? this.iframe.onreadystatechange = ()=>{
            this.iframe.readyState === "complete" && s()
        }
        : this.iframe.onload = s
    }
}
var nE = tE;
const $u = zo
  , rE = typeof Promise == "function" && typeof Promise.resolve == "function" ? t=>Promise.resolve().then(t) : t=>setTimeout(t, 0);
var sE = {
    WebSocket: $u.WebSocket || $u.MozWebSocket,
    usingBrowserWebSocket: !0,
    defaultBinaryType: "arraybuffer",
    nextTick: rE
};
const ju = Hc
  , oE = vs
  , iE = ws
  , aE = Dh
  , {pick: cE} = jc
  , {WebSocket: Lr, usingBrowserWebSocket: Wi, defaultBinaryType: lE, nextTick: uE} = sE
  , fE = Ft("engine.io-client:websocket")
  , Vu = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Vc extends ju {
    constructor(t) {
        super(t),
        this.supportsBinary = !t.forceBase64
    }
    get name() {
        return "websocket"
    }
    doOpen() {
        if (!this.check())
            return;
        const t = this.uri()
          , n = this.opts.protocols
          , r = Vu ? {} : cE(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
        try {
            this.ws = Wi && !Vu ? n ? new Lr(t,n) : new Lr(t) : new Lr(t,n,r)
        } catch (s) {
            return this.emit("error", s)
        }
        this.ws.binaryType = this.socket.binaryType || lE,
        this.addEventListeners()
    }
    addEventListeners() {
        this.ws.onopen = ()=>{
            this.opts.autoUnref && this.ws._socket.unref(),
            this.onOpen()
        }
        ,
        this.ws.onclose = this.onClose.bind(this),
        this.ws.onmessage = t=>this.onData(t.data),
        this.ws.onerror = t=>this.onError("websocket error", t)
    }
    write(t) {
        this.writable = !1;
        for (let n = 0; n < t.length; n++) {
            const r = t[n]
              , s = n === t.length - 1;
            oE.encodePacket(r, this.supportsBinary, o=>{
                const i = {};
                Wi || (r.options && (i.compress = r.options.compress),
                this.opts.perMessageDeflate && (typeof o == "string" ? Buffer.byteLength(o) : o.length) < this.opts.perMessageDeflate.threshold && (i.compress = !1));
                try {
                    Wi ? this.ws.send(o) : this.ws.send(o, i)
                } catch {
                    fE("websocket closed before onclose event")
                }
                s && uE(()=>{
                    this.writable = !0,
                    this.emit("drain")
                }
                )
            }
            )
        }
    }
    onClose() {
        ju.prototype.onClose.call(this)
    }
    doClose() {
        typeof this.ws < "u" && (this.ws.close(),
        this.ws = null)
    }
    uri() {
        let t = this.query || {};
        const n = this.opts.secure ? "wss" : "ws";
        let r = "";
        this.opts.port && (n === "wss" && Number(this.opts.port) !== 443 || n === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port),
        this.opts.timestampRequests && (t[this.opts.timestampParam] = aE()),
        this.supportsBinary || (t.b64 = 1),
        t = iE.encode(t),
        t.length && (t = "?" + t);
        const s = this.opts.hostname.indexOf(":") !== -1;
        return n + "://" + (s ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + t
    }
    check() {
        return !!Lr && !("__initialize"in Lr && this.name === Vc.prototype.name)
    }
}
var dE = Vc;
const hE = Rh
  , pE = Yw
  , mE = nE
  , gE = dE;
Ko.polling = yE;
Ko.websocket = gE;
function yE(e) {
    let t, n = !1, r = !1;
    const s = e.jsonp !== !1;
    if (typeof location < "u") {
        const o = location.protocol === "https:";
        let i = location.port;
        i || (i = o ? 443 : 80),
        n = e.hostname !== location.hostname || i !== e.port,
        r = e.secure !== o
    }
    if (e.xdomain = n,
    e.xscheme = r,
    t = new hE(e),
    "open"in t && !e.forceJSONP)
        return new pE(e);
    if (!s)
        throw new Error("JSONP disabled");
    return new mE(e)
}
const vE = Ko
  , bE = bs()
  , be = Ft("engine.io-client:socket")
  , Hh = vs
  , Uu = kh
  , wE = ws;
let Uc = class nr extends bE {
    constructor(t, n={}) {
        super(),
        t && typeof t == "object" && (n = t,
        t = null),
        t ? (t = Uu(t),
        n.hostname = t.host,
        n.secure = t.protocol === "https" || t.protocol === "wss",
        n.port = t.port,
        t.query && (n.query = t.query)) : n.host && (n.hostname = Uu(n.host).host),
        this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:",
        n.hostname && !n.port && (n.port = this.secure ? "443" : "80"),
        this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"),
        this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? 443 : 80),
        this.transports = n.transports || ["polling", "websocket"],
        this.readyState = "",
        this.writeBuffer = [],
        this.prevBufferLen = 0,
        this.opts = Object.assign({
            path: "/engine.io",
            agent: !1,
            withCredentials: !1,
            upgrade: !0,
            jsonp: !0,
            timestampParam: "t",
            rememberUpgrade: !1,
            rejectUnauthorized: !0,
            perMessageDeflate: {
                threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: !0
        }, n),
        this.opts.path = this.opts.path.replace(/\/$/, "") + "/",
        typeof this.opts.query == "string" && (this.opts.query = wE.decode(this.opts.query)),
        this.id = null,
        this.upgrades = null,
        this.pingInterval = null,
        this.pingTimeout = null,
        this.pingTimeoutTimer = null,
        typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && addEventListener("beforeunload", ()=>{
            this.transport && (this.transport.removeAllListeners(),
            this.transport.close())
        }
        , !1),
        this.hostname !== "localhost" && (this.offlineEventListener = ()=>{
            this.onClose("transport close")
        }
        ,
        addEventListener("offline", this.offlineEventListener, !1))),
        this.open()
    }
    createTransport(t) {
        be('creating transport "%s"', t);
        const n = EE(this.opts.query);
        n.EIO = Hh.protocol,
        n.transport = t,
        this.id && (n.sid = this.id);
        const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {
            query: n,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
        });
        return be("options: %j", r),
        new vE[t](r)
    }
    open() {
        let t;
        if (this.opts.rememberUpgrade && nr.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
            t = "websocket";
        else if (this.transports.length === 0) {
            setTimeout(()=>{
                this.emit("error", "No transports available")
            }
            , 0);
            return
        } else
            t = this.transports[0];
        this.readyState = "opening";
        try {
            t = this.createTransport(t)
        } catch (n) {
            be("error while creating transport: %s", n),
            this.transports.shift(),
            this.open();
            return
        }
        t.open(),
        this.setTransport(t)
    }
    setTransport(t) {
        be("setting transport %s", t.name),
        this.transport && (be("clearing existing transport %s", this.transport.name),
        this.transport.removeAllListeners()),
        this.transport = t,
        t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", ()=>{
            this.onClose("transport close")
        }
        )
    }
    probe(t) {
        be('probing transport "%s"', t);
        let n = this.createTransport(t, {
            probe: 1
        })
          , r = !1;
        nr.priorWebsocketSuccess = !1;
        const s = ()=>{
            r || (be('probe transport "%s" opened', t),
            n.send([{
                type: "ping",
                data: "probe"
            }]),
            n.once("packet", f=>{
                if (!r)
                    if (f.type === "pong" && f.data === "probe") {
                        if (be('probe transport "%s" pong', t),
                        this.upgrading = !0,
                        this.emit("upgrading", n),
                        !n)
                            return;
                        nr.priorWebsocketSuccess = n.name === "websocket",
                        be('pausing current transport "%s"', this.transport.name),
                        this.transport.pause(()=>{
                            r || this.readyState !== "closed" && (be("changing transport and sending upgrade packet"),
                            c(),
                            this.setTransport(n),
                            n.send([{
                                type: "upgrade"
                            }]),
                            this.emit("upgrade", n),
                            n = null,
                            this.upgrading = !1,
                            this.flush())
                        }
                        )
                    } else {
                        be('probe transport "%s" failed', t);
                        const d = new Error("probe error");
                        d.transport = n.name,
                        this.emit("upgradeError", d)
                    }
            }
            ))
        }
        ;
        function o() {
            r || (r = !0,
            c(),
            n.close(),
            n = null)
        }
        const i = f=>{
            const d = new Error("probe error: " + f);
            d.transport = n.name,
            o(),
            be('probe transport "%s" failed because of error: %s', t, f),
            this.emit("upgradeError", d)
        }
        ;
        function a() {
            i("transport closed")
        }
        function l() {
            i("socket closed")
        }
        function u(f) {
            n && f.name !== n.name && (be('"%s" works - aborting "%s"', f.name, n.name),
            o())
        }
        const c = ()=>{
            n.removeListener("open", s),
            n.removeListener("error", i),
            n.removeListener("close", a),
            this.removeListener("close", l),
            this.removeListener("upgrading", u)
        }
        ;
        n.once("open", s),
        n.once("error", i),
        n.once("close", a),
        this.once("close", l),
        this.once("upgrading", u),
        n.open()
    }
    onOpen() {
        if (be("socket open"),
        this.readyState = "open",
        nr.priorWebsocketSuccess = this.transport.name === "websocket",
        this.emit("open"),
        this.flush(),
        this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
            be("starting upgrade probes");
            let t = 0;
            const n = this.upgrades.length;
            for (; t < n; t++)
                this.probe(this.upgrades[t])
        }
    }
    onPacket(t) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
            switch (be('socket receive: type "%s", data "%s"', t.type, t.data),
            this.emit("packet", t),
            this.emit("heartbeat"),
            t.type) {
            case "open":
                this.onHandshake(JSON.parse(t.data));
                break;
            case "ping":
                this.resetPingTimeout(),
                this.sendPacket("pong"),
                this.emit("ping"),
                this.emit("pong");
                break;
            case "error":
                const n = new Error("server error");
                n.code = t.data,
                this.onError(n);
                break;
            case "message":
                this.emit("data", t.data),
                this.emit("message", t.data);
                break
            }
        else
            be('packet received with socket readyState "%s"', this.readyState)
    }
    onHandshake(t) {
        this.emit("handshake", t),
        this.id = t.sid,
        this.transport.query.sid = t.sid,
        this.upgrades = this.filterUpgrades(t.upgrades),
        this.pingInterval = t.pingInterval,
        this.pingTimeout = t.pingTimeout,
        this.onOpen(),
        this.readyState !== "closed" && this.resetPingTimeout()
    }
    resetPingTimeout() {
        clearTimeout(this.pingTimeoutTimer),
        this.pingTimeoutTimer = setTimeout(()=>{
            this.onClose("ping timeout")
        }
        , this.pingInterval + this.pingTimeout),
        this.opts.autoUnref && this.pingTimeoutTimer.unref()
    }
    onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen),
        this.prevBufferLen = 0,
        this.writeBuffer.length === 0 ? this.emit("drain") : this.flush()
    }
    flush() {
        this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length && (be("flushing %d packets in socket", this.writeBuffer.length),
        this.transport.send(this.writeBuffer),
        this.prevBufferLen = this.writeBuffer.length,
        this.emit("flush"))
    }
    write(t, n, r) {
        return this.sendPacket("message", t, n, r),
        this
    }
    send(t, n, r) {
        return this.sendPacket("message", t, n, r),
        this
    }
    sendPacket(t, n, r, s) {
        if (typeof n == "function" && (s = n,
        n = void 0),
        typeof r == "function" && (s = r,
        r = null),
        this.readyState === "closing" || this.readyState === "closed")
            return;
        r = r || {},
        r.compress = r.compress !== !1;
        const o = {
            type: t,
            data: n,
            options: r
        };
        this.emit("packetCreate", o),
        this.writeBuffer.push(o),
        s && this.once("flush", s),
        this.flush()
    }
    close() {
        const t = ()=>{
            this.onClose("forced close"),
            be("socket closing - telling transport to close"),
            this.transport.close()
        }
          , n = ()=>{
            this.removeListener("upgrade", n),
            this.removeListener("upgradeError", n),
            t()
        }
          , r = ()=>{
            this.once("upgrade", n),
            this.once("upgradeError", n)
        }
        ;
        return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing",
        this.writeBuffer.length ? this.once("drain", ()=>{
            this.upgrading ? r() : t()
        }
        ) : this.upgrading ? r() : t()),
        this
    }
    onError(t) {
        be("socket error %j", t),
        nr.priorWebsocketSuccess = !1,
        this.emit("error", t),
        this.onClose("transport error", t)
    }
    onClose(t, n) {
        (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (be('socket close with reason: "%s"', t),
        clearTimeout(this.pingIntervalTimer),
        clearTimeout(this.pingTimeoutTimer),
        this.transport.removeAllListeners("close"),
        this.transport.close(),
        this.transport.removeAllListeners(),
        typeof removeEventListener == "function" && removeEventListener("offline", this.offlineEventListener, !1),
        this.readyState = "closed",
        this.id = null,
        this.emit("close", t, n),
        this.writeBuffer = [],
        this.prevBufferLen = 0)
    }
    filterUpgrades(t) {
        const n = [];
        let r = 0;
        const s = t.length;
        for (; r < s; r++)
            ~this.transports.indexOf(t[r]) && n.push(t[r]);
        return n
    }
}
;
Uc.priorWebsocketSuccess = !1;
Uc.protocol = Hh.protocol;
function EE(e) {
    const t = {};
    for (let n in e)
        e.hasOwnProperty(n) && (t[n] = e[n]);
    return t
}
var CE = Uc;
const qc = CE;
Jn.exports = (e,t)=>new qc(e,t);
Jn.exports.Socket = qc;
Jn.exports.protocol = qc.protocol;
Jn.exports.Transport = Hc;
Jn.exports.transports = Ko;
Jn.exports.parser = vs;
var TE = Jn.exports, Es = {}, Ki = {}, On = {}, In = {}, qu;
function $h() {
    if (qu)
        return In;
    qu = 1,
    Object.defineProperty(In, "__esModule", {
        value: !0
    }),
    In.hasBinary = In.isBinary = void 0;
    const e = typeof ArrayBuffer == "function"
      , t = a=>typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(a) : a.buffer instanceof ArrayBuffer
      , n = Object.prototype.toString
      , r = typeof Blob == "function" || typeof Blob < "u" && n.call(Blob) === "[object BlobConstructor]"
      , s = typeof File == "function" || typeof File < "u" && n.call(File) === "[object FileConstructor]";
    function o(a) {
        return e && (a instanceof ArrayBuffer || t(a)) || r && a instanceof Blob || s && a instanceof File
    }
    In.isBinary = o;
    function i(a, l) {
        if (!a || typeof a != "object")
            return !1;
        if (Array.isArray(a)) {
            for (let u = 0, c = a.length; u < c; u++)
                if (i(a[u]))
                    return !0;
            return !1
        }
        if (o(a))
            return !0;
        if (a.toJSON && typeof a.toJSON == "function" && arguments.length === 1)
            return i(a.toJSON(), !0);
        for (const u in a)
            if (Object.prototype.hasOwnProperty.call(a, u) && i(a[u]))
                return !0;
        return !1
    }
    return In.hasBinary = i,
    In
}
var Wu;
function _E() {
    if (Wu)
        return On;
    Wu = 1,
    Object.defineProperty(On, "__esModule", {
        value: !0
    }),
    On.reconstructPacket = On.deconstructPacket = void 0;
    const e = $h();
    function t(o) {
        const i = []
          , a = o.data
          , l = o;
        return l.data = n(a, i),
        l.attachments = i.length,
        {
            packet: l,
            buffers: i
        }
    }
    On.deconstructPacket = t;
    function n(o, i) {
        if (!o)
            return o;
        if (e.isBinary(o)) {
            const a = {
                _placeholder: !0,
                num: i.length
            };
            return i.push(o),
            a
        } else if (Array.isArray(o)) {
            const a = new Array(o.length);
            for (let l = 0; l < o.length; l++)
                a[l] = n(o[l], i);
            return a
        } else if (typeof o == "object" && !(o instanceof Date)) {
            const a = {};
            for (const l in o)
                o.hasOwnProperty(l) && (a[l] = n(o[l], i));
            return a
        }
        return o
    }
    function r(o, i) {
        return o.data = s(o.data, i),
        o.attachments = void 0,
        o
    }
    On.reconstructPacket = r;
    function s(o, i) {
        if (!o)
            return o;
        if (o && o._placeholder === !0) {
            if (typeof o.num == "number" && o.num >= 0 && o.num < i.length)
                return i[o.num];
            throw new Error("illegal attachments")
        } else if (Array.isArray(o))
            for (let a = 0; a < o.length; a++)
                o[a] = s(o[a], i);
        else if (typeof o == "object")
            for (const a in o)
                o.hasOwnProperty(a) && (o[a] = s(o[a], i));
        return o
    }
    return On
}
var Ku;
function Wc() {
    return Ku || (Ku = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.Decoder = e.Encoder = e.PacketType = e.protocol = void 0;
        const t = bs()
          , n = _E()
          , r = $h()
          , s = Ft("socket.io-parser");
        e.protocol = 5;
        var o;
        (function(c) {
            c[c.CONNECT = 0] = "CONNECT",
            c[c.DISCONNECT = 1] = "DISCONNECT",
            c[c.EVENT = 2] = "EVENT",
            c[c.ACK = 3] = "ACK",
            c[c.CONNECT_ERROR = 4] = "CONNECT_ERROR",
            c[c.BINARY_EVENT = 5] = "BINARY_EVENT",
            c[c.BINARY_ACK = 6] = "BINARY_ACK"
        }
        )(o = e.PacketType || (e.PacketType = {}));
        class i {
            encode(f) {
                return s("encoding packet %j", f),
                (f.type === o.EVENT || f.type === o.ACK) && r.hasBinary(f) ? (f.type = f.type === o.EVENT ? o.BINARY_EVENT : o.BINARY_ACK,
                this.encodeAsBinary(f)) : [this.encodeAsString(f)]
            }
            encodeAsString(f) {
                let d = "" + f.type;
                return (f.type === o.BINARY_EVENT || f.type === o.BINARY_ACK) && (d += f.attachments + "-"),
                f.nsp && f.nsp !== "/" && (d += f.nsp + ","),
                f.id != null && (d += f.id),
                f.data != null && (d += JSON.stringify(f.data)),
                s("encoded %j as %s", f, d),
                d
            }
            encodeAsBinary(f) {
                const d = n.deconstructPacket(f)
                  , h = this.encodeAsString(d.packet)
                  , m = d.buffers;
                return m.unshift(h),
                m
            }
        }
        e.Encoder = i;
        class a extends t {
            constructor() {
                super()
            }
            add(f) {
                let d;
                if (typeof f == "string") {
                    if (this.reconstructor)
                        throw new Error("got plaintext data when reconstructing a packet");
                    d = this.decodeString(f),
                    d.type === o.BINARY_EVENT || d.type === o.BINARY_ACK ? (this.reconstructor = new u(d),
                    d.attachments === 0 && super.emit("decoded", d)) : super.emit("decoded", d)
                } else if (r.isBinary(f) || f.base64)
                    if (this.reconstructor)
                        d = this.reconstructor.takeBinaryData(f),
                        d && (this.reconstructor = null,
                        super.emit("decoded", d));
                    else
                        throw new Error("got binary data when not reconstructing a packet");
                else
                    throw new Error("Unknown type: " + f)
            }
            decodeString(f) {
                let d = 0;
                const h = {
                    type: Number(f.charAt(0))
                };
                if (o[h.type] === void 0)
                    throw new Error("unknown packet type " + h.type);
                if (h.type === o.BINARY_EVENT || h.type === o.BINARY_ACK) {
                    const v = d + 1;
                    for (; f.charAt(++d) !== "-" && d != f.length; )
                        ;
                    const T = f.substring(v, d);
                    if (T != Number(T) || f.charAt(d) !== "-")
                        throw new Error("Illegal attachments");
                    h.attachments = Number(T)
                }
                if (f.charAt(d + 1) === "/") {
                    const v = d + 1;
                    for (; ++d && !(f.charAt(d) === "," || d === f.length); )
                        ;
                    h.nsp = f.substring(v, d)
                } else
                    h.nsp = "/";
                const m = f.charAt(d + 1);
                if (m !== "" && Number(m) == m) {
                    const v = d + 1;
                    for (; ++d; ) {
                        const T = f.charAt(d);
                        if (T == null || Number(T) != T) {
                            --d;
                            break
                        }
                        if (d === f.length)
                            break
                    }
                    h.id = Number(f.substring(v, d + 1))
                }
                if (f.charAt(++d)) {
                    const v = l(f.substr(d));
                    if (a.isPayloadValid(h.type, v))
                        h.data = v;
                    else
                        throw new Error("invalid payload")
                }
                return s("decoded %s as %j", f, h),
                h
            }
            static isPayloadValid(f, d) {
                switch (f) {
                case o.CONNECT:
                    return typeof d == "object";
                case o.DISCONNECT:
                    return d === void 0;
                case o.CONNECT_ERROR:
                    return typeof d == "string" || typeof d == "object";
                case o.EVENT:
                case o.BINARY_EVENT:
                    return Array.isArray(d) && d.length > 0;
                case o.ACK:
                case o.BINARY_ACK:
                    return Array.isArray(d)
                }
            }
            destroy() {
                this.reconstructor && this.reconstructor.finishedReconstruction()
            }
        }
        e.Decoder = a;
        function l(c) {
            try {
                return JSON.parse(c)
            } catch {
                return !1
            }
        }
        class u {
            constructor(f) {
                this.packet = f,
                this.buffers = [],
                this.reconPack = f
            }
            takeBinaryData(f) {
                if (this.buffers.push(f),
                this.buffers.length === this.reconPack.attachments) {
                    const d = n.reconstructPacket(this.reconPack, this.buffers);
                    return this.finishedReconstruction(),
                    d
                }
                return null
            }
            finishedReconstruction() {
                this.reconPack = null,
                this.buffers = []
            }
        }
    }(Ki)),
    Ki
}
var Cs = {};
Object.defineProperty(Cs, "__esModule", {
    value: !0
});
Cs.on = void 0;
function SE(e, t, n) {
    return e.on(t, n),
    function() {
        e.off(t, n)
    }
}
Cs.on = SE;
var Ts = {};
Object.defineProperty(Ts, "__esModule", {
    value: !0
});
Ts.StrictEventEmitter = void 0;
const kE = bs();
class RE extends kE {
    on(t, n) {
        return super.on(t, n),
        this
    }
    once(t, n) {
        return super.once(t, n),
        this
    }
    emit(t, ...n) {
        return super.emit(t, ...n),
        this
    }
    emitReserved(t, ...n) {
        return super.emit(t, ...n),
        this
    }
    listeners(t) {
        return super.listeners(t)
    }
}
Ts.StrictEventEmitter = RE;
Object.defineProperty(Es, "__esModule", {
    value: !0
});
Es.Socket = void 0;
const vt = Wc()
  , js = Cs
  , AE = Ts
  , bt = Ft("socket.io-client:socket")
  , PE = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
});
let OE = class extends AE.StrictEventEmitter {
    constructor(t, n, r) {
        super(),
        this.receiveBuffer = [],
        this.sendBuffer = [],
        this.ids = 0,
        this.acks = {},
        this.flags = {},
        this.io = t,
        this.nsp = n,
        this.ids = 0,
        this.acks = {},
        this.receiveBuffer = [],
        this.sendBuffer = [],
        this.connected = !1,
        this.disconnected = !0,
        this.flags = {},
        r && r.auth && (this.auth = r.auth),
        this.io._autoConnect && this.open()
    }
    subEvents() {
        if (this.subs)
            return;
        const t = this.io;
        this.subs = [js.on(t, "open", this.onopen.bind(this)), js.on(t, "packet", this.onpacket.bind(this)), js.on(t, "error", this.onerror.bind(this)), js.on(t, "close", this.onclose.bind(this))]
    }
    get active() {
        return !!this.subs
    }
    connect() {
        return this.connected ? this : (this.subEvents(),
        this.io._reconnecting || this.io.open(),
        this.io._readyState === "open" && this.onopen(),
        this)
    }
    open() {
        return this.connect()
    }
    send(...t) {
        return t.unshift("message"),
        this.emit.apply(this, t),
        this
    }
    emit(t, ...n) {
        if (PE.hasOwnProperty(t))
            throw new Error('"' + t + '" is a reserved event name');
        n.unshift(t);
        const r = {
            type: vt.PacketType.EVENT,
            data: n
        };
        r.options = {},
        r.options.compress = this.flags.compress !== !1,
        typeof n[n.length - 1] == "function" && (bt("emitting packet with ack id %d", this.ids),
        this.acks[this.ids] = n.pop(),
        r.id = this.ids++);
        const s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        return this.flags.volatile && (!s || !this.connected) ? bt("discard packet as the transport is not currently writable") : this.connected ? this.packet(r) : this.sendBuffer.push(r),
        this.flags = {},
        this
    }
    packet(t) {
        t.nsp = this.nsp,
        this.io._packet(t)
    }
    onopen() {
        bt("transport is open - connecting"),
        typeof this.auth == "function" ? this.auth(t=>{
            this.packet({
                type: vt.PacketType.CONNECT,
                data: t
            })
        }
        ) : this.packet({
            type: vt.PacketType.CONNECT,
            data: this.auth
        })
    }
    onerror(t) {
        this.connected || this.emitReserved("connect_error", t)
    }
    onclose(t) {
        bt("close (%s)", t),
        this.connected = !1,
        this.disconnected = !0,
        delete this.id,
        this.emitReserved("disconnect", t)
    }
    onpacket(t) {
        if (t.nsp === this.nsp)
            switch (t.type) {
            case vt.PacketType.CONNECT:
                if (t.data && t.data.sid) {
                    const s = t.data.sid;
                    this.onconnect(s)
                } else
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                break;
            case vt.PacketType.EVENT:
                this.onevent(t);
                break;
            case vt.PacketType.BINARY_EVENT:
                this.onevent(t);
                break;
            case vt.PacketType.ACK:
                this.onack(t);
                break;
            case vt.PacketType.BINARY_ACK:
                this.onack(t);
                break;
            case vt.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case vt.PacketType.CONNECT_ERROR:
                const r = new Error(t.data.message);
                r.data = t.data.data,
                this.emitReserved("connect_error", r);
                break
            }
    }
    onevent(t) {
        const n = t.data || [];
        bt("emitting event %j", n),
        t.id != null && (bt("attaching ack callback to event"),
        n.push(this.ack(t.id))),
        this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n))
    }
    emitEvent(t) {
        if (this._anyListeners && this._anyListeners.length) {
            const n = this._anyListeners.slice();
            for (const r of n)
                r.apply(this, t)
        }
        super.emit.apply(this, t)
    }
    ack(t) {
        const n = this;
        let r = !1;
        return function(...s) {
            r || (r = !0,
            bt("sending ack %j", s),
            n.packet({
                type: vt.PacketType.ACK,
                id: t,
                data: s
            }))
        }
    }
    onack(t) {
        const n = this.acks[t.id];
        typeof n == "function" ? (bt("calling ack %s with %j", t.id, t.data),
        n.apply(this, t.data),
        delete this.acks[t.id]) : bt("bad ack %s", t.id)
    }
    onconnect(t) {
        bt("socket connected with id %s", t),
        this.id = t,
        this.connected = !0,
        this.disconnected = !1,
        this.emitBuffered(),
        this.emitReserved("connect")
    }
    emitBuffered() {
        this.receiveBuffer.forEach(t=>this.emitEvent(t)),
        this.receiveBuffer = [],
        this.sendBuffer.forEach(t=>this.packet(t)),
        this.sendBuffer = []
    }
    ondisconnect() {
        bt("server disconnect (%s)", this.nsp),
        this.destroy(),
        this.onclose("io server disconnect")
    }
    destroy() {
        this.subs && (this.subs.forEach(t=>t()),
        this.subs = void 0),
        this.io._destroy(this)
    }
    disconnect() {
        return this.connected && (bt("performing disconnect (%s)", this.nsp),
        this.packet({
            type: vt.PacketType.DISCONNECT
        })),
        this.destroy(),
        this.connected && this.onclose("io client disconnect"),
        this
    }
    close() {
        return this.disconnect()
    }
    compress(t) {
        return this.flags.compress = t,
        this
    }
    get volatile() {
        return this.flags.volatile = !0,
        this
    }
    onAny(t) {
        return this._anyListeners = this._anyListeners || [],
        this._anyListeners.push(t),
        this
    }
    prependAny(t) {
        return this._anyListeners = this._anyListeners || [],
        this._anyListeners.unshift(t),
        this
    }
    offAny(t) {
        if (!this._anyListeners)
            return this;
        if (t) {
            const n = this._anyListeners;
            for (let r = 0; r < n.length; r++)
                if (t === n[r])
                    return n.splice(r, 1),
                    this
        } else
            this._anyListeners = [];
        return this
    }
    listenersAny() {
        return this._anyListeners || []
    }
}
;
Es.Socket = OE;
var IE = Rr;
function Rr(e) {
    e = e || {},
    this.ms = e.min || 100,
    this.max = e.max || 1e4,
    this.factor = e.factor || 2,
    this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0,
    this.attempts = 0
}
Rr.prototype.duration = function() {
    var e = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var t = Math.random()
          , n = Math.floor(t * this.jitter * e);
        e = Math.floor(t * 10) & 1 ? e + n : e - n
    }
    return Math.min(e, this.max) | 0
}
;
Rr.prototype.reset = function() {
    this.attempts = 0
}
;
Rr.prototype.setMin = function(e) {
    this.ms = e
}
;
Rr.prototype.setMax = function(e) {
    this.max = e
}
;
Rr.prototype.setJitter = function(e) {
    this.jitter = e
}
;
Object.defineProperty(ts, "__esModule", {
    value: !0
});
ts.Manager = void 0;
const LE = TE
  , NE = Es
  , ME = Wc()
  , Ln = Cs
  , BE = IE
  , DE = Ts
  , Re = Ft("socket.io-client:manager");
class xE extends DE.StrictEventEmitter {
    constructor(t, n) {
        super(),
        this.nsps = {},
        this.subs = [],
        t && typeof t == "object" && (n = t,
        t = void 0),
        n = n || {},
        n.path = n.path || "/socket.io",
        this.opts = n,
        this.reconnection(n.reconnection !== !1),
        this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
        this.reconnectionDelay(n.reconnectionDelay || 1e3),
        this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
        this.randomizationFactor(n.randomizationFactor || .5),
        this.backoff = new BE({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
        }),
        this.timeout(n.timeout == null ? 2e4 : n.timeout),
        this._readyState = "closed",
        this.uri = t;
        const r = n.parser || ME;
        this.encoder = new r.Encoder,
        this.decoder = new r.Decoder,
        this._autoConnect = n.autoConnect !== !1,
        this._autoConnect && this.open()
    }
    reconnection(t) {
        return arguments.length ? (this._reconnection = !!t,
        this) : this._reconnection
    }
    reconnectionAttempts(t) {
        return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t,
        this)
    }
    reconnectionDelay(t) {
        var n;
        return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t,
        (n = this.backoff) === null || n === void 0 || n.setMin(t),
        this)
    }
    randomizationFactor(t) {
        var n;
        return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t,
        (n = this.backoff) === null || n === void 0 || n.setJitter(t),
        this)
    }
    reconnectionDelayMax(t) {
        var n;
        return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t,
        (n = this.backoff) === null || n === void 0 || n.setMax(t),
        this)
    }
    timeout(t) {
        return arguments.length ? (this._timeout = t,
        this) : this._timeout
    }
    maybeReconnectOnOpen() {
        !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
    }
    open(t) {
        if (Re("readyState %s", this._readyState),
        ~this._readyState.indexOf("open"))
            return this;
        Re("opening %s", this.uri),
        this.engine = LE(this.uri, this.opts);
        const n = this.engine
          , r = this;
        this._readyState = "opening",
        this.skipReconnect = !1;
        const s = Ln.on(n, "open", function() {
            r.onopen(),
            t && t()
        })
          , o = Ln.on(n, "error", i=>{
            Re("error"),
            r.cleanup(),
            r._readyState = "closed",
            this.emitReserved("error", i),
            t ? t(i) : r.maybeReconnectOnOpen()
        }
        );
        if (this._timeout !== !1) {
            const i = this._timeout;
            Re("connect attempt will timeout after %d", i),
            i === 0 && s();
            const a = setTimeout(()=>{
                Re("connect attempt timed out after %d", i),
                s(),
                n.close(),
                n.emit("error", new Error("timeout"))
            }
            , i);
            this.opts.autoUnref && a.unref(),
            this.subs.push(function() {
                clearTimeout(a)
            })
        }
        return this.subs.push(s),
        this.subs.push(o),
        this
    }
    connect(t) {
        return this.open(t)
    }
    onopen() {
        Re("open"),
        this.cleanup(),
        this._readyState = "open",
        this.emitReserved("open");
        const t = this.engine;
        this.subs.push(Ln.on(t, "ping", this.onping.bind(this)), Ln.on(t, "data", this.ondata.bind(this)), Ln.on(t, "error", this.onerror.bind(this)), Ln.on(t, "close", this.onclose.bind(this)), Ln.on(this.decoder, "decoded", this.ondecoded.bind(this)))
    }
    onping() {
        this.emitReserved("ping")
    }
    ondata(t) {
        this.decoder.add(t)
    }
    ondecoded(t) {
        this.emitReserved("packet", t)
    }
    onerror(t) {
        Re("error", t),
        this.emitReserved("error", t)
    }
    socket(t, n) {
        let r = this.nsps[t];
        return r || (r = new NE.Socket(this,t,n),
        this.nsps[t] = r),
        r
    }
    _destroy(t) {
        const n = Object.keys(this.nsps);
        for (const r of n)
            if (this.nsps[r].active) {
                Re("socket %s is still active, skipping close", r);
                return
            }
        this._close()
    }
    _packet(t) {
        Re("writing packet %j", t);
        const n = this.encoder.encode(t);
        for (let r = 0; r < n.length; r++)
            this.engine.write(n[r], t.options)
    }
    cleanup() {
        Re("cleanup"),
        this.subs.forEach(t=>t()),
        this.subs.length = 0,
        this.decoder.destroy()
    }
    _close() {
        Re("disconnect"),
        this.skipReconnect = !0,
        this._reconnecting = !1,
        this._readyState === "opening" && this.cleanup(),
        this.backoff.reset(),
        this._readyState = "closed",
        this.engine && this.engine.close()
    }
    disconnect() {
        return this._close()
    }
    onclose(t) {
        Re("onclose"),
        this.cleanup(),
        this.backoff.reset(),
        this._readyState = "closed",
        this.emitReserved("close", t),
        this._reconnection && !this.skipReconnect && this.reconnect()
    }
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const t = this;
        if (this.backoff.attempts >= this._reconnectionAttempts)
            Re("reconnect failed"),
            this.backoff.reset(),
            this.emitReserved("reconnect_failed"),
            this._reconnecting = !1;
        else {
            const n = this.backoff.duration();
            Re("will wait %dms before reconnect attempt", n),
            this._reconnecting = !0;
            const r = setTimeout(()=>{
                t.skipReconnect || (Re("attempting reconnect"),
                this.emitReserved("reconnect_attempt", t.backoff.attempts),
                !t.skipReconnect && t.open(s=>{
                    s ? (Re("reconnect attempt error"),
                    t._reconnecting = !1,
                    t.reconnect(),
                    this.emitReserved("reconnect_error", s)) : (Re("reconnect success"),
                    t.onreconnect())
                }
                ))
            }
            , n);
            this.opts.autoUnref && r.unref(),
            this.subs.push(function() {
                clearTimeout(r)
            })
        }
    }
    onreconnect() {
        const t = this.backoff.attempts;
        this._reconnecting = !1,
        this.backoff.reset(),
        this.emitReserved("reconnect", t)
    }
}
ts.Manager = xE;
(function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.io = t.Socket = t.Manager = t.protocol = void 0;
    const n = Wo
      , r = ts
      , s = Ft("socket.io-client");
    e.exports = t = i;
    const o = t.managers = {};
    function i(c, f) {
        typeof c == "object" && (f = c,
        c = void 0),
        f = f || {};
        const d = n.url(c, f.path || "/socket.io")
          , h = d.source
          , m = d.id
          , v = d.path
          , T = o[m] && v in o[m].nsps
          , k = f.forceNew || f["force new connection"] || f.multiplex === !1 || T;
        let b;
        return k ? (s("ignoring socket cache for %s", h),
        b = new r.Manager(h,f)) : (o[m] || (s("new io instance for %s", h),
        o[m] = new r.Manager(h,f)),
        b = o[m]),
        d.query && !f.query && (f.query = d.queryKey),
        b.socket(d.path, f)
    }
    t.io = i;
    var a = Wc();
    Object.defineProperty(t, "protocol", {
        enumerable: !0,
        get: function() {
            return a.protocol
        }
    }),
    t.connect = i;
    var l = ts;
    Object.defineProperty(t, "Manager", {
        enumerable: !0,
        get: function() {
            return l.Manager
        }
    });
    var u = Es;
    Object.defineProperty(t, "Socket", {
        enumerable: !0,
        get: function() {
            return u.Socket
        }
    }),
    t.default = i
}
)(Da, Da.exports);
var FE = Da.exports;
const yo = xc(FE);
yo.Manager;
yo.Socket;
var Kc = {
    exports: {}
};
function zc() {}
zc.prototype = {
    on: function(e, t, n) {
        var r = this.e || (this.e = {});
        return (r[e] || (r[e] = [])).push({
            fn: t,
            ctx: n
        }),
        this
    },
    once: function(e, t, n) {
        var r = this;
        function s() {
            r.off(e, s),
            t.apply(n, arguments)
        }
        return s._ = t,
        this.on(e, s, n)
    },
    emit: function(e) {
        var t = [].slice.call(arguments, 1)
          , n = ((this.e || (this.e = {}))[e] || []).slice()
          , r = 0
          , s = n.length;
        for (r; r < s; r++)
            n[r].fn.apply(n[r].ctx, t);
        return this
    },
    off: function(e, t) {
        var n = this.e || (this.e = {})
          , r = n[e]
          , s = [];
        if (r && t)
            for (var o = 0, i = r.length; o < i; o++)
                r[o].fn !== t && r[o].fn._ !== t && s.push(r[o]);
        return s.length ? n[e] = s : delete n[e],
        this
    }
};
Kc.exports = zc;
Kc.exports.TinyEmitter = zc;
var HE = Kc.exports
  , $E = HE
  , jE = new $E;
const Vs = xc(jE)
  , Q = mw("nuxt-socket-io")
  , jh = e=>e && e.constructor.name === "RefImpl"
  , VE = (e,t)=>new Promise((n,r)=>{
    t.timer = setTimeout(()=>n(!0), e),
    t.abort = ()=>{
        clearTimeout(t.timer),
        r(new Error("AbortError"))
    }
}
)
  , Ys = {}
  , hr = {
    SET_API(e, {label: t, api: n}) {
        e.ioApis[t] = n
    },
    SET_CLIENT_API(e, {label: t="clientAPI", ...n}) {
        e.clientApis[t] = n
    },
    SET_EMIT_ERRORS(e, {label: t, emitEvt: n, err: r}) {
        e.emitErrors[t] === void 0 && (e.emitErrors[t] = {}),
        e.emitErrors[t][n] === void 0 && (e.emitErrors[t][n] = []),
        e.emitErrors[t][n].push(r)
    },
    SET_EMIT_TIMEOUT(e, {label: t, emitTimeout: n}) {
        e.emitTimeouts[t] || (e.emitTimeouts[t] = {}),
        e.emitTimeouts[t] = n
    }
}
  , Vh = ()=>Sh("$io", ()=>({}))
  , ns = ()=>Sh("$nuxtSocket", ()=>({
    clientApis: {},
    ioApis: {},
    emitErrors: {},
    emitTimeouts: {}
}));
async function Us({label: e="", socket: t=Ys[e], evt: n, msg: r, emitTimeout: s=ns().value.emitTimeouts[e], noAck: o=!1}) {
    const i = ns().value;
    if (Q("$nuxtSocket.emit", e, n),
    t === void 0)
        throw new Error("socket instance required. Please provide a valid socket label or socket instance");
    Ce.emitP(t),
    Q(`Emitting ${n} with msg`, r);
    const a = {}
      , l = [t.emitP(n, r)];
    if (o)
        return;
    s && l.push(Ce.emitTimeout({
        emitTimeout: s,
        timerObj: a
    }).catch(d=>{
        if (e !== void 0 && e !== "")
            hr.SET_EMIT_ERRORS(i, {
                label: e,
                emitEvt: n,
                err: d
            }),
            Q(`[nuxt-socket-io]: ${e} Emit error occurred and logged to vuex `, d);
        else
            throw new Error(d.message)
    }
    ));
    const u = await Promise.race(l);
    Q("Emitter response rxd", {
        evt: n,
        resp: u
    }),
    a.abort && a.abort();
    const {emitError: c, ...f} = u || {};
    if (c !== void 0) {
        const d = {
            message: c,
            emitEvt: n,
            errorDetails: f,
            timestamp: Date.now()
        };
        if (Q("Emit error occurred", d),
        e !== void 0 && e !== "")
            Q(`[nuxt-socket-io]: ${e} Emit error ${d.message} occurred and logged to vuex `, d),
            hr.SET_EMIT_ERRORS(i, {
                label: e,
                emitEvt: n,
                err: d
            });
        else
            throw new Error(d.message)
    } else
        return u
}
let qt, zi;
function UE(e) {
    return e.replace(/[_\-\s](.)/g, function(t) {
        return t.toUpperCase()
    }).replace(/[-_\s]/g, "").replace(/^(.)/, function(t) {
        return t.toLowerCase()
    }).replace(/[^\w\s]/gi, "")
}
function qE(e, t) {
    return t.split(".").reduce((r,s)=>{
        if (r !== void 0 && r[s] !== void 0)
            return r[s]
    }
    , e) !== void 0
}
function Gi(e, t) {
    let n, r, s, o, i, a;
    if (typeof e == "string") {
        let l = [], u;
        const c = e.trim().split(/\s*\]\s*/);
        c.length > 1 ? (s = c[0],
        l = c[1].split(/\s*\[\s*/)) : l = c[0].split(/\s*\[\s*/),
        [u,a] = l,
        u.includes("-->") ? [n,r] = u.split(/\s*-->\s*/) : u.includes("<--") ? [n,r] = u.split(/\s*<--\s*/) : n = u,
        t === "emitter" ? [o,i] = n.split(/\s*\+\s*/) : r === void 0 && (r = n)
    }
    return {
        pre: s,
        post: a,
        evt: n,
        mapTo: r,
        emitEvt: o,
        msgLabel: i
    }
}
function WE(e, t) {
    let n;
    return t !== void 0 && (e[t] !== void 0 ? typeof e[t] == "object" ? (n = Array.isArray(e[t]) ? [] : {},
    Object.assign(n, e[t])) : n = e[t] : qt(`prop or data item "${t}" not defined`),
    Q(`assigned ${t} to ${n}`)),
    n
}
function zu(e, t, n) {
    t !== void 0 && (e[t] !== void 0 ? typeof e[t] != "function" && (jh(e[t]) ? e[t].value = n : e[t] = n,
    Q(`assigned ${n} to ${t}`)) : qt(`${t} not defined on instance`))
}
async function er(e, t, n) {
    if (t !== void 0) {
        if (e[t])
            return await e[t](n);
        qt(`method ${t} not defined`)
    }
}
function Ji(e) {
    return e && Array.isArray(e) && e.length > 0
}
const Ce = {
    clientApiEvents({ctx: e, socket: t, api: n}) {
        const {evts: r} = n;
        Object.entries(r).forEach(([s,o])=>{
            const {data: i} = o
              , a = s + "Emit";
            e[s] !== void 0 && i !== void 0 && (Object.entries(i).forEach(([l,u])=>{
                e.$set(e[s], l, u)
            }
            ),
            Q("Initialized data for", s, i)),
            e[a] === void 0 && (e[a] = async l=>{
                const {label: u, ack: c, ...f} = l || {}
                  , d = u || n.label
                  , h = Object.keys(f).length > 0 ? f : {
                    ...e[s]
                };
                if (h.method = a,
                c)
                    return await Us({
                        label: d,
                        socket: t,
                        evt: s,
                        msg: h
                    });
                Us({
                    label: d,
                    socket: t,
                    evt: s,
                    msg: h,
                    noAck: !0
                })
            }
            ,
            Q("Registered clientAPI method", a))
        }
        )
    },
    clientApiMethods({ctx: e, socket: t, api: n}) {
        const {methods: r} = n
          , s = Object.assign({}, r, {
            getAPI: {}
        });
        Object.entries(s).forEach(([o,i])=>{
            t.hasListeners(o) && qt(`evt ${o} already has a listener registered`),
            t.on(o, async(a,l)=>{
                if (o === "getAPI")
                    l && l(n);
                else if (e[o] !== void 0) {
                    a.method = o;
                    const u = await e[o](a);
                    l && l(u)
                } else
                    l && l({
                        emitErr: "notImplemented",
                        msg: `Client has not yet implemented method (${o})`
                    })
            }
            ),
            Q(`registered client api method ${o}`),
            o !== "getAPI" && e[o] === void 0 && qt(`client api method ${o} has not been defined. Either update the client api or define the method so it can be used by callers`)
        }
        )
    },
    clientAPI({ctx: e, socket: t, clientAPI: n}) {
        const r = ns().value;
        n.methods && Ce.clientApiMethods({
            ctx: e,
            socket: t,
            api: n
        }),
        n.evts && Ce.clientApiEvents({
            ctx: e,
            socket: t,
            api: n
        }),
        hr.SET_CLIENT_API(r, n),
        Q("clientAPI registered", n)
    },
    serverApiEvents({ctx: e, socket: t, api: n, label: r, ioDataProp: s, apiIgnoreEvts: o}) {
        const {evts: i} = n;
        Object.entries(i).forEach(([a,l])=>{
            const {methods: u=[], data: c} = l;
            if (o.includes(a)) {
                Q(`Event ${a} is in ignore list ("apiIgnoreEvts"), not registering.`);
                return
            }
            if (t.hasListeners(a) && qt(`evt ${a} already has a listener registered`),
            u.length === 0) {
                let f = c;
                typeof f == "object" && (f = Array.isArray(c) ? [] : {}),
                e.$set(e[s], a, f)
            } else
                u.forEach(f=>{
                    e[s][f] === void 0 && e.$set(e[s], f, {}),
                    e.$set(e[s][f], a, Array.isArray(c) ? [] : {})
                }
                );
            t.on(a, (f,d)=>{
                Q(`serverAPI event ${a} rxd with msg`, f);
                const {method: h, data: m} = f;
                h !== void 0 ? (e[s][h] === void 0 && e.$set(e[s], h, {}),
                e.$set(e[s][h], a, m)) : e.$set(e[s], a, m),
                d && d({
                    ack: "ok"
                })
            }
            ),
            Q(`Registered listener for ${a} on ${r}`)
        }
        )
    },
    serverApiMethods({ctx: e, socket: t, api: n, label: r, ioApiProp: s, ioDataProp: o}) {
        Object.entries(n.methods).forEach(([i,a])=>{
            const {msg: l, resp: u} = a;
            e[o][i] === void 0 && (e.$set(e[o], i, {}),
            l !== void 0 && e.$set(e[o][i], "msg", {
                ...l
            }),
            u !== void 0 && e.$set(e[o][i], "resp", Array.isArray(u) ? [] : {})),
            e[s][i] = async c=>{
                const f = i
                  , d = c !== void 0 ? c : {
                    ...e[o][i].msg
                };
                Q(`${s}:${r}: Emitting ${f} with ${d}`);
                const h = await Us({
                    label: r,
                    socket: t,
                    evt: f,
                    msg: d
                });
                return e[o][i].resp = h,
                h
            }
        }
        )
    },
    async serverAPI({ctx: e, socket: t, label: n, apiIgnoreEvts: r, ioApiProp: s, ioDataProp: o, serverAPI: i, clientAPI: a={}}) {
        const l = ns().value;
        if (e[s] === void 0) {
            console.error(`[nuxt-socket-io]: ${s} needs to be defined in the current context for serverAPI registration (vue requirement)`);
            return
        }
        const u = i.label || n;
        Q("register api for", u);
        const c = l.ioApis[u] || {}
          , f = await Us({
            label: u,
            socket: t,
            evt: i.evt || "getAPI",
            msg: i.data || {}
        });
        a.label === f.label && parseFloat(a.version) === parseFloat(f.version) ? (Object.assign(c, a),
        hr.SET_API(l, {
            label: u,
            api: c
        }),
        Q(`api for ${u} registered`, c)) : parseFloat(c.version) !== parseFloat(f.version) && (Object.assign(c, f),
        hr.SET_API(l, {
            label: u,
            api: c
        }),
        Q(`api for ${u} registered`, c)),
        e.$set(e, s, c),
        c.methods !== void 0 && (Ce.serverApiMethods({
            ctx: e,
            socket: t,
            api: c,
            label: n,
            ioApiProp: s,
            ioDataProp: o
        }),
        Q(`Attached methods for ${n} to ${s}`, Object.keys(c.methods))),
        c.evts !== void 0 && (Ce.serverApiEvents({
            ctx: e,
            socket: t,
            api: c,
            label: n,
            ioDataProp: o,
            apiIgnoreEvts: r
        }),
        Q(`registered evts for ${n} to ${s}`)),
        e.$set(e[s], "ready", !0),
        Q("ioApi", e[s])
    },
    emitErrors({ctx: e, err: t, emitEvt: n, emitErrorsProp: r}) {
        e[r][n] === void 0 && (e[r][n] = []),
        e[r][n].push(t)
    },
    async emitTimeout({ctx: e, emitEvt: t, emitErrorsProp: n, emitTimeout: r, timerObj: s}) {
        if (!await VE(r, s).catch(()=>{}
        ))
            return;
        const i = {
            message: "emitTimeout",
            emitEvt: t,
            emitTimeout: r,
            hint: [`1) Is ${t} supported on the backend?`, `2) Is emitTimeout ${r} ms too small?`].join(`\r
`),
            timestamp: Date.now()
        };
        if (Q("emitEvt timed out", i),
        e !== void 0 && typeof e[n] == "object")
            Ce.emitErrors({
                ctx: e,
                err: i,
                emitEvt: t,
                emitErrorsProp: n
            });
        else
            throw i
    },
    emitBacks({ctx: e, socket: t, entries: n}) {
        n.forEach(r=>{
            const {pre: s, post: o, evt: i, mapTo: a} = Gi(r, "emitBack");
            qE(e, a) ? (Q("registered local emitBack", {
                mapTo: a
            }),
            e.$watch(a, async function(l, u) {
                if (Q("local data changed", i, l),
                await er(e, s, {
                    data: l,
                    oldData: u
                }) === !1)
                    return;
                Q("Emitting back:", {
                    evt: i,
                    mapTo: a,
                    data: l
                });
                const f = t.emitP(i, {
                    data: l
                });
                if (o === void 0)
                    return;
                const d = await f;
                return er(e, o, d),
                d
            })) : qt(`Specified emitback ${a} is not defined in component`)
        }
        )
    },
    emitters({ctx: e, socket: t, entries: n, emitTimeout: r, emitErrorsProp: s}) {
        n.forEach(o=>{
            const {pre: i, post: a, mapTo: l, emitEvt: u, msgLabel: c} = Gi(o, "emitter");
            e[u] = async function(f=WE(e, c)) {
                if (Q("Emit evt", {
                    emitEvt: u,
                    msg: f
                }),
                await er(e, i, f) === !1)
                    return;
                const h = [t.emitP(u, f)]
                  , m = {};
                r && h.push(Ce.emitTimeout({
                    ctx: e,
                    emitEvt: u,
                    emitErrorsProp: s,
                    emitTimeout: r,
                    timerObj: m
                }));
                const v = await Promise.race(h);
                Q("Emitter response rxd", {
                    emitEvt: u,
                    resp: v
                }),
                m.abort && m.abort();
                const {emitError: T, ...k} = v || {};
                if (T !== void 0) {
                    const b = {
                        message: T,
                        emitEvt: u,
                        errorDetails: k,
                        timestamp: Date.now()
                    };
                    if (Q("Emit error occurred", b),
                    typeof e[s] == "object")
                        Ce.emitErrors({
                            ctx: e,
                            err: b,
                            emitEvt: u,
                            emitErrorsProp: s
                        });
                    else
                        throw b
                } else
                    return zu(e.$data || e, l, v),
                    er(e, a, v),
                    v
            }
            ,
            Q("Emitter created", {
                emitter: u
            })
        }
        )
    },
    listeners({ctx: e, socket: t, entries: n}) {
        n.forEach(r=>{
            const {pre: s, post: o, evt: i, mapTo: a} = Gi(r);
            Q("Registered local listener", i),
            t.on(i, async l=>{
                Q("Local listener received data", {
                    evt: i,
                    resp: l
                }),
                await er(e, s),
                zu(e.$data || e, a, l),
                er(e, o, l)
            }
            )
        }
        )
    },
    namespace({ctx: e, namespaceCfg: t, socket: n, emitTimeout: r, emitErrorsProp: s}) {
        const {emitters: o=[], listeners: i=[], emitBacks: a=[]} = t;
        Object.entries({
            emitters: o,
            listeners: i,
            emitBacks: a
        }).forEach(([u,c])=>{
            Array.isArray(c) ? Ce[u]({
                ctx: e,
                socket: n,
                entries: c,
                emitTimeout: r,
                emitErrorsProp: s
            }) : qt(`[nuxt-socket-io]: ${u} needs to be an array in namespace config`)
        }
        )
    },
    iox({stateOpts: e, socket: t, useSocket: n}) {
        Q("register.iox", e);
        const r = Vh().value
          , s = /\s*<*-->*\s*/
          , o = /\s*[^<]-->\s*/
          , i = /\s*<--[^>]\s*/;
        e.forEach(a=>{
            let[l,u] = a.split(s), c;
            u === void 0 && (u = l);
            const f = u.split("/");
            f.length > 1 && (c = f[0],
            r[c] === void 0 && (r[c] = {}),
            u = f[1]);
            function d() {
                t.on(l, m=>{
                    Q("iox evt received", l, m),
                    c ? (r[c][u] = m,
                    Q("iox evt saved", l, `${c}/${u}`)) : (r[u] = m,
                    Q("iox evt saved", l, u))
                }
                )
            }
            function h() {
                const m = c ? `${c}/${u}` : u;
                n.registeredWatchers.includes(m) || (mt(()=>c ? r[c][u] : r[u], (v,T)=>{
                    t.emit(l, v)
                }
                ),
                n.registeredWatchers.push(m))
            }
            o.test(a) ? d() : (i.test(a) || d(),
            h())
        }
        )
    },
    socketStatus(e, t, n, r) {
        const s = {
            connectUrl: n
        };
        ["connect_error", "connect_timeout", "reconnect", "reconnect_attempt", "reconnect_error", "reconnect_failed", "ping", "pong"].forEach(i=>{
            const a = UE(i);
            s[a] = "",
            t.io.on(i, l=>{
                Object.assign(e[r], {
                    [a]: l
                })
            }
            )
        }
        ),
        Object.assign(e, {
            [r]: s
        })
    },
    teardown({ctx: e, socket: t, useSocket: n}) {
        e.$once("closeSockets", function() {
            Q("closing socket id=" + t.id),
            t.removeAllListeners(),
            t.close()
        }),
        e.registeredTeardown || (e.onComponentDestroy = e.$destroy || e.onUnmounted,
        Q("teardown enabled for socket", {
            name: n.name
        }),
        e.$destroy = function() {
            Q("component destroyed, closing socket(s)", {
                name: n.name,
                url: n.url
            }),
            n.registeredVuexListeners = [],
            e.$emit("closeSockets"),
            e.onComponentDestroy && e.onComponentDestroy()
        }
        ,
        e.onUnmounted && (e.onUnmounted = e.$destroy),
        e.registeredTeardown = !0),
        t.on("disconnect", ()=>{
            Q("server disconnected", {
                name: n.name,
                url: n.url
            }),
            t.close()
        }
        )
    },
    stubs(e) {
        "$on"in e || (e.$once = (...t)=>Vs.once(...t),
        e.$on = (...t)=>Vs.on(...t),
        e.$off = (...t)=>Vs.off(...t),
        e.$$emit = (...t)=>Vs.emit(...t)),
        "$set"in e || (e.$set = (t,n,r)=>{
            jh(t[n]) ? t[n].value = r : t[n] = r
        }
        ),
        "$watch"in e || (e.$watch = (t,n)=>{}
        )
    },
    emitP(e) {
        e.emitP = (t,n)=>new Promise(r=>e.emit(t, n, r))
    },
    onceP(e) {
        e.onceP = t=>new Promise(n=>e.once(t, n))
    }
};
function KE(e) {
    const {name: t, channel: n="", statusProp: r="socketStatus", persist: s, teardown: o=!s, emitTimeout: i, emitErrorsProp: a="emitErrors", ioApiProp: l="ioApi", ioDataProp: u="ioData", apiIgnoreEvts: c=[], serverAPI: f, clientAPI: d, vuex: h, namespaceCfg: m, ...v} = e
      , {$config: T} = this
      , {nuxtSocketIO: k} = T.public
      , b = ns().value
      , y = {
        ...k
    };
    T.io && (Object.assign(y, T.io),
    y.sockets = Ji(k.sockets) ? k.sockets : [],
    Ji(T.io.sockets) && T.io.sockets.forEach(x=>{
        y.sockets.find(({name: q})=>q === x.name) === void 0 && y.sockets.push(x)
    }
    ));
    const w = {
        ...y,
        ...e
    }
      , {sockets: E, warnings: _=!0, info: I=!0} = w;
    if (qt = ()=>{}
    ,
    zi = ()=>{}
    ,
    !Ji(E))
        throw new Error(`Please configure sockets if planning to use nuxt-socket-io: \r
 [{name: '', url: ''}]`);
    Ce.stubs(this);
    let C = null;
    t ? C = E.find(x=>x.name === t) : C = E.find(x=>x.default === !0),
    C || (C = E[0]),
    C.name || (C.name = "dflt"),
    C.url || qt(`URL not defined for socket "${C.name}". Defaulting to "window.location"`),
    C.registeredWatchers || (C.registeredWatchers = []),
    C.registeredVuexListeners || (C.registeredVuexListeners = []);
    let {url: R} = C;
    R && (R += n);
    const {namespaces: L={}} = C;
    let H;
    const N = s && typeof s == "string" ? s : `${C.name}${n}`;
    function z() {
        R ? (H = yo(R, v),
        zi("[nuxt-socket-io]: connect", C.name, R, v)) : (H = yo(n, v),
        zi("[nuxt-socket-io]: connect", C.name, window.location, n, v))
    }
    s ? Ys[N] ? (Q(`resuing persisted socket ${N}`),
    H = Ys[N],
    H.disconnected && (Q("persisted socket disconnected, reconnecting..."),
    z())) : (Q(`socket ${N} does not exist, creating and connecting to it..`),
    z(),
    Ys[N] = H) : z(),
    Ce.emitP(H),
    Ce.onceP(H),
    i && hr.SET_EMIT_TIMEOUT(b, {
        label: N,
        emitTimeout: i
    });
    const se = Object.assign({
        ...L[n]
    }, m);
    (se.emitters || se.listeners || se.emitBacks) && (Ce.namespace({
        ctx: this,
        namespaceCfg: se,
        socket: H,
        emitTimeout: i,
        emitErrorsProp: a
    }),
    Q("namespaces configured for socket", {
        name: C.name,
        channel: n,
        namespaceCfg: m
    })),
    f && Ce.serverAPI({
        label: N,
        apiIgnoreEvts: c,
        ioApiProp: l,
        ioDataProp: u,
        ctx: this,
        socket: H,
        serverAPI: f,
        clientAPI: d
    }),
    d && Ce.clientAPI({
        ctx: this,
        socket: H,
        clientAPI: d
    });
    const re = [...C.iox || [], ...e.iox || []];
    return re && Ce.iox({
        stateOpts: re,
        socket: H,
        useSocket: C
    }),
    "socketStatus"in this && typeof this.socketStatus == "object" && (Ce.socketStatus(this, H, R || window.location.origin, r),
    Q("socketStatus registered for socket", {
        name: C.name,
        url: R
    })),
    o && Ce.teardown({
        ctx: this,
        socket: H,
        useSocket: C
    }),
    H
}
const zE = ke(e=>{
    e.provide("nuxtSocket", KE),
    e.provide("ioState", Vh)
}
)
  , GE = ke({
    name: "nuxt:chunk-reload",
    setup(e) {
        const t = xt()
          , n = kr()
          , r = new Set;
        t.beforeEach(()=>{
            r.clear()
        }
        ),
        e.hook("app:chunkError", ({error: o})=>{
            r.add(o)
        }
        );
        function s(o) {
            const a = "href"in o && o.href[0] === "#" ? n.app.baseURL + o.href : Rc(n.app.baseURL, o.fullPath);
            sw({
                path: a,
                persistState: !0
            })
        }
        e.hook("app:manifest:update", ()=>{
            t.beforeResolve(s)
        }
        ),
        t.onError((o,i)=>{
            r.has(o) && s(i)
        }
        )
    }
});
function Gu(e) {
    return {
        getItem: t=>Ba(t, {
            ...e,
            encode: encodeURIComponent,
            decode: decodeURIComponent
        }).value,
        setItem: (t,n)=>{
            Ba(t, {
                ...e,
                encode: encodeURIComponent,
                decode: decodeURIComponent
            }).value = n
        }
    }
}
function JE() {
    return {
        getItem: e=>ie().ssrContext ? null : localStorage.getItem(e),
        setItem: (e,t)=>{
            ie().ssrContext || localStorage.setItem(e, t)
        }
    }
}
function XE() {
    return {
        getItem: e=>ie().ssrContext ? null : sessionStorage.getItem(e),
        setItem: (e,t)=>{
            ie().ssrContext || sessionStorage.setItem(e, t)
        }
    }
}
const Ju = {
    localStorage: JE(),
    sessionStorage: XE(),
    cookies: Gu(),
    cookiesWithOptions: Gu
};
function YE(e) {
    return typeof e == "object" && e !== null
}
function Xu(e, t) {
    return e = YE(e) ? e : Object.create(null),
    new Proxy(e,{
        get(n, r, s) {
            return r === "key" ? Reflect.get(n, r, s) : Reflect.get(n, r, s) || Reflect.get(t, r, s)
        }
    })
}
function QE(e, t) {
    return t.reduce((n,r)=>n == null ? void 0 : n[r], e)
}
function ZE(e, t, n) {
    return t.slice(0, -1).reduce((r,s)=>/^(__proto__)$/.test(s) ? {} : r[s] = r[s] || {}, e)[t[t.length - 1]] = n,
    e
}
function eC(e, t) {
    return t.reduce((n,r)=>{
        const s = r.split(".");
        return ZE(n, s, QE(e, s))
    }
    , {})
}
function tC(e, t) {
    return n=>{
        var r;
        try {
            const {storage: s=localStorage, beforeRestore: o=void 0, afterRestore: i=void 0, serializer: a={
                serialize: JSON.stringify,
                deserialize: JSON.parse
            }, key: l=t.$id, paths: u=null, debug: c=!1} = n;
            return {
                storage: s,
                beforeRestore: o,
                afterRestore: i,
                serializer: a,
                key: ((r = e.key) != null ? r : f=>f)(typeof l == "string" ? l : l(t.$id)),
                paths: u,
                debug: c
            }
        } catch (s) {
            return n.debug && console.error("[pinia-plugin-persistedstate]", s),
            null
        }
    }
}
function Yu(e, {storage: t, serializer: n, key: r, debug: s}) {
    try {
        const o = t == null ? void 0 : t.getItem(r);
        o && e.$patch(n == null ? void 0 : n.deserialize(o))
    } catch (o) {
        s && console.error("[pinia-plugin-persistedstate]", o)
    }
}
function Qu(e, {storage: t, serializer: n, key: r, paths: s, debug: o}) {
    try {
        const i = Array.isArray(s) ? eC(e, s) : e;
        t.setItem(r, n.serialize(i))
    } catch (i) {
        o && console.error("[pinia-plugin-persistedstate]", i)
    }
}
function nC(e={}) {
    return t=>{
        const {auto: n=!1} = e
          , {options: {persist: r=n}, store: s, pinia: o} = t;
        if (!r)
            return;
        if (!(s.$id in o.state.value)) {
            const a = o._s.get(s.$id.replace("__hot:", ""));
            a && Promise.resolve().then(()=>a.$persist());
            return
        }
        const i = (Array.isArray(r) ? r.map(a=>Xu(a, e)) : [Xu(r, e)]).map(tC(e, s)).filter(Boolean);
        s.$persist = ()=>{
            i.forEach(a=>{
                Qu(s.$state, a)
            }
            )
        }
        ,
        s.$hydrate = ({runHooks: a=!0}={})=>{
            i.forEach(l=>{
                const {beforeRestore: u, afterRestore: c} = l;
                a && (u == null || u(t)),
                Yu(s, l),
                a && (c == null || c(t))
            }
            )
        }
        ,
        i.forEach(a=>{
            const {beforeRestore: l, afterRestore: u} = a;
            l == null || l(t),
            Yu(s, a),
            u == null || u(t),
            s.$subscribe((c,f)=>{
                Qu(f, a)
            }
            , {
                detached: !0
            })
        }
        )
    }
}
const rC = ke(e=>{
    const {cookieOptions: t, debug: n, storage: r} = kr().public.persistedState;
    e.$pinia.use(nC({
        storage: r === "cookies" ? Ju.cookiesWithOptions(t) : Ju[r],
        debug: n
    }))
}
)
  , sC = (e,t,n)=>{
    const r = document.createElement("script");
    r.src = e,
    r.async = !0,
    r.onload = t,
    r.onerror = n,
    document.head.appendChild(r)
}
  , Uh = Dc("app", {
    state: ()=>({
        telegramMiniAppReady: !1,
        telegramPlatform: "unknown"
    }),
    actions: {
        setTelegramMiniAppReady(e) {
            this.telegramMiniAppReady = e
        },
        setTelegramMiniAppPlatform(e) {
            this.telegramPlatform = e
        }
    }
})
  , oC = ke(()=>{
    const e = Uh();
    sC("https://telegram.org/js/telegram-web-app.js", ()=>{
        var n, r, s, o, i;
        const t = (n = window == null ? void 0 : window.Telegram) == null ? void 0 : n.WebApp;
        if (t) {
            const a = xt()
              , l = Gn()
              , u = kr()
              , {isProd: c, tgRetrodropBotUrl: f} = u.public;
            c && t.platform === "unknown" && f && !localStorage.getItem("test") && Jd(f, {
                external: !0
            }),
            (r = t.expand) == null || r.call(t),
            (s = t.enableClosingConfirmation) == null || s.call(t),
            (i = (o = t.BackButton) == null ? void 0 : o.onClick) == null || i.call(o, ()=>{
                var v, T, k, b, y, w, E, _;
                const d = ["/quests/social/connect", "/quests/social/twitter-qr", "/quests/social/unfortunately", "/game"].includes(l.path) || ((k = (T = (v = a.options.history) == null ? void 0 : v.state) == null ? void 0 : T.back) == null ? void 0 : k.includes("/reward"))
                  , h = ((b = l.query) == null ? void 0 : b.backTo) === "main"
                  , m = (y = l.query) == null ? void 0 : y.backTo;
                d || h || !((_ = (E = (w = a.options) == null ? void 0 : w.history) == null ? void 0 : E.state) != null && _.back) ? a.push("/") : !h && m ? a.replace(`${m}`) : a.back()
            }
            ),
            e.setTelegramMiniAppReady(!0),
            e.setTelegramMiniAppPlatform(t.platform)
        }
    }
    , null)
}
)
  , wt = {
    addEventListeners(e, t, n) {
        for (let r = 0, s = t.length; r < s; r++)
            e.addEventListener(t[r], n, {
                passive: !1
            })
    },
    removeEventListeners(e, t, n) {
        for (let r = 0, s = t.length; r < s; r++)
            e.removeEventListener(t[r], n, {
                passive: !1
            })
    },
    emitEvent: function(e, t, n) {
        if (e.componentInstance)
            e.componentInstance.$emit(t, n);
        else {
            let r = new window.CustomEvent(t,{
                detail: n
            });
            e.el.dispatchEvent(r)
        }
    }
}
  , Va = ["mousedown", "touchstart"]
  , Ua = ["mousemove", "touchmove"]
  , qa = ["mouseup", "touchend"]
  , Zu = function(e, t, n) {
    let r = e
      , s = !0
      , o = window;
    typeof t.value == "boolean" ? s = t.value : typeof t.value == "object" ? (typeof t.value.target == "string" ? (r = e.querySelector(t.value.target),
    r || console.error("There is no element with the current target value.")) : typeof t.value.target < "u" && console.error(`The parameter "target" should be either 'undefined' or 'string'.`),
    typeof t.value.container == "string" ? (o = document.querySelector(t.value.container),
    o || console.error("There is no element with the current container value.")) : typeof t.value.container < "u" && console.error(`The parameter "container" should be be either 'undefined' or 'string'.`),
    typeof t.value.active == "boolean" ? s = t.value.active : typeof t.value.active < "u" && console.error(`The parameter "active" value should be either 'undefined', 'true' or 'false'.`)) : typeof t.value < "u" && console.error("The passed value should be either 'undefined', 'true' or 'false' or 'object'.");
    const i = function(l, u) {
        o === window ? window.scrollBy(l, u) : (o.scrollLeft += l,
        o.scrollTop += u)
    }
      , a = function() {
        let l, u, c, f = !1;
        r.md = function(d) {
            const h = d instanceof window.MouseEvent
              , m = h ? d.pageX : d.touches[0].pageX
              , v = h ? d.pageY : d.touches[0].pageY
              , T = document.elementFromPoint(m - window.pageXOffset, v - window.pageYOffset)
              , k = t.arg === "nochilddrag"
              , b = t.modifiers.noleft
              , y = t.modifiers.noright
              , w = t.modifiers.nomiddle
              , E = t.modifiers.noback
              , _ = t.modifiers.noforward
              , I = t.arg === "firstchilddrag"
              , C = T === r
              , R = T === r.firstChild
              , L = k ? typeof (T == null ? void 0 : T.dataset.dragscroll) < "u" : typeof (T == null ? void 0 : T.dataset.noDragscroll) > "u";
            if (!(!C && (!L || I && !R)) && !(d.button === 0 && b)) {
                if (d.button === 1 && w || d.button === 2 && y || d.button === 3 && E || d.button === 4 && _)
                    return;
                c = 1,
                l = h ? d.clientX : d.touches[0].clientX,
                u = h ? d.clientY : d.touches[0].clientY
            }
        }
        ,
        r.mu = function(d) {
            c = 0,
            f && wt.emitEvent(n, "dragscrollend"),
            f = !1
        }
        ,
        r.mm = function(d) {
            const h = d instanceof window.MouseEvent;
            let m, v;
            if (c) {
                d.preventDefault(),
                f || wt.emitEvent(n, "dragscrollstart"),
                f = !0;
                const T = r.scrollLeft + r.clientWidth >= r.scrollWidth || r.scrollLeft === 0
                  , k = r.scrollTop + r.clientHeight >= r.scrollHeight || r.scrollTop === 0;
                m = -l + (l = h ? d.clientX : d.touches[0].clientX),
                v = -u + (u = h ? d.clientY : d.touches[0].clientY),
                t.modifiers.pass ? (r.scrollLeft -= t.modifiers.y ? -0 : m,
                r.scrollTop -= t.modifiers.x ? -0 : v,
                r === document.body && (r.scrollLeft -= t.modifiers.y ? -0 : m,
                r.scrollTop -= t.modifiers.x ? -0 : v),
                (T || t.modifiers.y) && i(-m, 0),
                (k || t.modifiers.x) && i(0, -v)) : (t.modifiers.x && (v = -0),
                t.modifiers.y && (m = -0),
                r.scrollLeft -= m,
                r.scrollTop -= v,
                r === document.body && (r.scrollLeft -= m,
                r.scrollTop -= v)),
                wt.emitEvent(n, "dragscrollmove", {
                    deltaX: -m,
                    deltaY: -v
                })
            }
        }
        ,
        wt.addEventListeners(r, Va, r.md),
        wt.addEventListeners(window, qa, r.mu),
        wt.addEventListeners(window, Ua, r.mm)
    };
    s ? document.readyState === "complete" ? a() : window.addEventListener("load", a) : (wt.removeEventListeners(r, Va, r.md),
    wt.removeEventListeners(window, qa, r.mu),
    wt.removeEventListeners(window, Ua, r.mm))
}
  , iC = e=>{
    const t = e;
    wt.removeEventListeners(t, Va, t.md),
    wt.removeEventListeners(window, qa, t.mu),
    wt.removeEventListeners(window, Ua, t.mm)
}
  , qh = {
    mounted: (e,t,n)=>Zu(e, t, n),
    updated: (e,t,n)=>{
        JSON.stringify(t.value) !== JSON.stringify(t.oldValue) && Zu(e, t, n)
    }
    ,
    unmounted: e=>iC(e)
};
typeof window < "u" && window.Vue && (window.VueDragscroll = qh);
const aC = ke(e=>{
    e.vueApp.directive("drag-scroll", qh)
}
);
var pr, mr, bo, Wh, wo, Kh;
class cC {
    constructor() {
        je(this, bo);
        je(this, wo);
        je(this, pr, void 0);
        je(this, mr, "xxx")
    }
    async getHash() {
        return Le(this, pr) || await on(this, bo, Wh).call(this),
        Le(this, mr) === "xxx" && Rn(this, mr, await on(this, wo, Kh).call(this)),
        Le(this, mr)
    }
}
pr = new WeakMap,
mr = new WeakMap,
bo = new WeakSet,
Wh = async function() {
    Rn(this, pr, await J(()=>import("./Bezvnk9Q.js"), [], import.meta.url))
}
,
wo = new WeakSet,
Kh = function() {
    return new Promise(t=>{
        Le(this, pr).load().then(n=>n.get()).then(n=>{
            t(n == null ? void 0 : n.visitorId)
        }
        )
    }
    )
}
;
const lC = new cC
  , uC = ke(()=>({
    provide: {
        fingerPrint: lC
    }
}))
  , fC = Dc("modals", {
    state: ()=>({
        modals: []
    }),
    actions: {
        openModal(e={}) {
            !e || this.modals.find(n=>n.name === e.name) || this.modals.push(e)
        },
        hideModal(e={}) {
            if (!(e != null && e.name)) {
                this.modals.shift();
                return
            }
            this.modals = this.modals.filter(t=>t.name !== e.name)
        }
    },
    getters: {
        activeModal: e=>{
            var t;
            return (t = e.modals[0]) == null ? void 0 : t.name
        }
        ,
        activeModalData: e=>{
            var t;
            return (t = e.modals[0]) == null ? void 0 : t.data
        }
        ,
        activeModalOptions: e=>{
            var t;
            return (t = e.modals[0]) == null ? void 0 : t.options
        }
    }
})
  , dC = ke(()=>{
    const e = fC();
    function t(r={}) {
        e.openModal(r)
    }
    function n() {
        e.hideModal()
    }
    return {
        provide: {
            showModal: t,
            hideModal: n
        }
    }
}
);
var hC = Object.defineProperty
  , ef = Object.getOwnPropertySymbols
  , pC = Object.prototype.hasOwnProperty
  , mC = Object.prototype.propertyIsEnumerable
  , tf = (e,t,n)=>t in e ? hC(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n
  , zh = (e,t)=>{
    for (var n in t || (t = {}))
        pC.call(t, n) && tf(e, n, t[n]);
    if (ef)
        for (var n of ef(t))
            mC.call(t, n) && tf(e, n, t[n]);
    return e
}
  , Go = e=>typeof e == "function"
  , Jo = e=>typeof e == "string"
  , Gh = e=>Jo(e) && e.trim().length > 0
  , gC = e=>typeof e == "number"
  , xn = e=>typeof e > "u"
  , rs = e=>typeof e == "object" && e !== null
  , yC = e=>Wt(e, "tag") && Gh(e.tag)
  , Jh = e=>window.TouchEvent && e instanceof TouchEvent
  , Xh = e=>Wt(e, "component") && Yh(e.component)
  , vC = e=>Go(e) || rs(e)
  , Yh = e=>!xn(e) && (Jo(e) || vC(e) || Xh(e))
  , nf = e=>rs(e) && ["height", "width", "right", "left", "top", "bottom"].every(t=>gC(e[t]))
  , Wt = (e,t)=>(rs(e) || Go(e)) && t in e
  , bC = (e=>()=>e++)(0);
function Xi(e) {
    return Jh(e) ? e.targetTouches[0].clientX : e.clientX
}
function rf(e) {
    return Jh(e) ? e.targetTouches[0].clientY : e.clientY
}
var wC = e=>{
    xn(e.remove) ? e.parentNode && e.parentNode.removeChild(e) : e.remove()
}
, _s = e=>Xh(e) ? _s(e.component) : yC(e) ? De({
    render() {
        return e
    }
}) : typeof e == "string" ? e : ne(he(e)), EC = e=>{
    if (typeof e == "string")
        return e;
    const t = Wt(e, "props") && rs(e.props) ? e.props : {}
      , n = Wt(e, "listeners") && rs(e.listeners) ? e.listeners : {};
    return {
        component: _s(e),
        props: t,
        listeners: n
    }
}
, CC = ()=>typeof window < "u", Gc = class {
    constructor() {
        this.allHandlers = {}
    }
    getHandlers(e) {
        return this.allHandlers[e] || []
    }
    on(e, t) {
        const n = this.getHandlers(e);
        n.push(t),
        this.allHandlers[e] = n
    }
    off(e, t) {
        const n = this.getHandlers(e);
        n.splice(n.indexOf(t) >>> 0, 1)
    }
    emit(e, t) {
        this.getHandlers(e).forEach(r=>r(t))
    }
}
, TC = e=>["on", "off", "emit"].every(t=>Wt(e, t) && Go(e[t])), dt;
(function(e) {
    e.SUCCESS = "success",
    e.ERROR = "error",
    e.WARNING = "warning",
    e.INFO = "info",
    e.DEFAULT = "default"
}
)(dt || (dt = {}));
var ss;
(function(e) {
    e.TOP_LEFT = "top-left",
    e.TOP_CENTER = "top-center",
    e.TOP_RIGHT = "top-right",
    e.BOTTOM_LEFT = "bottom-left",
    e.BOTTOM_CENTER = "bottom-center",
    e.BOTTOM_RIGHT = "bottom-right"
}
)(ss || (ss = {}));
var ht;
(function(e) {
    e.ADD = "add",
    e.DISMISS = "dismiss",
    e.UPDATE = "update",
    e.CLEAR = "clear",
    e.UPDATE_DEFAULTS = "update_defaults"
}
)(ht || (ht = {}));
var Lt = "Vue-Toastification"
  , Pt = {
    type: {
        type: String,
        default: dt.DEFAULT
    },
    classNames: {
        type: [String, Array],
        default: ()=>[]
    },
    trueBoolean: {
        type: Boolean,
        default: !0
    }
}
  , Qh = {
    type: Pt.type,
    customIcon: {
        type: [String, Boolean, Object, Function],
        default: !0
    }
}
  , Qs = {
    component: {
        type: [String, Object, Function, Boolean],
        default: "button"
    },
    classNames: Pt.classNames,
    showOnHover: {
        type: Boolean,
        default: !1
    },
    ariaLabel: {
        type: String,
        default: "close"
    }
}
  , Wa = {
    timeout: {
        type: [Number, Boolean],
        default: 5e3
    },
    hideProgressBar: {
        type: Boolean,
        default: !1
    },
    isRunning: {
        type: Boolean,
        default: !1
    }
}
  , Zh = {
    transition: {
        type: [Object, String],
        default: `${Lt}__bounce`
    }
}
  , _C = {
    position: {
        type: String,
        default: ss.TOP_RIGHT
    },
    draggable: Pt.trueBoolean,
    draggablePercent: {
        type: Number,
        default: .6
    },
    pauseOnFocusLoss: Pt.trueBoolean,
    pauseOnHover: Pt.trueBoolean,
    closeOnClick: Pt.trueBoolean,
    timeout: Wa.timeout,
    hideProgressBar: Wa.hideProgressBar,
    toastClassName: Pt.classNames,
    bodyClassName: Pt.classNames,
    icon: Qh.customIcon,
    closeButton: Qs.component,
    closeButtonClassName: Qs.classNames,
    showCloseButtonOnHover: Qs.showOnHover,
    accessibility: {
        type: Object,
        default: ()=>({
            toastRole: "alert",
            closeButtonLabel: "close"
        })
    },
    rtl: {
        type: Boolean,
        default: !1
    },
    eventBus: {
        type: Object,
        required: !1,
        default: ()=>new Gc
    }
}
  , SC = {
    id: {
        type: [String, Number],
        required: !0,
        default: 0
    },
    type: Pt.type,
    content: {
        type: [String, Object, Function],
        required: !0,
        default: ""
    },
    onClick: {
        type: Function,
        default: void 0
    },
    onClose: {
        type: Function,
        default: void 0
    }
}
  , kC = {
    container: {
        type: [Object, Function],
        default: ()=>document.body
    },
    newestOnTop: Pt.trueBoolean,
    maxToasts: {
        type: Number,
        default: 20
    },
    transition: Zh.transition,
    toastDefaults: Object,
    filterBeforeCreate: {
        type: Function,
        default: e=>e
    },
    filterToasts: {
        type: Function,
        default: e=>e
    },
    containerClassName: Pt.classNames,
    onMounted: Function,
    shareAppContext: [Boolean, Object]
}
  , Zt = {
    CORE_TOAST: _C,
    TOAST: SC,
    CONTAINER: kC,
    PROGRESS_BAR: Wa,
    ICON: Qh,
    TRANSITION: Zh,
    CLOSE_BUTTON: Qs
}
  , ep = De({
    name: "VtProgressBar",
    props: Zt.PROGRESS_BAR,
    data() {
        return {
            hasClass: !0
        }
    },
    computed: {
        style() {
            return {
                animationDuration: `${this.timeout}ms`,
                animationPlayState: this.isRunning ? "running" : "paused",
                opacity: this.hideProgressBar ? 0 : 1
            }
        },
        cpClass() {
            return this.hasClass ? `${Lt}__progress-bar` : ""
        }
    },
    watch: {
        timeout() {
            this.hasClass = !1,
            this.$nextTick(()=>this.hasClass = !0)
        }
    },
    mounted() {
        this.$el.addEventListener("animationend", this.animationEnded)
    },
    beforeUnmount() {
        this.$el.removeEventListener("animationend", this.animationEnded)
    },
    methods: {
        animationEnded() {
            this.$emit("close-toast")
        }
    }
});
function RC(e, t) {
    return ue(),
    It("div", {
        style: _r(e.style),
        class: en(e.cpClass)
    }, null, 6)
}
ep.render = RC;
var AC = ep
  , tp = De({
    name: "VtCloseButton",
    props: Zt.CLOSE_BUTTON,
    computed: {
        buttonComponent() {
            return this.component !== !1 ? _s(this.component) : "button"
        },
        classes() {
            const e = [`${Lt}__close-button`];
            return this.showOnHover && e.push("show-on-hover"),
            e.concat(this.classNames)
        }
    }
})
  , PC = hs(" × ");
function OC(e, t) {
    return ue(),
    Pe(Bo(e.buttonComponent), ps({
        "aria-label": e.ariaLabel,
        class: e.classes
    }, e.$attrs), {
        default: kn(()=>[PC]),
        _: 1
    }, 16, ["aria-label", "class"])
}
tp.render = OC;
var IC = tp
  , np = {}
  , LC = {
    "aria-hidden": "true",
    focusable: "false",
    "data-prefix": "fas",
    "data-icon": "check-circle",
    class: "svg-inline--fa fa-check-circle fa-w-16",
    role: "img",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
}
  , NC = Kn("path", {
    fill: "currentColor",
    d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
}, null, -1)
  , MC = [NC];
function BC(e, t) {
    return ue(),
    It("svg", LC, MC)
}
np.render = BC;
var DC = np
  , rp = {}
  , xC = {
    "aria-hidden": "true",
    focusable: "false",
    "data-prefix": "fas",
    "data-icon": "info-circle",
    class: "svg-inline--fa fa-info-circle fa-w-16",
    role: "img",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
}
  , FC = Kn("path", {
    fill: "currentColor",
    d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
}, null, -1)
  , HC = [FC];
function $C(e, t) {
    return ue(),
    It("svg", xC, HC)
}
rp.render = $C;
var sf = rp
  , sp = {}
  , jC = {
    "aria-hidden": "true",
    focusable: "false",
    "data-prefix": "fas",
    "data-icon": "exclamation-circle",
    class: "svg-inline--fa fa-exclamation-circle fa-w-16",
    role: "img",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
}
  , VC = Kn("path", {
    fill: "currentColor",
    d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1)
  , UC = [VC];
function qC(e, t) {
    return ue(),
    It("svg", jC, UC)
}
sp.render = qC;
var WC = sp
  , op = {}
  , KC = {
    "aria-hidden": "true",
    focusable: "false",
    "data-prefix": "fas",
    "data-icon": "exclamation-triangle",
    class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
    role: "img",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 576 512"
}
  , zC = Kn("path", {
    fill: "currentColor",
    d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1)
  , GC = [zC];
function JC(e, t) {
    return ue(),
    It("svg", KC, GC)
}
op.render = JC;
var XC = op
  , ip = De({
    name: "VtIcon",
    props: Zt.ICON,
    computed: {
        customIconChildren() {
            return Wt(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : ""
        },
        customIconClass() {
            return Jo(this.customIcon) ? this.trimValue(this.customIcon) : Wt(this.customIcon, "iconClass") ? this.trimValue(this.customIcon.iconClass) : ""
        },
        customIconTag() {
            return Wt(this.customIcon, "iconTag") ? this.trimValue(this.customIcon.iconTag, "i") : "i"
        },
        hasCustomIcon() {
            return this.customIconClass.length > 0
        },
        component() {
            return this.hasCustomIcon ? this.customIconTag : Yh(this.customIcon) ? _s(this.customIcon) : this.iconTypeComponent
        },
        iconTypeComponent() {
            return {
                [dt.DEFAULT]: sf,
                [dt.INFO]: sf,
                [dt.SUCCESS]: DC,
                [dt.ERROR]: XC,
                [dt.WARNING]: WC
            }[this.type]
        },
        iconClasses() {
            const e = [`${Lt}__icon`];
            return this.hasCustomIcon ? e.concat(this.customIconClass) : e
        }
    },
    methods: {
        trimValue(e, t="") {
            return Gh(e) ? e.trim() : t
        }
    }
});
function YC(e, t) {
    return ue(),
    Pe(Bo(e.component), {
        class: en(e.iconClasses)
    }, {
        default: kn(()=>[hs(gf(e.customIconChildren), 1)]),
        _: 1
    }, 8, ["class"])
}
ip.render = YC;
var QC = ip
  , ap = De({
    name: "VtToast",
    components: {
        ProgressBar: AC,
        CloseButton: IC,
        Icon: QC
    },
    inheritAttrs: !1,
    props: Object.assign({}, Zt.CORE_TOAST, Zt.TOAST),
    data() {
        return {
            isRunning: !0,
            disableTransitions: !1,
            beingDragged: !1,
            dragStart: 0,
            dragPos: {
                x: 0,
                y: 0
            },
            dragRect: {}
        }
    },
    computed: {
        classes() {
            const e = [`${Lt}__toast`, `${Lt}__toast--${this.type}`, `${this.position}`].concat(this.toastClassName);
            return this.disableTransitions && e.push("disable-transition"),
            this.rtl && e.push(`${Lt}__toast--rtl`),
            e
        },
        bodyClasses() {
            return [`${Lt}__toast-${Jo(this.content) ? "body" : "component-body"}`].concat(this.bodyClassName)
        },
        draggableStyle() {
            return this.dragStart === this.dragPos.x ? {} : this.beingDragged ? {
                transform: `translateX(${this.dragDelta}px)`,
                opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
            } : {
                transition: "transform 0.2s, opacity 0.2s",
                transform: "translateX(0)",
                opacity: 1
            }
        },
        dragDelta() {
            return this.beingDragged ? this.dragPos.x - this.dragStart : 0
        },
        removalDistance() {
            return nf(this.dragRect) ? (this.dragRect.right - this.dragRect.left) * this.draggablePercent : 0
        }
    },
    mounted() {
        this.draggable && this.draggableSetup(),
        this.pauseOnFocusLoss && this.focusSetup()
    },
    beforeUnmount() {
        this.draggable && this.draggableCleanup(),
        this.pauseOnFocusLoss && this.focusCleanup()
    },
    methods: {
        hasProp: Wt,
        getVueComponentFromObj: _s,
        closeToast() {
            this.eventBus.emit(ht.DISMISS, this.id)
        },
        clickHandler() {
            this.onClick && this.onClick(this.closeToast),
            this.closeOnClick && (!this.beingDragged || this.dragStart === this.dragPos.x) && this.closeToast()
        },
        timeoutHandler() {
            this.closeToast()
        },
        hoverPause() {
            this.pauseOnHover && (this.isRunning = !1)
        },
        hoverPlay() {
            this.pauseOnHover && (this.isRunning = !0)
        },
        focusPause() {
            this.isRunning = !1
        },
        focusPlay() {
            this.isRunning = !0
        },
        focusSetup() {
            addEventListener("blur", this.focusPause),
            addEventListener("focus", this.focusPlay)
        },
        focusCleanup() {
            removeEventListener("blur", this.focusPause),
            removeEventListener("focus", this.focusPlay)
        },
        draggableSetup() {
            const e = this.$el;
            e.addEventListener("touchstart", this.onDragStart, {
                passive: !0
            }),
            e.addEventListener("mousedown", this.onDragStart),
            addEventListener("touchmove", this.onDragMove, {
                passive: !1
            }),
            addEventListener("mousemove", this.onDragMove),
            addEventListener("touchend", this.onDragEnd),
            addEventListener("mouseup", this.onDragEnd)
        },
        draggableCleanup() {
            const e = this.$el;
            e.removeEventListener("touchstart", this.onDragStart),
            e.removeEventListener("mousedown", this.onDragStart),
            removeEventListener("touchmove", this.onDragMove),
            removeEventListener("mousemove", this.onDragMove),
            removeEventListener("touchend", this.onDragEnd),
            removeEventListener("mouseup", this.onDragEnd)
        },
        onDragStart(e) {
            this.beingDragged = !0,
            this.dragPos = {
                x: Xi(e),
                y: rf(e)
            },
            this.dragStart = Xi(e),
            this.dragRect = this.$el.getBoundingClientRect()
        },
        onDragMove(e) {
            this.beingDragged && (e.preventDefault(),
            this.isRunning && (this.isRunning = !1),
            this.dragPos = {
                x: Xi(e),
                y: rf(e)
            })
        },
        onDragEnd() {
            this.beingDragged && (Math.abs(this.dragDelta) >= this.removalDistance ? (this.disableTransitions = !0,
            this.$nextTick(()=>this.closeToast())) : setTimeout(()=>{
                this.beingDragged = !1,
                nf(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right ? this.isRunning = !1 : this.isRunning = !0
            }
            ))
        }
    }
})
  , ZC = ["role"];
function eT(e, t) {
    const n = Dr("Icon")
      , r = Dr("CloseButton")
      , s = Dr("ProgressBar");
    return ue(),
    It("div", {
        class: en(e.classes),
        style: _r(e.draggableStyle),
        onClick: t[0] || (t[0] = (...o)=>e.clickHandler && e.clickHandler(...o)),
        onMouseenter: t[1] || (t[1] = (...o)=>e.hoverPause && e.hoverPause(...o)),
        onMouseleave: t[2] || (t[2] = (...o)=>e.hoverPlay && e.hoverPlay(...o))
    }, [e.icon ? (ue(),
    Pe(n, {
        key: 0,
        "custom-icon": e.icon,
        type: e.type
    }, null, 8, ["custom-icon", "type"])) : oi("v-if", !0), Kn("div", {
        role: e.accessibility.toastRole || "alert",
        class: en(e.bodyClasses)
    }, [typeof e.content == "string" ? (ue(),
    It(Te, {
        key: 0
    }, [hs(gf(e.content), 1)], 2112)) : (ue(),
    Pe(Bo(e.getVueComponentFromObj(e.content)), ps({
        key: 1,
        "toast-id": e.id
    }, e.hasProp(e.content, "props") ? e.content.props : {}, Fm(e.hasProp(e.content, "listeners") ? e.content.listeners : {}), {
        onCloseToast: e.closeToast
    }), null, 16, ["toast-id", "onCloseToast"]))], 10, ZC), e.closeButton ? (ue(),
    Pe(r, {
        key: 1,
        component: e.closeButton,
        "class-names": e.closeButtonClassName,
        "show-on-hover": e.showCloseButtonOnHover,
        "aria-label": e.accessibility.closeButtonLabel,
        onClick: Kg(e.closeToast, ["stop"])
    }, null, 8, ["component", "class-names", "show-on-hover", "aria-label", "onClick"])) : oi("v-if", !0), e.timeout ? (ue(),
    Pe(s, {
        key: 2,
        "is-running": e.isRunning,
        "hide-progress-bar": e.hideProgressBar,
        timeout: e.timeout,
        onCloseToast: e.timeoutHandler
    }, null, 8, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"])) : oi("v-if", !0)], 38)
}
ap.render = eT;
var tT = ap
  , cp = De({
    name: "VtTransition",
    props: Zt.TRANSITION,
    emits: ["leave"],
    methods: {
        hasProp: Wt,
        leave(e) {
            e instanceof HTMLElement && (e.style.left = e.offsetLeft + "px",
            e.style.top = e.offsetTop + "px",
            e.style.width = getComputedStyle(e).width,
            e.style.position = "absolute")
        }
    }
});
function nT(e, t) {
    return ue(),
    Pe(xg, {
        tag: "div",
        "enter-active-class": e.transition.enter ? e.transition.enter : `${e.transition}-enter-active`,
        "move-class": e.transition.move ? e.transition.move : `${e.transition}-move`,
        "leave-active-class": e.transition.leave ? e.transition.leave : `${e.transition}-leave-active`,
        onLeave: e.leave
    }, {
        default: kn(()=>[xm(e.$slots, "default")]),
        _: 3
    }, 8, ["enter-active-class", "move-class", "leave-active-class", "onLeave"])
}
cp.render = nT;
var rT = cp
  , lp = De({
    name: "VueToastification",
    devtools: {
        hide: !0
    },
    components: {
        Toast: tT,
        VtTransition: rT
    },
    props: Object.assign({}, Zt.CORE_TOAST, Zt.CONTAINER, Zt.TRANSITION),
    data() {
        return {
            count: 0,
            positions: Object.values(ss),
            toasts: {},
            defaults: {}
        }
    },
    computed: {
        toastArray() {
            return Object.values(this.toasts)
        },
        filteredToasts() {
            return this.defaults.filterToasts(this.toastArray)
        }
    },
    beforeMount() {
        const e = this.eventBus;
        e.on(ht.ADD, this.addToast),
        e.on(ht.CLEAR, this.clearToasts),
        e.on(ht.DISMISS, this.dismissToast),
        e.on(ht.UPDATE, this.updateToast),
        e.on(ht.UPDATE_DEFAULTS, this.updateDefaults),
        this.defaults = this.$props
    },
    mounted() {
        this.setup(this.container)
    },
    methods: {
        async setup(e) {
            Go(e) && (e = await e()),
            wC(this.$el),
            e.appendChild(this.$el)
        },
        setToast(e) {
            xn(e.id) || (this.toasts[e.id] = e)
        },
        addToast(e) {
            e.content = EC(e.content);
            const t = Object.assign({}, this.defaults, e.type && this.defaults.toastDefaults && this.defaults.toastDefaults[e.type], e)
              , n = this.defaults.filterBeforeCreate(t, this.toastArray);
            n && this.setToast(n)
        },
        dismissToast(e) {
            const t = this.toasts[e];
            !xn(t) && !xn(t.onClose) && t.onClose(),
            delete this.toasts[e]
        },
        clearToasts() {
            Object.keys(this.toasts).forEach(e=>{
                this.dismissToast(e)
            }
            )
        },
        getPositionToasts(e) {
            const t = this.filteredToasts.filter(n=>n.position === e).slice(0, this.defaults.maxToasts);
            return this.defaults.newestOnTop ? t.reverse() : t
        },
        updateDefaults(e) {
            xn(e.container) || this.setup(e.container),
            this.defaults = Object.assign({}, this.defaults, e)
        },
        updateToast({id: e, options: t, create: n}) {
            this.toasts[e] ? (t.timeout && t.timeout === this.toasts[e].timeout && t.timeout++,
            this.setToast(Object.assign({}, this.toasts[e], t))) : n && this.addToast(Object.assign({}, {
                id: e
            }, t))
        },
        getClasses(e) {
            return [`${Lt}__container`, e].concat(this.defaults.containerClassName)
        }
    }
});
function sT(e, t) {
    const n = Dr("Toast")
      , r = Dr("VtTransition");
    return ue(),
    It("div", null, [(ue(!0),
    It(Te, null, hl(e.positions, s=>(ue(),
    It("div", {
        key: s
    }, [ce(r, {
        transition: e.defaults.transition,
        class: en(e.getClasses(s))
    }, {
        default: kn(()=>[(ue(!0),
        It(Te, null, hl(e.getPositionToasts(s), o=>(ue(),
        Pe(n, ps({
            key: o.id
        }, o), null, 16))), 128))]),
        _: 2
    }, 1032, ["transition", "class"])]))), 128))])
}
lp.render = sT;
var oT = lp
  , of = (e={},t=!0)=>{
    const n = e.eventBus = e.eventBus || new Gc;
    t && Dt(()=>{
        const o = Pd(oT, zh({}, e))
          , i = o.mount(document.createElement("div"))
          , a = e.onMounted;
        if (xn(a) || a(i, o),
        e.shareAppContext) {
            const l = e.shareAppContext;
            l === !0 ? console.warn(`[${Lt}] App to share context with was not provided.`) : (o._context.components = l._context.components,
            o._context.directives = l._context.directives,
            o._context.mixins = l._context.mixins,
            o._context.provides = l._context.provides,
            o.config.globalProperties = l.config.globalProperties)
        }
    }
    );
    const r = (o,i)=>{
        const a = Object.assign({}, {
            id: bC(),
            type: dt.DEFAULT
        }, i, {
            content: o
        });
        return n.emit(ht.ADD, a),
        a.id
    }
    ;
    r.clear = ()=>n.emit(ht.CLEAR, void 0),
    r.updateDefaults = o=>{
        n.emit(ht.UPDATE_DEFAULTS, o)
    }
    ,
    r.dismiss = o=>{
        n.emit(ht.DISMISS, o)
    }
    ;
    function s(o, {content: i, options: a}, l=!1) {
        const u = Object.assign({}, a, {
            content: i
        });
        n.emit(ht.UPDATE, {
            id: o,
            options: u,
            create: l
        })
    }
    return r.update = s,
    r.success = (o,i)=>r(o, Object.assign({}, i, {
        type: dt.SUCCESS
    })),
    r.info = (o,i)=>r(o, Object.assign({}, i, {
        type: dt.INFO
    })),
    r.error = (o,i)=>r(o, Object.assign({}, i, {
        type: dt.ERROR
    })),
    r.warning = (o,i)=>r(o, Object.assign({}, i, {
        type: dt.WARNING
    })),
    r
}
  , iT = ()=>{
    const e = ()=>console.warn(`[${Lt}] This plugin does not support SSR!`);
    return new Proxy(e,{
        get() {
            return e
        }
    })
}
;
function Ka(e) {
    return CC() ? TC(e) ? of({
        eventBus: e
    }, !1) : of(e, !0) : iT()
}
var up = Symbol("VueToastification")
  , fp = new Gc
  , aT = (e,t)=>{
    (t == null ? void 0 : t.shareAppContext) === !0 && (t.shareAppContext = e);
    const n = Ka(zh({
        eventBus: fp
    }, t));
    e.provide(up, n)
}
  , cT = e=>{
    if (e)
        return Ka(e);
    const t = Gt() ? Oe(up, void 0) : void 0;
    return t || Ka(fp)
}
  , lT = aT;
function uT(e={
    iconCustom: ""
}) {
    const t = cT()
      , n = {
        fontSize: "16px",
        textTransform: "uppercase",
        fontFamily: "Orbitron, sans-serif",
        fontWeight: 900,
        lineHeight: "20px",
        letterSpacing: "2%",
        color: "var(--Text-Primary)"
    }
      , r = {
        display: "flex",
        alignItems: "center",
        borderRadius: "60px"
    }
      , s = {
        flexBasis: "24px",
        marginRight: "16px",
        height: "24px",
        weight: "24px"
    }
      , o = {
        fontSize: "14px",
        fontWeight: 500,
        lineHeight: "20px"
    }
      , i = ce("div", {
        className: "notify",
        style: r
    }, [ce("img", {
        className: "notify__icon",
        style: s,
        src: e.iconCustom ? `/icons/png/${e.iconCustom}.png` : "/icons/png/check.png",
        alt: "icon"
    }, null), ce("div", {
        className: "notify__wrap"
    }, [e.title ? ce("p", {
        className: "notify__title",
        style: n
    }, [e.title]) : null, e.text && ce("span", {
        className: "notify__text",
        style: o
    }, [e.text])])]);
    t(i, e)
}
const fT = ke(e=>{
    const t = {
        position: ss.TOP_CENTER,
        hideProgressBar: !0,
        icon: !1,
        closeButton: !1,
        toastClassName: "main-notification-item"
    };
    return e.vueApp.use(lT, t),
    {
        provide: {
            notify: uT
        }
    }
}
);
var vn;
class qs {
    constructor(t, n, r) {
        je(this, vn, {
            round: 20,
            bevel: 32,
            halfBebel: 50
        });
        this.width = t,
        this.height = n,
        this.options = r.split(" ")
    }
    generate() {
        const {options: t, width: n, height: r} = this;
        let s = `m 0 ${Le(this, vn)[t[0]]} `
          , o = 1;
        for (const i in t) {
            const a = t[i];
            s += this[a](o),
            s += this.line(o, o % 2 === 1 ? n - Le(this, vn)[a] - Le(this, vn)[t[Number(i) > 2 ? 0 : Number(i) + 1]] : r - Le(this, vn)[a] - Le(this, vn)[t[Number(i) > 2 ? 0 : Number(i) + 1]]),
            o++
        }
        return `path("${s}")`
    }
    round(t) {
        switch (t) {
        case 1:
            return "c 0 -10 10 -20 20 -20 ";
        case 2:
            return "c 10 0 20 10 20 20 ";
        case 3:
            return "c 0 10 -10 20 -20 20 ";
        case 4:
            return "c -10 0 -20 -10 -20 -20 "
        }
    }
    bevel(t) {
        switch (t) {
        case 1:
            return "c 0 -5 2 -10 6 -14 l 12 -12 c 4 -4 9 -6 14 -6 ";
        case 2:
            return "c 5 0 10 2 14 6 l 12 12 c 4 4 6 9 6 14 ";
        case 3:
            return "c 0 5 -2 10 -6 14 l -12 12 c -4 4 -9 6 -14 6 ";
        case 4:
            return "c -5 0 -10 -2 -14 -6 l -12 -12 c -4 -4 -6 -9 -6 -14 "
        }
    }
    line(t, n) {
        let r, s = n;
        return t % 2 === 1 ? r = "h" : r = "v",
        t > 2 && (s = n * -1),
        `${r} ${s} `
    }
}
vn = new WeakMap;
const dT = ke(e=>{
    e.vueApp.directive("shape-background", {
        mounted(t, n) {
            const r = n.value
              , {overflow: s} = n.modifiers
              , {clientWidth: o, clientHeight: i} = t
              , l = new qs(o,i,r).generate();
            if (["relative", "absolute", "fixed", "sticky"].every(h=>t.style.position !== h) && (t.style.position = "relative"),
            s && !t.querySelector(":scope > .shape-background-overflow")) {
                const h = document.createElement("span");
                h.style.clipPath = l,
                h.classList.add("shape-background-overflow"),
                t.appendChild(h)
            }
            s || (t.style.clipPath = l,
            t.classList.add("shape-background"));
            const f = new qs(o - 2,i - 2,r).generate();
            if (!t.querySelector(":scope > .shape-background-helper")) {
                const h = document.createElement("span");
                h.style.clipPath = f,
                h.classList.add("shape-background-helper"),
                h.style.width = `${o - 2}px`,
                h.style.height = `${i - 2}px`,
                t.appendChild(h)
            }
            new ResizeObserver(h=>{
                for (const m of h) {
                    const v = m.target
                      , {clientWidth: T, clientHeight: k} = v
                      , y = new qs(T,k,r).generate();
                    if (s) {
                        const E = v.querySelector(":scope > .shape-background-overflow");
                        E && (E.style.clipPath = y)
                    } else
                        v.style.clipPath = y,
                        v.classList.contains("shape-background") || v.classList.add("shape-background");
                    const w = v.querySelector(":scope > .shape-background-helper");
                    if (w) {
                        const _ = new qs(T - 2,k - 2,r).generate();
                        w.style.clipPath = _,
                        w.style.width = `${T - 2}px`,
                        w.style.height = `${k - 2}px`
                    }
                }
            }
            ).observe(t)
        }
    })
}
)
  , hT = 2801
  , pT = 7015
  , mT = 37009
  , m_ = ["earn", "wager", "trading", "social", "referral", "pts"]
  , g_ = "twitter_access_token"
  , y_ = "twitter_refresh_token"
  , v_ = "caBRgE02FR"
  , b_ = "bUwxm1Pzq5"
  , w_ = "twitter_redirect_after_connect"
  , E_ = "discord_redirect_after_connect"
  , C_ = "socialQuestList"
  , T_ = "onGoingQuestsList"
  , __ = "app";
function gT(e={}) {
    const t = Gn()
      , {$notify: n} = ie()
      , r = {
        "/free-crypto": "freeCrypto",
        "/game": "game"
    };
    mt(()=>t.path, ()=>{
        var o;
        if (Object.keys(r).some(i=>i.startsWith(t.path) && t.path !== "/")) {
            const i = (o = e[r[t.path]]) == null ? void 0 : o.message;
            i && (n({
                type: "error",
                title: "Error",
                text: i
            }),
            Jd("/"))
        }
    }
    , {
        immediate: !0
    })
}
const za = Dc("user", {
    state: ()=>({
        user: {},
        logged: !1,
        showLoader: !0,
        totalUsers: 0,
        isBind: !1,
        regDate: "",
        authHash: "",
        telegramData: null,
        isTwitterAllow: void 0,
        twitter: {},
        discord: {},
        settings: {
            hideAvatar: !1
        }
    }),
    actions: {
        async auth(e) {
            const {$socket: t, $fingerPrint: n, $showModal: r} = ie()
              , s = await n.getHash();
            if (!this.telegramData)
                try {
                    this.telegramData = JSON.parse(localStorage.getItem("telegramData"))
                } catch (o) {
                    console.error(o)
                }
            t.emit("Auth.signIn", {
                telegramData: this.telegramData,
                fingerprint: s,
                signUp: e
            }, !1, !1).then(o=>{
                var i, a;
                if (this.regDate = o.regDate,
                this.isBind = o.isBind,
                this.user = o,
                this.logged = !0,
                this.setLoaderState(!1),
                this.totalUsers = o.totalUsers,
                o.settings && (this.settings = o.settings),
                (i = this.user) != null && i._id) {
                    const l = Ba("userId");
                    l.value = this.user._id,
                    (a = window.dataLayer) == null || a.push({
                        user_id: this.user._id
                    })
                }
                o.restrictions && gT(o.restrictions)
            }
            ).catch(o=>{
                console.error("Auth error: ", o),
                o.code === hT && (this.setLoaderState(!1),
                this.totalUsers = o.totalUsers),
                o.code === pT && (this.setLoaderState(!1),
                r({
                    name: "AccessDenied",
                    options: {
                        hideCloseButton: !0,
                        persistent: !0,
                        isPriority: !0
                    }
                })),
                o.code === mT && (this.setLoaderState(!1),
                this.logged = !0,
                r({
                    name: "AccessDenied",
                    options: {
                        hideCloseButton: !0,
                        persistent: !0
                    },
                    data: {
                        error: o.error
                    }
                }))
            }
            )
        },
        setLoaderState(e) {
            this.showLoader = e
        },
        setAuthHash(e) {
            this.authHash = e
        },
        setTelegramData(e) {
            this.telegramData = e
        },
        setTwitter(e) {
            this.twitter = e
        },
        setIsTwitterAllow(e) {
            this.isTwitterAllow = e
        },
        setDiscord(e) {
            this.discord = e
        },
        setSquadInfo(e) {
            this.user.squadInfo = e
        },
        toggleHideAvatar() {
            const {$socket: e} = ie();
            e.emit("Profile.toggleAvatar").then(()=>{
                this.settings.hideAvatar = !this.settings.hideAvatar
            }
            )
        }
    }
});
function S_(e) {
    return cs() ? (Po(e),
    !0) : !1
}
function Ga(e) {
    return typeof e == "function" ? e() : he(e)
}
const yT = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const k_ = e=>e != null
  , vT = Object.prototype.toString
  , R_ = e=>vT.call(e) === "[object Object]"
  , vo = ()=>{}
  , A_ = bT();
function bT() {
    var e, t;
    return yT && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent))
}
function dp(e, t) {
    function n(...r) {
        return new Promise((s,o)=>{
            Promise.resolve(e(()=>t.apply(this, r), {
                fn: t,
                thisArg: this,
                args: r
            })).then(s).catch(o)
        }
        )
    }
    return n
}
function wT(e, t={}) {
    let n, r, s = vo;
    const o = a=>{
        clearTimeout(a),
        s(),
        s = vo
    }
    ;
    return a=>{
        const l = Ga(e)
          , u = Ga(t.maxWait);
        return n && o(n),
        l <= 0 || u !== void 0 && u <= 0 ? (r && (o(r),
        r = null),
        Promise.resolve(a())) : new Promise((c,f)=>{
            s = t.rejectOnCancel ? f : c,
            u && !r && (r = setTimeout(()=>{
                n && o(n),
                r = null,
                c(a())
            }
            , u)),
            n = setTimeout(()=>{
                r && o(r),
                r = null,
                c(a())
            }
            , l)
        }
        )
    }
}
function ET(...e) {
    let t = 0, n, r = !0, s = vo, o, i, a, l, u;
    !ve(e[0]) && typeof e[0] == "object" ? {delay: i, trailing: a=!0, leading: l=!0, rejectOnCancel: u=!1} = e[0] : [i,a=!0,l=!0,u=!1] = e;
    const c = ()=>{
        n && (clearTimeout(n),
        n = void 0,
        s(),
        s = vo)
    }
    ;
    return d=>{
        const h = Ga(i)
          , m = Date.now() - t
          , v = ()=>o = d();
        return c(),
        h <= 0 ? (t = Date.now(),
        v()) : (m > h && (l || !r) ? (t = Date.now(),
        v()) : a && (o = new Promise((T,k)=>{
            s = u ? k : T,
            n = setTimeout(()=>{
                t = Date.now(),
                r = !0,
                T(v()),
                c()
            }
            , Math.max(0, h - m))
        }
        )),
        !l && !n && (n = setTimeout(()=>r = !0, h)),
        r = !1,
        o)
    }
}
function CT(e) {
    return e || Gt()
}
function P_(e, t=200, n={}) {
    return dp(wT(t, n), e)
}
function O_(e, t=200, n=!1, r=!0, s=!1) {
    return dp(ET(t, n, r, s), e)
}
function I_(e, t=!0, n) {
    CT() ? ds(e, n) : t ? e() : Dt(e)
}
function af(e, t, n) {
    const r = mt(e, (...s)=>(Dt(()=>r()),
    t(...s)), n);
    return r
}
function L_(e) {
    var t;
    if (e)
        return (t = e.toString()) == null ? void 0 : t.replace(/\B(?=(\d{3})+(?!\d))/g, " ").trim()
}
const N_ = (e={})=>{
    const n = Math.random() * 1e5 / 1e3;
    let r = null
      , s = 0;
    return Object.keys(e).forEach(o=>{
        r === null && n > 100 - e[o] - s && (r = o),
        s += parseFloat(e[o])
    }
    ),
    r
}
  , M_ = e=>{
    const t = new Date(e);
    if (t instanceof Date)
        return new Date().getTime() > t.getTime()
}
  , B_ = e=>{
    const t = new Date(e);
    if (t instanceof Date)
        return new Date().getTime() < t.getTime()
}
  , TT = e=>new Promise(t=>setTimeout(t, e))
  , D_ = e=>{
    let t = Math.floor(e / 1e3 % 60)
      , n = Math.floor(e / (1e3 * 60) % 60)
      , r = Math.floor(e / (1e3 * 60 * 60) % 24);
    t = t < 10 ? "0" + t : t,
    n = n < 10 ? "0" + n : n;
    let s = `${n}:${t}`;
    return r && (r = r < 10 ? "0" + r : r,
    s = `${r}:${s}`),
    s
}
  , x_ = (e,t,n)=>{
    var a;
    if (!e || typeof e != "string")
        return;
    const {public: {hostUrl: r}} = kr()
      , [s,o] = e.split("/").reverse();
    let i = `${r}/share-image/${o}/${s}/${t}`;
    if ((a = Object.keys(n)) != null && a.length) {
        const l = new URLSearchParams(n).toString();
        i += `?${l}`
    }
    return i
}
;
function _T(e) {
    return e.toString(16).padStart(2, "0")
}
function F_(e) {
    const t = new Uint8Array((e || 24) / 2);
    return window.crypto.getRandomValues(t),
    Array.from(t, _T).join("")
}
var Eo, os, Yt, Co, hp, To, pp, _o, mp, is, Ja;
class ST {
    constructor(t) {
        je(this, Co);
        je(this, To);
        je(this, _o);
        je(this, is);
        je(this, Eo, 1e4);
        je(this, os, 1e3 * 10);
        je(this, Yt, !1);
        this.socket = t,
        this.socket.on("connect", on(this, To, pp).bind(this)),
        this.socket.on("disconnect", on(this, _o, mp).bind(this)),
        this.socket.io.on("error", on(this, Co, hp).bind(this))
    }
    emit(t, n={}, r=!1, s=!0) {
        if (Le(this, Yt)) {
            console.error("✕", t);
            return
        }
        const o = za();
        return r ? !s || o.logged ? (this.socket.emit(t, n, ()=>{}
        ),
        Promise.resolve()) : (af(()=>o.logged, ()=>{
            this.socket.emit(t, n, ()=>{}
            )
        }
        ),
        Promise.resolve()) : new Promise((i,a)=>{
            const l = setTimeout(()=>{
                a(new Error("Socket time out"))
            }
            , Le(this, Eo))
              , u = ()=>{
                this.socket.emit(t, n, c=>{
                    l && clearTimeout(l),
                    c && c.error ? a(c) : i(c)
                }
                )
            }
            ;
            !s || o.logged ? u() : af(()=>o.logged, u)
        }
        )
    }
    on(t, n) {
        this.socket.on(t, n)
    }
    off(t, n) {
        this.socket.off(t, n)
    }
}
Eo = new WeakMap,
os = new WeakMap,
Yt = new WeakMap,
Co = new WeakSet,
hp = function(t) {
    console.error("Socket error: ", t),
    !Le(this, Yt) && (Rn(this, Yt, !0),
    on(this, is, Ja).call(this))
}
,
To = new WeakSet,
pp = function() {
    Le(this, Yt) && za().auth(),
    Rn(this, Yt, !1)
}
,
_o = new WeakSet,
mp = function(t) {
    Rn(this, Yt, !0),
    t !== "io server disconnect" && on(this, is, Ja).call(this)
}
,
is = new WeakSet,
Ja = async function() {
    await TT(Le(this, os)),
    console.warn("Trying to reconnect socket...."),
    Rn(this, os, Le(this, os) + 2e3),
    this.socket.connect()
}
;
const kT = ke(e=>{
    const t = e.$nuxtSocket({
        name: "main"
    });
    return {
        provide: {
            socket: new ST(t)
        }
    }
}
)
  , RT = [Rb, Pb, V0, U0, q0, ow, iw, aw, zE, GE, rC, oC, aC, uC, dC, fT, dT, kT]
  , AT = De({
    props: {
        vnode: {
            type: Object,
            required: !0
        },
        route: {
            type: Object,
            required: !0
        },
        vnodeRef: Object,
        renderKey: String,
        trackRootNodes: Boolean
    },
    setup(e) {
        const t = e.renderKey
          , n = e.route
          , r = {};
        for (const s in e.route)
            Object.defineProperty(r, s, {
                get: ()=>t === e.renderKey ? e.route[s] : n[s]
            });
        return jn(gs, ls(r)),
        ()=>gt(e.vnode, {
            ref: e.vnodeRef
        })
    }
})
  , PT = De({
    name: "NuxtPage",
    inheritAttrs: !1,
    props: {
        name: {
            type: String
        },
        transition: {
            type: [Boolean, Object],
            default: void 0
        },
        keepalive: {
            type: [Boolean, Object],
            default: void 0
        },
        route: {
            type: Object
        },
        pageKey: {
            type: [Function, String],
            default: null
        }
    },
    setup(e, {attrs: t, expose: n}) {
        const r = ie()
          , s = pt()
          , o = Oe(gs, null);
        let i;
        n({
            pageRef: s
        });
        const a = Oe(Gd, null);
        let l;
        const u = r.deferHydration();
        if (r.isHydrating) {
            const c = r.hooks.hookOnce("app:error", u);
            xt().beforeEach(c)
        }
        return e.pageKey && mt(()=>e.pageKey, (c,f)=>{
            c !== f && r.callHook("page:loading:start")
        }
        ),
        ()=>gt(vh, {
            name: e.name,
            route: e.route,
            ...t
        }, {
            default: c=>{
                const f = IT(o, c.route, c.Component)
                  , d = o && o.matched.length === c.route.matched.length;
                if (!c.Component) {
                    if (l && !d)
                        return l;
                    u();
                    return
                }
                if (l && a && !a.isCurrent(c.route))
                    return l;
                if (f && o && (!a || a != null && a.isCurrent(o)))
                    return d ? l : null;
                const h = La(c, e.pageKey);
                !r.isHydrating && !LT(o, c.route, c.Component) && i === h && r.callHook("page:loading:end"),
                i = h;
                const m = !!(e.transition ?? c.route.meta.pageTransition ?? Ra)
                  , v = m && OT([e.transition, c.route.meta.pageTransition, Ra, {
                    onAfterLeave: ()=>{
                        r.callHook("page:transition:finish", c.Component)
                    }
                }].filter(Boolean))
                  , T = e.keepalive ?? c.route.meta.keepalive ?? bb;
                return l = bh(Ho, m && v, M0(T, gt(pc, {
                    suspensible: !0,
                    onPending: ()=>r.callHook("page:start", c.Component),
                    onResolve: ()=>{
                        Dt(()=>r.callHook("page:finish", c.Component).then(()=>r.callHook("page:loading:end")).finally(u))
                    }
                }, {
                    default: ()=>{
                        const k = gt(AT, {
                            key: h || void 0,
                            vnode: c.Component,
                            route: c.route,
                            renderKey: h || void 0,
                            trackRootNodes: m,
                            vnodeRef: s
                        });
                        return T && (k.type.name = c.Component.type.name || c.Component.type.__name || "RouteProvider"),
                        k
                    }
                }))).default(),
                l
            }
        })
    }
});
function OT(e) {
    const t = e.map(n=>({
        ...n,
        onAfterLeave: n.onAfterLeave ? Bc(n.onAfterLeave) : void 0
    }));
    return Kd(...t)
}
function IT(e, t, n) {
    if (!e)
        return !1;
    const r = t.matched.findIndex(s=>{
        var o;
        return ((o = s.components) == null ? void 0 : o.default) === (n == null ? void 0 : n.type)
    }
    );
    return !r || r === -1 ? !1 : t.matched.slice(0, r).some((s,o)=>{
        var i, a, l;
        return ((i = s.components) == null ? void 0 : i.default) !== ((l = (a = e.matched[o]) == null ? void 0 : a.components) == null ? void 0 : l.default)
    }
    ) || n && La({
        route: t,
        Component: n
    }) !== La({
        route: e,
        Component: n
    })
}
function LT(e, t, n) {
    return e ? t.matched.findIndex(s=>{
        var o;
        return ((o = s.components) == null ? void 0 : o.default) === (n == null ? void 0 : n.type)
    }
    ) < t.matched.length - 1 : !1
}
const NT = De({
    name: "LayoutLoader",
    inheritAttrs: !1,
    props: {
        name: String,
        layoutProps: Object
    },
    async setup(e, t) {
        const n = await bn[e.name]().then(r=>r.default || r);
        return ()=>gt(n, e.layoutProps, t.slots)
    }
})
  , MT = De({
    name: "NuxtLayout",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean, Object],
            default: null
        },
        fallback: {
            type: [String, Object],
            default: null
        }
    },
    setup(e, t) {
        const n = ie()
          , r = Oe(gs)
          , s = r === Gn() ? L0() : r
          , o = ft(()=>{
            let l = he(e.name) ?? s.meta.layout ?? "default";
            return l && !(l in bn) && e.fallback && (l = he(e.fallback)),
            l
        }
        )
          , i = pt();
        t.expose({
            layoutRef: i
        });
        const a = n.deferHydration();
        if (n.isHydrating) {
            const l = n.hooks.hookOnce("app:error", a);
            xt().beforeEach(l)
        }
        return ()=>{
            const l = o.value && o.value in bn
              , u = s.meta.layoutTransition ?? vb;
            return bh(Ho, l && u, {
                default: ()=>gt(pc, {
                    suspensible: !0,
                    onResolve: ()=>{
                        Dt(a)
                    }
                }, {
                    default: ()=>gt(BT, {
                        layoutProps: ps(t.attrs, {
                            ref: i
                        }),
                        key: o.value || void 0,
                        name: o.value,
                        shouldProvide: !e.name,
                        hasTransition: !!u
                    }, t.slots)
                })
            }).default()
        }
    }
})
  , BT = De({
    name: "NuxtLayoutProvider",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean]
        },
        layoutProps: {
            type: Object
        },
        hasTransition: {
            type: Boolean
        },
        shouldProvide: {
            type: Boolean
        }
    },
    setup(e, t) {
        const n = e.name;
        return e.shouldProvide && jn(Gd, {
            isCurrent: r=>n === (r.meta.layout ?? "default")
        }),
        ()=>{
            var r, s;
            return !n || typeof n == "string" && !(n in bn) ? (s = (r = t.slots).default) == null ? void 0 : s.call(r) : gt(NT, {
                key: n,
                layoutProps: e.layoutProps,
                name: n
            }, t.slots)
        }
    }
})
  , DT = ()=>{
    var r;
    const e = Uh()
      , t = Gn()
      , n = (r = window == null ? void 0 : window.Telegram) == null ? void 0 : r.WebApp;
    mt(()=>[e.telegramMiniAppReady, t.path], ([s,o])=>{
        var i, a;
        s && (o === "/" || o.includes("/reward") || o === "/free-crypto/boost" ? (i = n.BackButton) == null || i.hide() : (a = n.BackButton) == null || a.show())
    }
    , {
        immediate: !0
    })
}
  , xT = {
    __name: "app",
    setup(e) {
        var n, r, s;
        const t = za();
        DT();
        {
            const o = Gn()
              , i = o.hash;
            if (t.setAuthHash(i),
            i && i.startsWith("#tgWebAppData")) {
                const a = o.query.tgWebAppStartParam
                  , l = new URLSearchParams(i);
                let u = JSON.parse(decodeURIComponent(l.get("user")));
                const c = [`auth_date=${l.get("auth_date")}`];
                let f = [...c, `${l.get("#tgWebAppData")}`, `user=${decodeURIComponent(l.get("user"))}`].sort().join(`
`);
                const d = l.get("chat_instance");
                if (d) {
                    const v = new URLSearchParams(l.get("#tgWebAppData"));
                    try {
                        u = JSON.parse(v.get("user"))
                    } catch (T) {
                        console.error(T)
                    }
                    a && c.push(`start_param=${a}`),
                    f = [...c, `chat_instance=${d}`, `chat_type=${l.get("chat_type")}`, `user=${decodeURIComponent(v.get("user"))}`].sort().join(`
`)
                }
                const h = {};
                u != null && u.id && (h.telegram_id = u.id),
                (n = o.query) != null && n.rd_tg_notif && (h.rd_tg_notif = o.query.rd_tg_notif),
                (r = Object.keys(h)) != null && r.length && ((s = window == null ? void 0 : window.dataLayer) == null || s.push(h));
                const m = {
                    telegramId: u == null ? void 0 : u.id,
                    initDataHash: l.get("hash"),
                    dataToCheck: f,
                    userName: u == null ? void 0 : u.username,
                    lastName: u == null ? void 0 : u.last_name,
                    firstName: u == null ? void 0 : u.first_name
                };
                a && Object.assign(m, {
                    startAppParameter: a
                }),
                localStorage.setItem("telegramData", JSON.stringify(m)),
                t.setTelegramData(m)
            }
        }
        return t.auth(),
        (o,i)=>{
            const a = PT
              , l = MT;
            return ue(),
            Pe(l, null, {
                default: kn(()=>[ce(a)]),
                _: 1
            })
        }
    }
}
  , FT = xT
  , HT = {
    __name: "nuxt-error-page",
    props: {
        error: Object
    },
    setup(e) {
        const n = e.error;
        n.stack && n.stack.split(`
`).splice(1).map(f=>({
            text: f.replace("webpack:/", "").replace(".vue", ".js").trim(),
            internal: f.includes("node_modules") && !f.includes(".cache") || f.includes("internal") || f.includes("new Promise")
        })).map(f=>`<span class="stack${f.internal ? " internal" : ""}">${f.text}</span>`).join(`
`);
        const r = Number(n.statusCode || 500)
          , s = r === 404
          , o = n.statusMessage ?? (s ? "Page Not Found" : "Internal Server Error")
          , i = n.message || n.toString()
          , a = void 0
          , c = s ? dl(()=>J(()=>import("./DRFzsTBt.js"), __vite__mapDeps([178, 26, 118, 2, 179]), import.meta.url).then(f=>f.default || f)) : dl(()=>J(()=>import("./BR3gwn9N.js"), __vite__mapDeps([180, 118, 2, 181]), import.meta.url).then(f=>f.default || f));
        return (f,d)=>(ue(),
        Pe(he(c), kp(hd({
            statusCode: he(r),
            statusMessage: he(o),
            description: he(i),
            stack: he(a)
        })), null, 16))
    }
}
  , $T = HT
  , jT = {
    __name: "nuxt-root",
    setup(e) {
        const t = ()=>null
          , n = ie()
          , r = n.deferHydration();
        if (n.isHydrating) {
            const a = n.hooks.hookOnce("app:error", r);
            xt().beforeEach(a)
        }
        const s = !1;
        jn(gs, Gn()),
        n.hooks.callHookWith(a=>a.map(l=>l()), "vue:setup");
        const o = jo();
        Xf((a,l,u)=>{
            if (n.hooks.callHook("vue:error", a, l, u).catch(c=>console.error("[nuxt] Error in `vue:error` hook", c)),
            Sv(a) && (a.fatal || a.unhandled))
                return n.runWithContext(()=>rr(a)),
                !1
        }
        );
        const i = !1;
        return (a,l)=>(ue(),
        Pe(pc, {
            onResolve: he(r)
        }, {
            default: kn(()=>[he(o) ? (ue(),
            Pe(he($T), {
                key: 0,
                error: he(o)
            }, null, 8, ["error"])) : he(i) ? (ue(),
            Pe(he(t), {
                key: 1,
                context: he(i)
            }, null, 8, ["context"])) : he(s) ? (ue(),
            Pe(Bo(he(s)), {
                key: 2
            })) : (ue(),
            Pe(he(FT), {
                key: 3
            }))]),
            _: 1
        }, 8, ["onResolve"]))
    }
}
  , cf = jT;
let lf;
{
    let e;
    lf = async function() {
        var i, a;
        if (e)
            return e;
        const r = !!((i = window.__NUXT__) != null && i.serverRendered || ((a = document.getElementById("__NUXT_DATA__")) == null ? void 0 : a.dataset.ssr) === "true") ? Xg(cf) : Pd(cf)
          , s = nv({
            vueApp: r
        });
        async function o(l) {
            await s.callHook("app:error", l),
            s.payload.error = s.payload.error || Vo(l)
        }
        r.config.errorHandler = o;
        try {
            await sv(s, RT)
        } catch (l) {
            o(l)
        }
        try {
            await s.hooks.callHook("app:created", r),
            await s.hooks.callHook("app:beforeMount", r),
            r.mount(wb),
            await s.hooks.callHook("app:mounted", r),
            await Dt()
        } catch (l) {
            o(l)
        }
        return r.config.errorHandler === o && (r.config.errorHandler = void 0),
        r
    }
    ,
    e = lf().catch(t=>{
        throw console.error("Error while mounting app:", t),
        t
    }
    )
}
export {J as $, _r as A, Gn as B, xt as C, Jd as D, ie as E, Te as F, N_ as G, L_ as H, kr as I, __ as J, cT as K, u_ as L, za as M, fC as N, TT as O, D_ as P, gs as Q, Dc as R, QT as S, Ho as T, s_ as U, ve as V, F_ as W, x_ as X, De as Y, gt as Z, yc as _, Kn as a, PT as a$, B_ as a0, M_ as a1, Lm as a2, a_ as a3, zT as a4, Om as a5, Pm as a6, _a as a7, Gt as a8, zn as a9, hd as aA, m_ as aB, af as aC, Vy as aD, Ba as aE, T_ as aF, Ju as aG, C_ as aH, Uh as aI, y_ as aJ, g_ as aK, b_ as aL, v_ as aM, E_ as aN, w_ as aO, JT as aP, YT as aQ, t_ as aR, xc as aS, jn as aT, XT as aU, ZT as aV, n_ as aW, Kg as aX, xg as aY, o_ as aZ, dl as a_, wh as aa, Su as ab, l_ as ac, Dr as ad, Rc as ae, $o as af, hy as ag, c_ as ah, ya as ai, kc as aj, I_ as ak, P_ as al, O_ as am, Ga as an, vo as ao, R_ as ap, S_ as aq, A_ as ar, k_ as as, yT as at, Dt as au, r_ as av, WT as aw, i_ as ax, ps as ay, kp as az, ce as b, sC as b0, bc as b1, sw as b2, It as c, hs as d, qT as e, xd as f, oi as g, ds as h, vc as i, ft as j, mt as k, KT as l, GT as m, Pe as n, ue as o, UT as p, Bo as q, pt as r, nn as s, gf as t, he as u, hl as v, kn as w, en as x, e_ as y, xm as z};
